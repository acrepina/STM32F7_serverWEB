
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\partition.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\partition.o

Disassembly of section .text.part_isFatPart:

00000000 <part_isFatPart>:
part_isFatPart():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:67
 * type in the broadest sense. I
 * Return value: If it is FAT, returns 1, otherwise 0.
*/
eint16 part_isFatPart(euint8 type)
{
	if(type == PT_FAT12  ||
   0:	2801      	cmp	r0, #1
   2:	d00c      	beq.n	1e <part_isFatPart+0x1e>
   4:	2804      	cmp	r0, #4
   6:	d00a      	beq.n	1e <part_isFatPart+0x1e>
   8:	2806      	cmp	r0, #6
   a:	d008      	beq.n	1e <part_isFatPart+0x1e>
   c:	280b      	cmp	r0, #11
   e:	d006      	beq.n	1e <part_isFatPart+0x1e>
  10:	285c      	cmp	r0, #92
  12:	d004      	beq.n	1e <part_isFatPart+0x1e>
  14:	285e      	cmp	r0, #94
  16:	bf14      	ite	ne
  18:	2000      	movne	r0, #0
  1a:	2001      	moveq	r0, #1
  1c:	e000      	b.n	20 <part_isFatPart+0x20>
  1e:	2001      	movs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:77
	   type == PT_FAT16B   )
	{
		return(1);
	}
	return(0);
}
  20:	4770      	bx	lr
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.part_initPartition:

00000000 <part_initPartition>:
part_initPartition():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:49
void part_initPartition(Partition *part,Disc* refDisc)
{
	eint16 c;
	
	part->disc=refDisc;
	part->activePartition=-1; /* No partition selected */
   0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:45
 * void part_initPartition(Partition *part,Disc* refDisc)
 * Description: This function searches the 4 partitions for a FAT class partition
 * and marks the first one found as the active to be used partition.
*/
void part_initPartition(Partition *part,Disc* refDisc)
{
   4:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:48
	eint16 c;
	
	part->disc=refDisc;
   6:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:45
 * void part_initPartition(Partition *part,Disc* refDisc)
 * Description: This function searches the 4 partitions for a FAT class partition
 * and marks the first one found as the active to be used partition.
*/
void part_initPartition(Partition *part,Disc* refDisc)
{
   8:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:49
	eint16 c;
	
	part->disc=refDisc;
	part->activePartition=-1; /* No partition selected */
   a:	7103      	strb	r3, [r0, #4]
   c:	2403      	movs	r4, #3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:52
	part_setError(part,PART_NOERROR);
	for(c=3;c>=0;c--){
		if(part_isFatPart(part->disc->partitions[c].type))
   e:	682b      	ldr	r3, [r5, #0]
  10:	eb03 1304 	add.w	r3, r3, r4, lsl #4
  14:	7b18      	ldrb	r0, [r3, #12]
  16:	f7ff fffe 	bl	0 <part_initPartition>
  1a:	b280      	uxth	r0, r0
  1c:	b100      	cbz	r0, 20 <part_initPartition+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:53
			part->activePartition=c;
  1e:	712c      	strb	r4, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:51
	eint16 c;
	
	part->disc=refDisc;
	part->activePartition=-1; /* No partition selected */
	part_setError(part,PART_NOERROR);
	for(c=3;c>=0;c--){
  20:	3c01      	subs	r4, #1
  22:	d2f4      	bcs.n	e <part_initPartition+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:55
		if(part_isFatPart(part->disc->partitions[c].type))
			part->activePartition=c;
	} 
}
  24:	bd70      	pop	{r4, r5, r6, pc}
  26:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.part_getRealLBA:

00000000 <part_getRealLBA>:
part_getRealLBA():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:106
 * Description: This function calculates what the partition offset for
 * a partition is + the address.
 * Return value: Sector address.
*/
euint32 part_getRealLBA(Partition *part,euint32 address)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	f990 2004 	ldrsb.w	r2, [r0, #4]
   6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   a:	6918      	ldr	r0, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:108
	return(part->disc->partitions[part->activePartition].LBA_begin+address);
}
   c:	1808      	adds	r0, r1, r0
   e:	4770      	bx	lr
Disassembly of section .text.part_directSectorWrite:

00000000 <part_directSectorWrite>:
part_directSectorWrite():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:147
		ioman_directSectorRead(part->disc->ioman,part_getRealLBA(part,address),buf)
	);
}

esint8 part_directSectorWrite(Partition *part,euint32 address, euint8* buf)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:148
	return(
   6:	f7ff fffe 	bl	0 <part_directSectorWrite>
   a:	6823      	ldr	r3, [r4, #0]
   c:	4601      	mov	r1, r0
   e:	462a      	mov	r2, r5
  10:	6818      	ldr	r0, [r3, #0]
  12:	f7ff fffe 	bl	0 <ioman_directSectorWrite>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:151
		ioman_directSectorWrite(part->disc->ioman,part_getRealLBA(part,address),buf)
	);
}
  16:	b240      	sxtb	r0, r0
  18:	bd70      	pop	{r4, r5, r6, pc}
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.part_directSectorRead:

00000000 <part_directSectorRead>:
part_directSectorRead():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:140
		ioman_flushRange(part->disc->ioman,part_getRealLBA(part,addr_l),part_getRealLBA(part,addr_h)) 
	);	
}

esint8 part_directSectorRead(Partition *part,euint32 address, euint8* buf)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:141
	return(
   6:	f7ff fffe 	bl	0 <part_directSectorRead>
   a:	6823      	ldr	r3, [r4, #0]
   c:	4601      	mov	r1, r0
   e:	462a      	mov	r2, r5
  10:	6818      	ldr	r0, [r3, #0]
  12:	f7ff fffe 	bl	0 <ioman_directSectorRead>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:144
		ioman_directSectorRead(part->disc->ioman,part_getRealLBA(part,address),buf)
	);
}
  16:	b240      	sxtb	r0, r0
  18:	bd70      	pop	{r4, r5, r6, pc}
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.part_flushPart:

00000000 <part_flushPart>:
part_flushPart():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:133
{
	return(ioman_releaseSector(part->disc->ioman,buf));
}

esint8 part_flushPart(Partition *part,euint32 addr_l, euint32 addr_h)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4614      	mov	r4, r2
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:134
	return( 
   6:	f7ff fffe 	bl	0 <part_flushPart>
   a:	4621      	mov	r1, r4
   c:	4606      	mov	r6, r0
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <part_flushPart>
  14:	682b      	ldr	r3, [r5, #0]
  16:	4602      	mov	r2, r0
  18:	4631      	mov	r1, r6
  1a:	6818      	ldr	r0, [r3, #0]
  1c:	f7ff fffe 	bl	0 <ioman_flushRange>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:137
		ioman_flushRange(part->disc->ioman,part_getRealLBA(part,addr_l),part_getRealLBA(part,addr_h)) 
	);	
}
  20:	b240      	sxtb	r0, r0
  22:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.part_relSect:

00000000 <part_relSect>:
part_relSect():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:129
 * Description: This function calls ioman_releaseSector.
 * Return value: Whatever releaseSector returns.
*/
esint8 part_relSect(Partition *part, euint8* buf)
{
	return(ioman_releaseSector(part->disc->ioman,buf));
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:128
 * esint8 part_relSect(Partition *part, euint8* buf)
 * Description: This function calls ioman_releaseSector.
 * Return value: Whatever releaseSector returns.
*/
esint8 part_relSect(Partition *part, euint8* buf)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:129
	return(ioman_releaseSector(part->disc->ioman,buf));
   4:	6818      	ldr	r0, [r3, #0]
   6:	f7ff fffe 	bl	0 <ioman_releaseSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:130
}
   a:	b240      	sxtb	r0, r0
   c:	bd10      	pop	{r4, pc}
   e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.part_getSect:

00000000 <part_getSect>:
part_getSect():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:118
 * Description: This function calls ioman_getSector, but recalculates the sector
 * address to be partition relative.
 * Return value: Whatever getSector returns. (pointer or 0)
*/
euint8* part_getSect(Partition *part, euint32 address, euint8 mode)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:119
	return(ioman_getSector(part->disc->ioman,part_getRealLBA(part,address),mode));
   6:	f7ff fffe 	bl	0 <part_getSect>
   a:	6823      	ldr	r3, [r4, #0]
   c:	4601      	mov	r1, r0
   e:	462a      	mov	r2, r5
  10:	6818      	ldr	r0, [r3, #0]
  12:	f7ff fffe 	bl	0 <ioman_getSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:120
}
  16:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.part_writeBuf:

00000000 <part_writeBuf>:
part_writeBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:92
 * Description: This function writes 512 bytes, from buf. It's offset is address
 * sectors from the beginning of the partition.
 * Return value: It returns whatever the hardware function returns. (-1=error)
*/
eint16 part_writeBuf(Partition *part,euint32 address,euint8* buf)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:94
	/*DBG((TXT("part_writeBuf :: %li\n"),address));*/
	return(if_writeBuf(part->disc->ioman->iface,part_getRealLBA(part,address),buf));
   6:	f7ff fffe 	bl	0 <part_writeBuf>
   a:	6823      	ldr	r3, [r4, #0]
   c:	4601      	mov	r1, r0
   e:	681b      	ldr	r3, [r3, #0]
  10:	462a      	mov	r2, r5
  12:	6818      	ldr	r0, [r3, #0]
  14:	f7ff fffe 	bl	0 <if_writeBuf>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:95
}
  18:	b240      	sxtb	r0, r0
  1a:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.part_readBuf:

00000000 <part_readBuf>:
part_readBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:81
	return(0);
}
/*****************************************************************************/ 

esint8 part_readBuf(Partition *part, euint32 address, euint8* buf)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:82
	return(if_readBuf(part->disc->ioman->iface,part_getRealLBA(part,address), buf));
   6:	f7ff fffe 	bl	0 <part_readBuf>
   a:	6823      	ldr	r3, [r4, #0]
   c:	4601      	mov	r1, r0
   e:	681b      	ldr	r3, [r3, #0]
  10:	462a      	mov	r2, r5
  12:	6818      	ldr	r0, [r3, #0]
  14:	f7ff fffe 	bl	0 <if_readBuf>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/partition.c:83
}
  18:	b240      	sxtb	r0, r0
  1a:	bd70      	pop	{r4, r5, r6, pc}
