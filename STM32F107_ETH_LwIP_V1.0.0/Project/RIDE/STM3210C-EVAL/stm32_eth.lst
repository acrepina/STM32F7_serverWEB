
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32_eth.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32_eth.o

Disassembly of section .text.ETH_StructInit:

00000000 <ETH_StructInit>:
ETH_StructInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:460
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                         
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;                                                                
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;                                                               
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;                                
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;          
   0:	2240      	movs	r2, #64
   2:	6402      	str	r2, [r0, #64]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:461
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
   4:	2220      	movs	r2, #32
   6:	6442      	str	r2, [r0, #68]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:469
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;      
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
   8:	3260      	adds	r2, #96
   a:	6642      	str	r2, [r0, #100]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:477
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
   c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:444
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC   -----------------------------------*/     
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;           
  10:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:477
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  12:	f8c0 2080 	str.w	r2, [r0, #128]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:478
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  16:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:479
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  1a:	f102 427d 	add.w	r2, r2, #4244635648	; 0xfd000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:444
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC   -----------------------------------*/     
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;           
  1e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:445
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;                   
  20:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:446
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                     
  22:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:447
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                          
  24:	60c3      	str	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:448
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                              
  26:	6103      	str	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:449
  ETH_InitStruct->ETH_Speed = ETH_Speed_10M;                       
  28:	6143      	str	r3, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:450
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;               
  2a:	6183      	str	r3, [r0, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:451
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
  2c:	61c3      	str	r3, [r0, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:452
  ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;                       
  2e:	6203      	str	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:453
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                            
  30:	6243      	str	r3, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:454
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                  
  32:	6283      	str	r3, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:455
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                         
  34:	62c3      	str	r3, [r0, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:456
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;                                                                
  36:	6303      	str	r3, [r0, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:457
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
  38:	6343      	str	r3, [r0, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:458
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;                                                               
  3a:	6383      	str	r3, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:459
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;                                
  3c:	63c3      	str	r3, [r0, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:462
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;          
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;      
  3e:	6483      	str	r3, [r0, #72]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:463
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
  40:	64c3      	str	r3, [r0, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:464
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;      
  42:	6503      	str	r3, [r0, #80]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:465
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
  44:	6543      	str	r3, [r0, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:466
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  46:	6583      	str	r3, [r0, #88]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:467
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  48:	65c3      	str	r3, [r0, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:468
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  4a:	6603      	str	r3, [r0, #96]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:470
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
  4c:	6683      	str	r3, [r0, #104]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:471
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
  4e:	66c3      	str	r3, [r0, #108]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:472
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
  50:	6703      	str	r3, [r0, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:473
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
  52:	6743      	str	r3, [r0, #116]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:474
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
  54:	6783      	str	r3, [r0, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:475
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  56:	67c3      	str	r3, [r0, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:478
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  58:	f8c0 1084 	str.w	r1, [r0, #132]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:479
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  5c:	f8c0 2088 	str.w	r2, [r0, #136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:480
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
  60:	f5a2 0260 	sub.w	r2, r2, #14680064	; 0xe00000
  64:	f8c0 208c 	str.w	r2, [r0, #140]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:488
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  68:	f5a2 12f0 	sub.w	r2, r2, #1966080	; 0x1e0000
  6c:	f8c0 20ac 	str.w	r2, [r0, #172]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:489
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
  70:	f44f 7280 	mov.w	r2, #256	; 0x100
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:481
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
  74:	f8c0 3090 	str.w	r3, [r0, #144]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:482
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
  78:	f8c0 3094 	str.w	r3, [r0, #148]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:483
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
  7c:	f8c0 3098 	str.w	r3, [r0, #152]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:484
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
  80:	f8c0 309c 	str.w	r3, [r0, #156]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:485
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  84:	f8c0 30a0 	str.w	r3, [r0, #160]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:486
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  88:	f8c0 10a4 	str.w	r1, [r0, #164]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:487
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
  8c:	f8c0 30a8 	str.w	r3, [r0, #168]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:489
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
  90:	f8c0 20b0 	str.w	r2, [r0, #176]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:490
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0;
  94:	f8c0 30b4 	str.w	r3, [r0, #180]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:491
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
  98:	f8c0 30b8 	str.w	r3, [r0, #184]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:492
}
  9c:	4770      	bx	lr
  9e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_HandleTxPkt:

00000000 <ETH_HandleTxPkt>:
ETH_HandleTxPkt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:526
uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength)
{ 
  uint32_t offset = 0;
    
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   0:	4b1e      	ldr	r3, [pc, #120]	(7c <ETH_HandleTxPkt+0x7c>)
   2:	681b      	ldr	r3, [r3, #0]
   4:	681b      	ldr	r3, [r3, #0]
   6:	2b00      	cmp	r3, #0
   8:	da01      	bge.n	e <ETH_HandleTxPkt+0xe>
   a:	2000      	movs	r0, #0
   c:	e035      	b.n	7a <ETH_HandleTxPkt+0x7a>
   e:	f04f 0c00 	mov.w	ip, #0	; 0x0
  12:	e007      	b.n	24 <ETH_HandleTxPkt+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:535
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  14:	6813      	ldr	r3, [r2, #0]
  16:	689a      	ldr	r2, [r3, #8]
  18:	f810 300c 	ldrb.w	r3, [r0, ip]
  1c:	f80c 3002 	strb.w	r3, [ip, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:533
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
  20:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  24:	458c      	cmp	ip, r1
  26:	4a15      	ldr	r2, [pc, #84]	(7c <ETH_HandleTxPkt+0x7c>)
  28:	d3f4      	bcc.n	14 <ETH_HandleTxPkt+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:539
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
        
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
  2a:	6810      	ldr	r0, [r2, #0]
  2c:	04cb      	lsls	r3, r1, #19
  2e:	0cdb      	lsrs	r3, r3, #19
  30:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:543
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  32:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:545
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  34:	4a12      	ldr	r2, [pc, #72]	(80 <ETH_HandleTxPkt+0x80>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:543
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  36:	f043 4130 	orr.w	r1, r3, #2952790016	; 0xb0000000
  3a:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:545
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  3c:	6813      	ldr	r3, [r2, #0]
  3e:	f013 0f04 	tst.w	r3, #4	; 0x4
  42:	d004      	beq.n	4e <ETH_HandleTxPkt+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:548
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
  44:	2304      	movs	r3, #4
  46:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:550
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  48:	4b0e      	ldr	r3, [pc, #56]	(84 <ETH_HandleTxPkt+0x84>)
  4a:	2200      	movs	r2, #0
  4c:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:555
  }
  
  /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */  
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
  4e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  52:	d003      	beq.n	5c <ETH_HandleTxPkt+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:558
  {     
    /* Selects the next DMA Tx descriptor list for next buffer to send */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);    
  54:	68c2      	ldr	r2, [r0, #12]
  56:	4b09      	ldr	r3, [pc, #36]	(7c <ETH_HandleTxPkt+0x7c>)
  58:	601a      	str	r2, [r3, #0]
  5a:	e00d      	b.n	78 <ETH_HandleTxPkt+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:562
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
  5c:	f411 1f00 	tst.w	r1, #2097152	; 0x200000
  60:	4a06      	ldr	r2, [pc, #24]	(7c <ETH_HandleTxPkt+0x7c>)
  62:	d002      	beq.n	6a <ETH_HandleTxPkt+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:565
    {
      /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);      
  64:	4b08      	ldr	r3, [pc, #32]	(88 <ETH_HandleTxPkt+0x88>)
  66:	681b      	ldr	r3, [r3, #0]
  68:	e005      	b.n	76 <ETH_HandleTxPkt+0x76>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:570
    }
    else
    {  
      /* Selects the next DMA Tx descriptor list for next buffer to send */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  6a:	4b08      	ldr	r3, [pc, #32]	(8c <ETH_HandleTxPkt+0x8c>)
  6c:	681b      	ldr	r3, [r3, #0]
  6e:	f3c3 0384 	ubfx	r3, r3, #2, #5
  72:	3310      	adds	r3, #16
  74:	18c3      	adds	r3, r0, r3
  76:	6013      	str	r3, [r2, #0]
  78:	2001      	movs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:575
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
}
  7a:	4770      	bx	lr
  7c:	00000000 	.word	0x00000000
  80:	40029014 	.word	0x40029014
  84:	40029004 	.word	0x40029004
  88:	40029010 	.word	0x40029010
  8c:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_HandleRxPkt:

00000000 <ETH_HandleRxPkt>:
ETH_HandleRxPkt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:587
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   0:	4b22      	ldr	r3, [pc, #136]	(8c <ETH_HandleRxPkt+0x8c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:584
  * @param  ppkt: pointer to the application packet receive buffer.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
   2:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:587
  uint32_t offset = 0, framelength = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
   4:	681b      	ldr	r3, [r3, #0]
   6:	681b      	ldr	r3, [r3, #0]
   8:	2b00      	cmp	r3, #0
   a:	da01      	bge.n	10 <ETH_HandleRxPkt+0x10>
   c:	2000      	movs	r0, #0
   e:	e03b      	b.n	88 <ETH_HandleRxPkt+0x88>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:593
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
  10:	f413 4200 	ands.w	r2, r3, #32768	; 0x8000
  14:	d112      	bne.n	3c <ETH_HandleRxPkt+0x3c>
  16:	f413 7f80 	tst.w	r3, #256	; 0x100
  1a:	d00f      	beq.n	3c <ETH_HandleRxPkt+0x3c>
  1c:	f413 7f00 	tst.w	r3, #512	; 0x200
  20:	d00c      	beq.n	3c <ETH_HandleRxPkt+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:598
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
  22:	f3c3 430d 	ubfx	r3, r3, #16, #14
  26:	1f18      	subs	r0, r3, #4
  28:	e005      	b.n	36 <ETH_HandleRxPkt+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:602
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet->Buffer1Addr) + offset));
  2a:	4b18      	ldr	r3, [pc, #96]	(8c <ETH_HandleRxPkt+0x8c>)
  2c:	681b      	ldr	r3, [r3, #0]
  2e:	689b      	ldr	r3, [r3, #8]
  30:	5cd3      	ldrb	r3, [r2, r3]
  32:	548b      	strb	r3, [r1, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:600
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
  34:	3201      	adds	r2, #1
  36:	4282      	cmp	r2, r0
  38:	d3f7      	bcc.n	2a <ETH_HandleRxPkt+0x2a>
  3a:	e000      	b.n	3e <ETH_HandleRxPkt+0x3e>
  3c:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:611
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  }
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN; 
  3e:	4b13      	ldr	r3, [pc, #76]	(8c <ETH_HandleRxPkt+0x8c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:614
 
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
  40:	4a13      	ldr	r2, [pc, #76]	(90 <ETH_HandleRxPkt+0x90>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:611
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  }
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN; 
  42:	6819      	ldr	r1, [r3, #0]
  44:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  48:	600b      	str	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:614
 
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
  4a:	6813      	ldr	r3, [r2, #0]
  4c:	f013 0f80 	tst.w	r3, #128	; 0x80
  50:	d004      	beq.n	5c <ETH_HandleRxPkt+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:617
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
  52:	2380      	movs	r3, #128
  54:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:619
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
  56:	4b0f      	ldr	r3, [pc, #60]	(94 <ETH_HandleRxPkt+0x94>)
  58:	2200      	movs	r2, #0
  5a:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:624
  }
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */      
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
  5c:	684b      	ldr	r3, [r1, #4]
  5e:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  62:	d003      	beq.n	6c <ETH_HandleRxPkt+0x6c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:627
  {     
    /* Selects the next DMA Rx descriptor list for next buffer to read */ 
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
  64:	68ca      	ldr	r2, [r1, #12]
  66:	4b09      	ldr	r3, [pc, #36]	(8c <ETH_HandleRxPkt+0x8c>)
  68:	601a      	str	r2, [r3, #0]
  6a:	e00d      	b.n	88 <ETH_HandleRxPkt+0x88>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:631
  }
  else /* Ring Mode */
  {   
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  6c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  70:	4a06      	ldr	r2, [pc, #24]	(8c <ETH_HandleRxPkt+0x8c>)
  72:	d002      	beq.n	7a <ETH_HandleRxPkt+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:634
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);      
  74:	4b08      	ldr	r3, [pc, #32]	(98 <ETH_HandleRxPkt+0x98>)
  76:	681b      	ldr	r3, [r3, #0]
  78:	e005      	b.n	86 <ETH_HandleRxPkt+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:639
    }
    else
    { 
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  7a:	4b08      	ldr	r3, [pc, #32]	(9c <ETH_HandleRxPkt+0x9c>)
  7c:	681b      	ldr	r3, [r3, #0]
  7e:	f3c3 0384 	ubfx	r3, r3, #2, #5
  82:	3310      	adds	r3, #16
  84:	18cb      	adds	r3, r1, r3
  86:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:645
    }
  }
  
  /* Return Frame Length/ERROR */
  return (framelength);  
}
  88:	4770      	bx	lr
  8a:	46c0      	nop			(mov r8, r8)
  8c:	00000000 	.word	0x00000000
  90:	40029014 	.word	0x40029014
  94:	40029008 	.word	0x40029008
  98:	4002900c 	.word	0x4002900c
  9c:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_DropRxPkt:

00000000 <ETH_DropRxPkt>:
ETH_DropRxPkt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:676
  * @retval None
  */
void ETH_DropRxPkt(void)
{
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN;  
   0:	490c      	ldr	r1, [pc, #48]	(34 <ETH_DropRxPkt+0x34>)
   2:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   6:	680a      	ldr	r2, [r1, #0]
   8:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:678
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
   a:	6853      	ldr	r3, [r2, #4]
   c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  10:	d001      	beq.n	16 <ETH_DropRxPkt+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:681
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
  12:	68d3      	ldr	r3, [r2, #12]
  14:	e00b      	b.n	2e <ETH_DropRxPkt+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:685
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  16:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  1a:	d002      	beq.n	22 <ETH_DropRxPkt+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:689
    {
      /* Selects the next DMA Rx descriptor list for next buffer read: this will
         be the first Rx descriptor in this case */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
  1c:	4b06      	ldr	r3, [pc, #24]	(38 <ETH_DropRxPkt+0x38>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	e005      	b.n	2e <ETH_DropRxPkt+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:694
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));
  22:	4b06      	ldr	r3, [pc, #24]	(3c <ETH_DropRxPkt+0x3c>)
  24:	681b      	ldr	r3, [r3, #0]
  26:	f3c3 0384 	ubfx	r3, r3, #2, #5
  2a:	3310      	adds	r3, #16
  2c:	18d3      	adds	r3, r2, r3
  2e:	600b      	str	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:697
    }
  }
}
  30:	4770      	bx	lr
  32:	46c0      	nop			(mov r8, r8)
  34:	00000000 	.word	0x00000000
  38:	4002900c 	.word	0x4002900c
  3c:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_ReadPHYRegister:

00000000 <ETH_ReadPHYRegister>:
ETH_ReadPHYRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:716
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
   0:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:722
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   2:	4a14      	ldr	r2, [pc, #80]	(58 <ETH_ReadPHYRegister+0x58>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:714
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
   4:	b082      	sub	sp, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:716
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
   6:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:722
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   8:	6913      	ldr	r3, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:726
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
   a:	02c0      	lsls	r0, r0, #11
   c:	0400      	lsls	r0, r0, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:724
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
   e:	f003 031c 	and.w	r3, r3, #28	; 0x1c
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:726
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  12:	0c00      	lsrs	r0, r0, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:727
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  14:	0189      	lsls	r1, r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:726
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  16:	4318      	orrs	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:727
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  18:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:728
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  1c:	4308      	orrs	r0, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:729
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  1e:	f040 0001 	orr.w	r0, r0, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:731
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  22:	6110      	str	r0, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:735
  /* Check for the Busy flag */
  do
  {
    timeout++;
  24:	9b01      	ldr	r3, [sp, #4]
  26:	3301      	adds	r3, #1
  28:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:736
    tmpreg = ETH->MACMIIAR;
  2a:	4b0a      	ldr	r3, [pc, #40]	(58 <ETH_ReadPHYRegister+0x58>)
  2c:	691b      	ldr	r3, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:737
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
  2e:	f013 0f01 	tst.w	r3, #1	; 0x1
  32:	d003      	beq.n	40 <ETH_ReadPHYRegister+0x40>
  34:	9a01      	ldr	r2, [sp, #4]
  36:	4b08      	ldr	r3, [pc, #32]	(5c <ETH_ReadPHYRegister+0x5c>)
  38:	429a      	cmp	r2, r3
  3a:	d9f3      	bls.n	28 <ETH_ReadPHYRegister+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:739
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  3c:	9a01      	ldr	r2, [sp, #4]
  3e:	4b07      	ldr	r3, [pc, #28]	(60 <ETH_StructInit+0x60>)
  40:	429a      	cmp	r2, r3
  42:	d101      	bne.n	4c <ETH_ReadPHYRegister+0x4c>
  44:	2000      	movs	r0, #0
  46:	e002      	b.n	52 <ETH_ReadPHYRegister+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:745
  {
    return (uint16_t)ETH_ERROR;
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
  48:	4b02      	ldr	r3, [pc, #8]	(58 <ETH_ReadPHYRegister+0x58>)
  4a:	695b      	ldr	r3, [r3, #20]
  4c:	b298      	uxth	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:746
}
  4e:	b002      	add	sp, #8
  50:	4770      	bx	lr
  52:	46c0      	nop			(mov r8, r8)
  54:	40028000 	.word	0x40028000
  58:	0004fffe 	.word	0x0004fffe
  5c:	0004ffff 	.word	0x0004ffff
Disassembly of section .text.ETH_WritePHYRegister:

00000000 <ETH_WritePHYRegister>:
ETH_WritePHYRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:761
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
   0:	b513      	push	{r0, r1, r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:763
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:769
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   4:	4c11      	ldr	r4, [pc, #68]	(50 <ETH_WritePHYRegister+0x50>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:763
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
   6:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:769
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   8:	6923      	ldr	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:775
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
   a:	02c0      	lsls	r0, r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:771
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
   c:	f003 031c 	and.w	r3, r3, #28	; 0x1c
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:775
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  10:	0400      	lsls	r0, r0, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:774
  tmpreg = ETH->MACMIIAR;
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  12:	f043 0303 	orr.w	r3, r3, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:775
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  16:	0c00      	lsrs	r0, r0, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:776
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  18:	0189      	lsls	r1, r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:775
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  1a:	4303      	orrs	r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:776
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  1c:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
  20:	430b      	orrs	r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:778
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  22:	6162      	str	r2, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:780
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  24:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:784
  /* Check for the Busy flag */
  do
  {
    timeout++;
  26:	9b01      	ldr	r3, [sp, #4]
  28:	3301      	adds	r3, #1
  2a:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:785
    tmpreg = ETH->MACMIIAR;
  2c:	4b07      	ldr	r3, [pc, #28]	(50 <ETH_WritePHYRegister+0x50>)
  2e:	691b      	ldr	r3, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:786
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
  30:	f013 0f01 	tst.w	r3, #1	; 0x1
  34:	d003      	beq.n	42 <ETH_WritePHYRegister+0x42>
  36:	9a01      	ldr	r2, [sp, #4]
  38:	4b05      	ldr	r3, [pc, #20]	(54 <ETH_WritePHYRegister+0x54>)
  3a:	429a      	cmp	r2, r3
  3c:	d9f3      	bls.n	2a <ETH_WritePHYRegister+0x2a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:788
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
  3e:	9b01      	ldr	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:795
    return ETH_ERROR;
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;  
}
  40:	4804      	ldr	r0, [pc, #16]	(58 <ETH_StructInit+0x58>)
  42:	1a18      	subs	r0, r3, r0
  44:	bf18      	it	ne
  46:	2001      	movne	r0, #1
  48:	bd1c      	pop	{r2, r3, r4, pc}
  4a:	46c0      	nop			(mov r8, r8)
  4c:	40028000 	.word	0x40028000
  50:	0004fffe 	.word	0x0004fffe
  54:	0004ffff 	.word	0x0004ffff
Disassembly of section .text.ETH_PHYLoopBackCmd:

00000000 <ETH_PHYLoopBackCmd>:
ETH_PHYLoopBackCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:809
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:816
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
   4:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:809
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
   6:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:816
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
   8:	f7ff fffe 	bl	0 <ETH_PHYLoopBackCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:818
  
  if (NewState != DISABLE)
   c:	b11c      	cbz	r4, 16 <ETH_PHYLoopBackCmd+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:821
  {
    /* Enable the PHY loopback mode */
    tmpreg |= PHY_Loopback;  
   e:	f440 4380 	orr.w	r3, r0, #16384	; 0x4000
  12:	b29a      	uxth	r2, r3
  14:	e003      	b.n	1e <ETH_PHYLoopBackCmd+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:826
  }
  else
  {
    /* Disable the PHY loopback mode: normal mode */
    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
  16:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  1a:	ea00 0202 	and.w	r2, r0, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:829
  }
  /* Update the PHY control register with the new configuration */
  if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
  1e:	4628      	mov	r0, r5
  20:	2100      	movs	r1, #0
  22:	f7ff fffe 	bl	0 <ETH_PHYLoopBackCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:838
  else
  {
    /* Return SUCCESS */
    return ETH_ERROR; 
  }   
}
  26:	3800      	subs	r0, #0
  28:	bf18      	it	ne
  2a:	2001      	movne	r0, #1
  2c:	bd70      	pop	{r4, r5, r6, pc}
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_MACTransmissionCmd:

00000000 <ETH_MACTransmissionCmd>:
ETH_MACTransmissionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:852
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   0:	b120      	cbz	r0, c <ETH_MACTransmissionCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:855
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MACTransmissionCmd+0x18>)
   4:	6813      	ldr	r3, [r2, #0]
   6:	f043 0308 	orr.w	r3, r3, #8	; 0x8
   a:	e003      	b.n	14 <ETH_MACTransmissionCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:860
  }
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_MACTransmissionCmd+0x18>)
   e:	6813      	ldr	r3, [r2, #0]
  10:	f023 0308 	bic.w	r3, r3, #8	; 0x8
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:862
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MACReceptionCmd:

00000000 <ETH_MACReceptionCmd>:
ETH_MACReceptionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:875
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   0:	b120      	cbz	r0, c <ETH_MACReceptionCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:878
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MACReceptionCmd+0x18>)
   4:	6813      	ldr	r3, [r2, #0]
   6:	f043 0304 	orr.w	r3, r3, #4	; 0x4
   a:	e003      	b.n	14 <ETH_MACReceptionCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:883
  }
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_MACReceptionCmd+0x18>)
   e:	6813      	ldr	r3, [r2, #0]
  10:	f023 0304 	bic.w	r3, r3, #4	; 0x4
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:885
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetFlowControlBusyStatus:

00000000 <ETH_GetFlowControlBusyStatus>:
ETH_GetFlowControlBusyStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:896
  */
FlagStatus ETH_GetFlowControlBusyStatus(void)
{
  FlagStatus bitstatus = RESET;
  /* The Flow Control register should not be written to until this bit is cleared */
  if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
   0:	4b02      	ldr	r3, [pc, #8]	(c <ETH_GetFlowControlBusyStatus+0xc>)
   2:	6998      	ldr	r0, [r3, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:905
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	f000 0001 	and.w	r0, r0, #1	; 0x1
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_InitiatePauseControlFrame:

00000000 <ETH_InitiatePauseControlFrame>:
ETH_InitiatePauseControlFrame():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:915
  * @retval None
  */
void ETH_InitiatePauseControlFrame(void)  
{ 
  /* When Set In full duplex MAC initiates pause control frame */
  ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_InitiatePauseControlFrame+0xc>)
   2:	6993      	ldr	r3, [r2, #24]
   4:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   8:	6193      	str	r3, [r2, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:916
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_BackPressureActivationCmd:

00000000 <ETH_BackPressureActivationCmd>:
ETH_BackPressureActivationCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:929
void ETH_BackPressureActivationCmd(FunctionalState NewState)   
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
   0:	b120      	cbz	r0, c <ETH_BackPressureActivationCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:934
  {
    /* Activate the MAC BackPressure operation */
    /* In Half duplex: during backpressure, when the MAC receives a new frame,
    the transmitter starts sending a JAM pattern resulting in a collision */
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_BackPressureActivationCmd+0x18>)
   4:	6993      	ldr	r3, [r2, #24]
   6:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   a:	e003      	b.n	14 <ETH_BackPressureActivationCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:939
  }
  else
  {
    /* Desactivate the MAC BackPressure operation */
    ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_BackPressureActivationCmd+0x18>)
   e:	6993      	ldr	r3, [r2, #24]
  10:	f023 0301 	bic.w	r3, r3, #1	; 0x1
  14:	6193      	str	r3, [r2, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:941
  } 
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetMACFlagStatus:

00000000 <ETH_GetMACFlagStatus>:
ETH_GetMACFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:959
FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
  if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_GetMACFlagStatus+0x10>)
   2:	6b9b      	ldr	r3, [r3, #56]
   4:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:968
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetMACITStatus:

00000000 <ETH_GetMACITStatus>:
ETH_GetMACITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:986
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
  if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_GetMACITStatus+0x10>)
   2:	6b9b      	ldr	r3, [r3, #56]
   4:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:995
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MACITConfig:

00000000 <ETH_MACITConfig>:
ETH_MACITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1014
{
  /* Check the parameters */
  assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
   0:	b121      	cbz	r1, c <ETH_MACITConfig+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1017
  {
    /* Enable the selected ETHERNET MAC interrupts */
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MACITConfig+0x18>)
   4:	6bd3      	ldr	r3, [r2, #60]
   6:	ea23 0300 	bic.w	r3, r3, r0
   a:	e003      	b.n	14 <ETH_MACITConfig+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1022
  }
  else
  {
    /* Disable the selected ETHERNET MAC interrupts */
    ETH->MACIMR |= ETH_MAC_IT;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_MACITConfig+0x18>)
   e:	6bd3      	ldr	r3, [r2, #60]
  10:	ea40 0303 	orr.w	r3, r0, r3
  14:	63d3      	str	r3, [r2, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1024
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MACAddressConfig:

00000000 <ETH_MACAddressConfig>:
ETH_MACAddressConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1044
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selectecd MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
   0:	794a      	ldrb	r2, [r1, #5]
   2:	790b      	ldrb	r3, [r1, #4]
   4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1046
  /* Load the selectecd MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
   8:	4a07      	ldr	r2, [pc, #28]	(28 <ETH_MACAddressConfig+0x28>)
   a:	5083      	str	r3, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1048
  /* Calculate the selectecd MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
   c:	788b      	ldrb	r3, [r1, #2]
   e:	78ca      	ldrb	r2, [r1, #3]
  10:	041b      	lsls	r3, r3, #16
  12:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  16:	780a      	ldrb	r2, [r1, #0]
  18:	4313      	orrs	r3, r2
  1a:	784a      	ldrb	r2, [r1, #1]
  1c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1051
 
  /* Load the selectecd MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
  20:	4a02      	ldr	r2, [pc, #8]	(2c <ETH_MACAddressConfig+0x2c>)
  22:	5083      	str	r3, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1052
}
  24:	4770      	bx	lr
  26:	46c0      	nop			(mov r8, r8)
  28:	40028040 	.word	0x40028040
  2c:	40028044 	.word	0x40028044
Disassembly of section .text.ETH_GetMACAddress:

00000000 <ETH_GetMACAddress>:
ETH_GetMACAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1072
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Get the selectecd MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
   0:	4b07      	ldr	r3, [pc, #28]	(20 <ETH_GetMACAddress+0x20>)
   2:	58c2      	ldr	r2, [r0, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1075
 
  /* Calculate the selectecd MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
   4:	0a13      	lsrs	r3, r2, #8
   6:	714b      	strb	r3, [r1, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1078
  Addr[4] = (tmpreg & (uint8_t)0xFF);
  /* Load the selectecd MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
   8:	4b06      	ldr	r3, [pc, #24]	(24 <ETH_GetMACAddress+0x24>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1076
  /* Get the selectecd MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
 
  /* Calculate the selectecd MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
  Addr[4] = (tmpreg & (uint8_t)0xFF);
   a:	710a      	strb	r2, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1078
  /* Load the selectecd MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
   c:	58c2      	ldr	r2, [r0, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1080
  /* Calculate the selectecd MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
   e:	0e13      	lsrs	r3, r2, #24
  10:	70cb      	strb	r3, [r1, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1081
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
  12:	0c13      	lsrs	r3, r2, #16
  14:	708b      	strb	r3, [r1, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1082
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
  16:	0a13      	lsrs	r3, r2, #8
  18:	704b      	strb	r3, [r1, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1083
  Addr[0] = (tmpreg & (uint8_t)0xFF);
  1a:	700a      	strb	r2, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1084
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028040 	.word	0x40028040
  24:	40028044 	.word	0x40028044
Disassembly of section .text.ETH_MACAddressPerfectFilterCmd:

00000000 <ETH_MACAddressPerfectFilterCmd>:
ETH_MACAddressPerfectFilterCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1099
  * @param  NewState: new state of the specified ETHERNET MAC address use.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
{
   0:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MACAddressPerfectFilterCmd+0x18>)
   2:	1882      	adds	r2, r0, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1104
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
   4:	b119      	cbz	r1, e <ETH_MACAddressPerfectFilterCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1107
  {
    /* Enable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
   6:	6813      	ldr	r3, [r2, #0]
   8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   c:	e002      	b.n	14 <ETH_MACAddressPerfectFilterCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1112
  }
  else
  {
    /* Disable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
   e:	6813      	ldr	r3, [r2, #0]
  10:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1114
  }
}
  16:	4770      	bx	lr
  18:	40028040 	.word	0x40028040
Disassembly of section .text.ETH_MACAddressFilterConfig:

00000000 <ETH_MACAddressFilterConfig>:
ETH_MACAddressFilterConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1132
  *     @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the
  *                                     DA fields of the received frame.
  * @retval None
  */
void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
{
   0:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MACAddressFilterConfig+0x18>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1137
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
  
  if (Filter != ETH_MAC_AddressFilter_DA)
   2:	2908      	cmp	r1, #8
   4:	4402      	add	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1141
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
   6:	bf15      	itete	ne
   8:	6813      	ldrne	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1147
  }
  else
  {
    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
   a:	6813      	ldreq	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1141
  
  if (Filter != ETH_MAC_AddressFilter_DA)
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
   c:	f043 4380 	orrne.w	r3, r3, #1073741824	; 0x40000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1147
  }
  else
  {
    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
  10:	f023 4380 	biceq.w	r3, r3, #1073741824	; 0x40000000
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1149
  }
}
  16:	4770      	bx	lr
  18:	40028040 	.word	0x40028040
Disassembly of section .text.ETH_MACAddressMaskBytesFilterConfig:

00000000 <ETH_MACAddressMaskBytesFilterConfig>:
ETH_MACAddressMaskBytesFilterConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1175
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
  
  /* Clear MBC bits in the selected MAC address  high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
   0:	4a04      	ldr	r2, [pc, #16]	(14 <ETH_MACAddressMaskBytesFilterConfig+0x14>)
   2:	5883      	ldr	r3, [r0, r2]
   4:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
   8:	5083      	str	r3, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1177
  /* Set the selected Filetr mask bytes */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
   a:	5883      	ldr	r3, [r0, r2]
   c:	430b      	orrs	r3, r1
   e:	5083      	str	r3, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1178
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
  14:	40028040 	.word	0x40028040
Disassembly of section .text.ETH_DMATxDescChainInit:

00000000 <ETH_DMATxDescChainInit>:
ETH_DMATxDescChainInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1194
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   0:	4b0f      	ldr	r3, [pc, #60]	(40 <ETH_DMATxDescChainInit+0x40>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1189
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1194
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   4:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1189
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
   6:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1194
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   8:	f04f 0c00 	mov.w	ip, #0	; 0x0
   c:	f100 0210 	add.w	r2, r0, #16	; 0x10
  10:	e011      	b.n	36 <ETH_DMATxDescChainInit+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1201
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
  12:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  16:	f842 3c10 	str.w	r3, [r2, #-16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1207
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
  1a:	1e63      	subs	r3, r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1210
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  1c:	459c      	cmp	ip, r3
  1e:	bf2c      	ite	cs
  20:	4603      	movcs	r3, r0
  22:	4613      	movcc	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1204
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
  24:	f842 1c08 	str.w	r1, [r2, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1210
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  28:	f842 3c04 	str.w	r3, [r2, #-4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1196
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
  2c:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  30:	3210      	adds	r2, #16
  32:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  36:	45a4      	cmp	ip, r4
  38:	d3eb      	bcc.n	12 <ETH_DMATxDescChainInit+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1220
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
  3a:	4b02      	ldr	r3, [pc, #8]	(44 <ETH_DMATxDescChainInit+0x44>)
  3c:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1221
}
  3e:	bd10      	pop	{r4, pc}
  40:	00000000 	.word	0x00000000
  44:	40029010 	.word	0x40029010
Disassembly of section .text.ETH_DMATxDescRingInit:

00000000 <ETH_DMATxDescRingInit>:
ETH_DMATxDescRingInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1234
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	461c      	mov	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1239
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   4:	4b0e      	ldr	r3, [pc, #56]	(40 <ETH_DMATxDescRingInit+0x40>)
   6:	f04f 0c00 	mov.w	ip, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1234
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount)
{
   a:	460e      	mov	r6, r1
   c:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1239
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   e:	6018      	str	r0, [r3, #0]
  10:	4602      	mov	r2, r0
  12:	4661      	mov	r1, ip
  14:	e00e      	b.n	34 <ETH_DMATxDescRingInit+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1246
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff1[i*ETH_MAX_PACKET_SIZE]);
  16:	1873      	adds	r3, r6, r1
  18:	6093      	str	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1249
    
    /* Set Buffer2 address pointer */
    DMATxDesc->Buffer2NextDescAddr = (uint32_t)(&TxBuff2[i*ETH_MAX_PACKET_SIZE]);
  1a:	186b      	adds	r3, r5, r1
  1c:	60d3      	str	r3, [r2, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1253
    
    /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (TxBuffCount-1))
  1e:	1e63      	subs	r3, r4, #1
  20:	459c      	cmp	ip, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1256
    {
      /* Set Transmit End of Ring bit */
      DMATxDesc->Status = ETH_DMATxDesc_TER;
  22:	bf04      	itt	eq
  24:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
  28:	6013      	streq	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1241
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
  2a:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  2e:	3210      	adds	r2, #16
  30:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  34:	45a4      	cmp	ip, r4
  36:	d3ee      	bcc.n	16 <ETH_DMATxDescRingInit+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1261
      DMATxDesc->Status = ETH_DMATxDesc_TER;
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR =  (uint32_t) DMATxDescTab;
  38:	4b02      	ldr	r3, [pc, #8]	(44 <ETH_DMATxDescRingInit+0x44>)
  3a:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1262
}
  3c:	bd70      	pop	{r4, r5, r6, pc}
  3e:	46c0      	nop			(mov r8, r8)
  40:	00000000 	.word	0x00000000
  44:	40029010 	.word	0x40029010
Disassembly of section .text.ETH_GetDMATxDescFlagStatus:

00000000 <ETH_GetDMATxDescFlagStatus>:
ETH_GetDMATxDescFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1296
  *     @arg ETH_DMATxDesc_UF  : Underflow Error: late data arrival from the memory
  *     @arg ETH_DMATxDesc_DB  : Deferred Bit
  * @retval The new state of ETH_DMATxDescFlag (SET or RESET).
  */
FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	4219      	tst	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1310
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr
Disassembly of section .text.ETH_GetDMATxDescCollisionCount:

00000000 <ETH_GetDMATxDescCollisionCount>:
ETH_GetDMATxDescCollisionCount():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1318
  * @brief  Returns the specified ETHERNET DMA Tx Desc collision count.
  * @param  DMATxDesc: pointer on a DMA Tx descriptor                     
  * @retval The Transmit descriptor collision counter value.
  */
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
{
   0:	6800      	ldr	r0, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1321
  /* Return the Receive descriptor frame length */
  return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
}
   2:	f3c0 00c3 	ubfx	r0, r0, #3, #4
   6:	4770      	bx	lr
Disassembly of section .text.ETH_SetDMATxDescOwnBit:

00000000 <ETH_SetDMATxDescOwnBit>:
ETH_SetDMATxDescOwnBit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1331
  * @retval None
  */
void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
{
  /* Set the DMA Tx Desc Own bit */
  DMATxDesc->Status |= ETH_DMATxDesc_OWN;
   0:	6803      	ldr	r3, [r0, #0]
   2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   6:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1332
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescTransmitITConfig:

00000000 <ETH_DMATxDescTransmitITConfig>:
ETH_DMATxDescTransmitITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1342
  * @param  NewState: new state of the DMA Tx Desc transmit interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1346
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescTransmitITConfig+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1349
  {
    /* Enable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
   4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   8:	e001      	b.n	12 <ETH_DMATxDescTransmitITConfig+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1354
  }
  else
  {
    /* Disable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
   a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1356
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescFrameSegmentConfig:

00000000 <ETH_DMATxDescFrameSegmentConfig>:
ETH_DMATxDescFrameSegmentConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1368
  *     @arg ETH_DMATxDesc_LastSegment  : actual Tx desc contain last segment 
  *     @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment                   
  * @retval None
  */
void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	430b      	orrs	r3, r1
   4:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1374
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
  
  /* Selects the DMA Tx Desc Frame segment */
  DMATxDesc->Status |= DMATxDesc_FrameSegment;
}
   6:	4770      	bx	lr
Disassembly of section .text.ETH_DMATxDescChecksumInsertionConfig:

00000000 <ETH_DMATxDescChecksumInsertionConfig>:
ETH_DMATxDescChecksumInsertionConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1388
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
  * @retval None
  */
void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	430b      	orrs	r3, r1
   4:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1394
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
}
   6:	4770      	bx	lr
Disassembly of section .text.ETH_DMATxDescCRCCmd:

00000000 <ETH_DMATxDescCRCCmd>:
ETH_DMATxDescCRCCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1404
  * @param  NewState: new state of the specified DMA Tx Desc CRC.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1408
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescCRCCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1411
  {
    /* Enable the selected DMA Tx Desc CRC */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
   4:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   8:	e001      	b.n	12 <ETH_DMATxDescCRCCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1416
  }
  else
  {
    /* Disable the selected DMA Tx Desc CRC */
    DMATxDesc->Status |= ETH_DMATxDesc_DC; 
   a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1418
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescEndOfRingCmd:

00000000 <ETH_DMATxDescEndOfRingCmd>:
ETH_DMATxDescEndOfRingCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1428
  * @param  NewState: new state of the specified DMA Tx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1432
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescEndOfRingCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1435
  {
    /* Enable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status |= ETH_DMATxDesc_TER;  
   4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   8:	e001      	b.n	12 <ETH_DMATxDescEndOfRingCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1440
  }
  else
  {
    /* Disable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_TER); 
   a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1442
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescSecondAddressChainedCmd:

00000000 <ETH_DMATxDescSecondAddressChainedCmd>:
ETH_DMATxDescSecondAddressChainedCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1452
  * @param  NewState: new state of the specified DMA Tx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1456
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescSecondAddressChainedCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1459
  {
    /* Enable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
   4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8:	e001      	b.n	12 <ETH_DMATxDescSecondAddressChainedCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1464
  }
  else
  {
    /* Disable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
   a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1466
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescShortFramePaddingCmd:

00000000 <ETH_DMATxDescShortFramePaddingCmd>:
ETH_DMATxDescShortFramePaddingCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1476
  * @param  NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1480
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescShortFramePaddingCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1483
  {
    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
   4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   8:	e001      	b.n	12 <ETH_DMATxDescShortFramePaddingCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1488
  }
  else
  {
    /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
    DMATxDesc->Status |= ETH_DMATxDesc_DP; 
   a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1490
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescTimeStampCmd:

00000000 <ETH_DMATxDescTimeStampCmd>:
ETH_DMATxDescTimeStampCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1500
  * @param  NewState: new state of the specified DMA Tx Desc time stamp.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
   0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1504
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMATxDescTimeStampCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1507
  {
    /* Enable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status |= ETH_DMATxDesc_TTSE;  
   4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   8:	e001      	b.n	12 <ETH_DMATxDescTimeStampCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1512
  }
  else
  {
    /* Disable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TTSE); 
   a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1514
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMATxDescBufferSizeConfig:

00000000 <ETH_DMATxDescBufferSizeConfig>:
ETH_DMATxDescBufferSizeConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1524
  * @param  BufferSize1: specifies the Tx desc buffer1 size.
  * @param  BufferSize2: specifies the Tx desc buffer2 size (put "0" if not used).
  * @retval None
  */
void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
{
   0:	6843      	ldr	r3, [r0, #4]
   2:	4319      	orrs	r1, r3
   4:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   8:	6041      	str	r1, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1531
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
  
  /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
  DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
}
   a:	4770      	bx	lr
Disassembly of section .text.ETH_DMARxDescChainInit:

00000000 <ETH_DMARxDescChainInit>:
ETH_DMARxDescChainInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1541
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
   0:	4b11      	ldr	r3, [pc, #68]	(48 <ETH_DMARxDescChainInit+0x48>)
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1546
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   4:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1541
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
   6:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1546
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   8:	f04f 0c00 	mov.w	ip, #0	; 0x0
   c:	f100 0210 	add.w	r2, r0, #16	; 0x10
  10:	e015      	b.n	3e <ETH_DMARxDescChainInit+0x3e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1553
  for(i=0; i < RxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
  12:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  16:	f842 3c10 	str.w	r3, [r2, #-16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1556

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
  1a:	f244 53f0 	movw	r3, #17904	; 0x45f0
  1e:	f842 3c0c 	str.w	r3, [r2, #-12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1561
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
  22:	1e63      	subs	r3, r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1564
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  24:	459c      	cmp	ip, r3
  26:	bf2c      	ite	cs
  28:	4603      	movcs	r3, r0
  2a:	4613      	movcc	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1558
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
  2c:	f842 1c08 	str.w	r1, [r2, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1564
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  30:	f842 3c04 	str.w	r3, [r2, #-4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1548
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
  34:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  38:	3210      	adds	r2, #16
  3a:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  3e:	45a4      	cmp	ip, r4
  40:	d3e7      	bcc.n	12 <ETH_DMARxDescChainInit+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1574
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  42:	4b02      	ldr	r3, [pc, #8]	(4c <ETH_DMARxDescChainInit+0x4c>)
  44:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1575
}
  46:	bd10      	pop	{r4, pc}
  48:	00000000 	.word	0x00000000
  4c:	4002900c 	.word	0x4002900c
Disassembly of section .text.ETH_DMARxDescRingInit:

00000000 <ETH_DMARxDescRingInit>:
ETH_DMARxDescRingInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1588
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	461c      	mov	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1592
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   4:	4b11      	ldr	r3, [pc, #68]	(4c <ETH_DMARxDescRingInit+0x4c>)
   6:	f04f 0c00 	mov.w	ip, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1588
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
   a:	460e      	mov	r6, r1
   c:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1592
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   e:	6018      	str	r0, [r3, #0]
  10:	4602      	mov	r2, r0
  12:	4661      	mov	r1, ip
  14:	e014      	b.n	40 <ETH_DMARxDescRingInit+0x40>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1599
  for(i=0; i < RxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i; 
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN; 
  16:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  1a:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1601
    /* Set Buffer1 size */
    DMARxDesc->ControlBufferSize = ETH_MAX_PACKET_SIZE;  
  1c:	f44f 63be 	mov.w	r3, #1520	; 0x5f0
  20:	6053      	str	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1603
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff1[i*ETH_MAX_PACKET_SIZE]); 
  22:	1873      	adds	r3, r6, r1
  24:	6093      	str	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1606
    
    /* Set Buffer2 address pointer */
    DMARxDesc->Buffer2NextDescAddr = (uint32_t)(&RxBuff2[i*ETH_MAX_PACKET_SIZE]); 
  26:	186b      	adds	r3, r5, r1
  28:	60d3      	str	r3, [r2, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1610
    
    /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (RxBuffCount-1))
  2a:	1e63      	subs	r3, r4, #1
  2c:	459c      	cmp	ip, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1613
    {
      /* Set Receive End of Ring bit */
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
  2e:	bf04      	itt	eq
  30:	f248 53f0 	movweq	r3, #34288	; 0x85f0
  34:	6053      	streq	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1594
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
  36:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  3a:	3210      	adds	r2, #16
  3c:	f501 61be 	add.w	r1, r1, #1520	; 0x5f0
  40:	45a4      	cmp	ip, r4
  42:	d3e8      	bcc.n	16 <ETH_DMARxDescRingInit+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1618
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  44:	4b02      	ldr	r3, [pc, #8]	(50 <ETH_DMARxDescRingInit+0x50>)
  46:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1619
}
  48:	bd70      	pop	{r4, r5, r6, pc}
  4a:	46c0      	nop			(mov r8, r8)
  4c:	00000000 	.word	0x00000000
  50:	4002900c 	.word	0x4002900c
Disassembly of section .text.ETH_GetDMARxDescFlagStatus:

00000000 <ETH_GetDMARxDescFlagStatus>:
ETH_GetDMARxDescFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1647
  *     @arg ETH_DMARxDesc_CE:          CRC error
  *     @arg ETH_DMARxDesc_MAMPCE:      Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error
  * @retval The new state of ETH_DMARxDescFlag (SET or RESET).
  */
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	4219      	tst	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1660
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr
Disassembly of section .text.ETH_SetDMARxDescOwnBit:

00000000 <ETH_SetDMARxDescOwnBit>:
ETH_SetDMARxDescOwnBit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1668
  * @brief  Set the specified DMA Rx Desc Own bit.
  * @param  DMARxDesc: Pointer on a Rx desc
  * @retval None
  */
void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
{
   0:	6803      	ldr	r3, [r0, #0]
   2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   6:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1671
  /* Set the DMA Rx Desc Own bit */
  DMARxDesc->Status |= ETH_DMARxDesc_OWN;
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_GetDMARxDescFrameLength:

00000000 <ETH_GetDMARxDescFrameLength>:
ETH_GetDMARxDescFrameLength():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1679
  * @brief  Returns the specified DMA Rx Desc frame length.
  * @param  DMARxDesc: pointer on a DMA Rx descriptor                     
  * @retval The Rx descriptor received frame length.
  */
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
   0:	6800      	ldr	r0, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1682
  /* Return the Receive descriptor frame length */
  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
}
   2:	f3c0 400d 	ubfx	r0, r0, #16, #14
   6:	4770      	bx	lr
Disassembly of section .text.ETH_GetRxPktSize:

00000000 <ETH_GetRxPktSize>:
ETH_GetRxPktSize():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:653
  * @brief  Get the size of received the received packet.
  * @param  None
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(void)
{
   0:	4b09      	ldr	r3, [pc, #36]	(28 <ETH_GetRxPktSize+0x28>)
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:655
  uint32_t frameLength = 0;
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
   4:	6818      	ldr	r0, [r3, #0]
   6:	6803      	ldr	r3, [r0, #0]
   8:	2b00      	cmp	r3, #0
   a:	db0a      	blt.n	22 <ETH_GetRxPktSize+0x22>
   c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  10:	d107      	bne.n	22 <ETH_GetRxPktSize+0x22>
  12:	f403 7340 	and.w	r3, r3, #768	; 0x300
  16:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  1a:	d102      	bne.n	8 <ETH_GetRxPktSize+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:661
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the size of the packet: including 4 bytes of the CRC */
    frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet);
  1c:	f7ff fffe 	bl	0 <ETH_GetRxPktSize>
  20:	e000      	b.n	24 <ETH_GetRxPktSize+0x24>
  22:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:666
  }
 
 /* Return Frame Length */ 
 return frameLength;
}
  24:	bd10      	pop	{r4, pc}
  26:	46c0      	nop			(mov r8, r8)
  28:	00000000 	.word	0x00000000
Disassembly of section .text.ETH_DMARxDescReceiveITConfig:

00000000 <ETH_DMARxDescReceiveITConfig>:
ETH_DMARxDescReceiveITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1692
  * @param  NewState: new state of the specified DMA Rx Desc interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1696
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMARxDescReceiveITConfig+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1699
  {
    /* Enable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
   4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   8:	e001      	b.n	12 <ETH_DMARxDescReceiveITConfig+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1704
  }
  else
  {
    /* Disable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
   a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   e:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1706
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMARxDescEndOfRingCmd:

00000000 <ETH_DMARxDescEndOfRingCmd>:
ETH_DMARxDescEndOfRingCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1716
  * @param  NewState: new state of the specified DMA Rx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1720
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMARxDescEndOfRingCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1723
  {
    /* Enable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;  
   4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8:	e001      	b.n	12 <ETH_DMARxDescEndOfRingCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1728
  }
  else
  {
    /* Disable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RER); 
   a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   e:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1730
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_DMARxDescSecondAddressChainedCmd:

00000000 <ETH_DMARxDescSecondAddressChainedCmd>:
ETH_DMARxDescSecondAddressChainedCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1740
  * @param  NewState: new state of the specified DMA Rx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1744
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   2:	b111      	cbz	r1, e <ETH_DMARxDescSecondAddressChainedCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1747
  {
    /* Enable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RCH;  
   4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   8:	e001      	b.n	12 <ETH_DMARxDescSecondAddressChainedCmd+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1752
  }
  else
  {
    /* Disable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RCH); 
   a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   e:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1754
  }
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ETH_GetDMARxDescBufferSize:

00000000 <ETH_GetDMARxDescBufferSize>:
ETH_GetDMARxDescBufferSize():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1766
  *     @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1
  *     @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2                     
  * @retval The Receive descriptor frame length.
  */
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
{
   0:	6840      	ldr	r0, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1770
  /* Check the parameters */
  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
  
  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
   2:	b111      	cbz	r1, e <ETH_GetDMARxDescBufferSize+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1773
  {
    /* Return the DMA Rx Desc buffer2 size */
    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
   4:	f3c0 400c 	ubfx	r0, r0, #16, #13
   8:	e001      	b.n	12 <ETH_StructInit+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1778
  }
  else
  {
    /* Return the DMA Rx Desc buffer1 size */
    return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
   a:	04c0      	lsls	r0, r0, #19
   c:	0cc0      	lsrs	r0, r0, #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1780
  }
}
   e:	4770      	bx	lr
Disassembly of section .text.ETH_SoftwareReset:

00000000 <ETH_SoftwareReset>:
ETH_SoftwareReset():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1789
  * @brief  Resets all MAC subsystem internal registers and logic.
  * @param  None
  * @retval None
  */
void ETH_SoftwareReset(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	(10 <ETH_StructInit+0x10>)
   2:	6813      	ldr	r3, [r2, #0]
   4:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   8:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1793
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
}
   a:	4770      	bx	lr
   c:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_GetSoftwareResetStatus:

00000000 <ETH_GetSoftwareResetStatus>:
ETH_GetSoftwareResetStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1801
  * @brief  Checks whether the ETHERNET software reset bit is set or not.
  * @param  None
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
   0:	4b02      	ldr	r3, [pc, #8]	(10 <ETH_StructInit+0x10>)
   2:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1812
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   4:	f000 0001 	and.w	r0, r0, #1	; 0x1
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_GetDMAFlagStatus:

00000000 <ETH_GetDMAFlagStatus>:
ETH_GetDMAFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1842
  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
  *     @arg ETH_DMA_FLAG_T   : Transmit flag 
  * @retval The new state of ETH_DMA_FLAG (SET or RESET).
  */
FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
{  
   0:	4a04      	ldr	r2, [pc, #16]	(18 <ETH_StructInit+0x18>)
   2:	f241 0314 	movw	r3, #4116	; 0x1014
   6:	58d3      	ldr	r3, [r2, r3]
   8:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1855
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   a:	bf0c      	ite	eq
   c:	2000      	moveq	r0, #0
   e:	2001      	movne	r0, #1
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
  14:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_DMAClearFlag:

00000000 <ETH_DMAClearFlag>:
ETH_DMAClearFlag():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1879
  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
  *     @arg ETH_DMA_FLAG_T   : Transmit flag
  * @retval None
  */
void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
{
   0:	4b02      	ldr	r3, [pc, #8]	(10 <ETH_StructInit+0x10>)
   2:	f241 0214 	movw	r2, #4116	; 0x1014
   6:	5098      	str	r0, [r3, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1885
  /* Check the parameters */
  assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
  
  /* Clear the selected ETHERNET DMA FLAG */
  ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetDMAITStatus:

00000000 <ETH_GetDMAITStatus>:
ETH_GetDMAITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1912
  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
  *     @arg ETH_DMA_IT_T   : Transmit interrupt 
  * @retval The new state of ETH_DMA_IT (SET or RESET).
  */
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
{  
   0:	4a04      	ldr	r2, [pc, #16]	(18 <ETH_StructInit+0x18>)
   2:	f241 0314 	movw	r3, #4116	; 0x1014
   6:	58d3      	ldr	r3, [r2, r3]
   8:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1925
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   a:	bf0c      	ite	eq
   c:	2000      	moveq	r0, #0
   e:	2001      	movne	r0, #1
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
  14:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_DMAClearITPendingBit:

00000000 <ETH_DMAClearITPendingBit>:
ETH_DMAClearITPendingBit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1949
  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
  *     @arg ETH_DMA_IT_T   : Transmit interrupt
  * @retval None
  */
void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
{
   0:	4b02      	ldr	r3, [pc, #8]	(10 <ETH_StructInit+0x10>)
   2:	f241 0214 	movw	r2, #4116	; 0x1014
   6:	5098      	str	r0, [r3, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1955
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  
  /* Clear the selected ETHERNET DMA IT */
  ETH->DMASR = (uint32_t) ETH_DMA_IT;
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetTransmitProcessState:

00000000 <ETH_GetTransmitProcessState>:
ETH_GetTransmitProcessState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1970
  *     - ETH_DMA_TransmitProcess_Reading   : unning - reading the data from host memory
  *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe
  *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
  */
uint32_t ETH_GetTransmitProcessState(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(14 <ETH_StructInit+0x14>)
   2:	f241 0314 	movw	r3, #4116	; 0x1014
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1972
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
}
   8:	f000 0001 	and.w	r0, r0, #1	; 0x1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetReceiveProcessState:

00000000 <ETH_GetReceiveProcessState>:
ETH_GetReceiveProcessState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1987
  *     - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable
  *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
  *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the recieve frame into host memory  
  */
uint32_t ETH_GetReceiveProcessState(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(14 <ETH_StructInit+0x14>)
   2:	f241 0314 	movw	r3, #4116	; 0x1014
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1989
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
}
   8:	f000 0040 	and.w	r0, r0, #64	; 0x40
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_FlushTransmitFIFO:

00000000 <ETH_FlushTransmitFIFO>:
ETH_FlushTransmitFIFO():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:1997
  * @brief  Clears the ETHERNET transmit FIFO.
  * @param  None                
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
   0:	4903      	ldr	r1, [pc, #12]	(14 <ETH_StructInit+0x14>)
   2:	f241 0218 	movw	r2, #4120	; 0x1018
   6:	588b      	ldr	r3, [r1, r2]
   8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   c:	508b      	str	r3, [r1, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2000
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetFlushTransmitFIFOStatus:

00000000 <ETH_GetFlushTransmitFIFOStatus>:
ETH_GetFlushTransmitFIFOStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2008
  * @brief  Checks whether the ETHERNET transmit FIFO bit is cleared or not.
  * @param  None                
  * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
  */
FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
{   
   0:	4a03      	ldr	r2, [pc, #12]	(14 <ETH_StructInit+0x14>)
   2:	f241 0318 	movw	r3, #4120	; 0x1018
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2019
  else
  {
    bitstatus = RESET;
  }
  return bitstatus; 
}
   8:	f3c0 5000 	ubfx	r0, r0, #20, #1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_DMATransmissionCmd:

00000000 <ETH_DMATransmissionCmd>:
ETH_DMATransmissionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2028
  * @param  NewState: new state of the DMA transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATransmissionCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, 10 <ETH_DMATransmissionCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2035
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
   2:	4a05      	ldr	r2, [pc, #20]	(1c <ETH_StructInit+0x1c>)
   4:	6813      	ldr	r3, [r2, #0]
   6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   a:	e003      	b.n	18 <ETH_DMATransmissionCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2040
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
   c:	4a02      	ldr	r2, [pc, #8]	(1c <ETH_StructInit+0x1c>)
   e:	6813      	ldr	r3, [r2, #0]
  10:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2042
  }
}
  16:	4770      	bx	lr
  18:	40029018 	.word	0x40029018
Disassembly of section .text.ETH_DMAReceptionCmd:

00000000 <ETH_DMAReceptionCmd>:
ETH_DMAReceptionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2051
  * @param  NewState: new state of the DMA reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAReceptionCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, 10 <ETH_DMAReceptionCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2058
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
   2:	4a05      	ldr	r2, [pc, #20]	(1c <ETH_StructInit+0x1c>)
   4:	6813      	ldr	r3, [r2, #0]
   6:	f043 0302 	orr.w	r3, r3, #2	; 0x2
   a:	e003      	b.n	18 <ETH_DMAReceptionCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2063
  }
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
   c:	4a02      	ldr	r2, [pc, #8]	(1c <ETH_StructInit+0x1c>)
   e:	6813      	ldr	r3, [r2, #0]
  10:	f023 0302 	bic.w	r3, r3, #2	; 0x2
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2065
  }
}
  16:	4770      	bx	lr
  18:	40029018 	.word	0x40029018
Disassembly of section .text.ETH_Start:

00000000 <ETH_Start>:
ETH_Start():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:500
  * @brief  Enables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Start(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:502
  /* Enable transmit state machine of the MAC for transmission on the MII */  
  ETH_MACTransmissionCmd(ENABLE);
   2:	2001      	movs	r0, #1
   4:	f7ff fffe 	bl	0 <ETH_Start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:504
  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO();
   8:	f7ff fffe 	bl	0 <ETH_Start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:506
  /* Enable receive state machine of the MAC for reception from the MII */  
  ETH_MACReceptionCmd(ENABLE);
   c:	2001      	movs	r0, #1
   e:	f7ff fffe 	bl	0 <ETH_Start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:509
 
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE); 
  12:	2001      	movs	r0, #1
  14:	f7ff fffe 	bl	0 <ETH_Start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:511
  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);   
  18:	2001      	movs	r0, #1
  1a:	f7ff fffe 	bl	0 <ETH_Start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:512
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.ETH_DMAITConfig:

00000000 <ETH_DMAITConfig>:
ETH_DMAITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2092
  * @param  NewState: new state of the specified ETHERNET DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
{
   0:	b121      	cbz	r1, c <ETH_DMAITConfig+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2100
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET DMA interrupts */
    ETH->DMAIER |= ETH_DMA_IT;
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_DMAITConfig+0x18>)
   4:	6813      	ldr	r3, [r2, #0]
   6:	ea40 0303 	orr.w	r3, r0, r3
   a:	e003      	b.n	14 <ETH_DMAITConfig+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2105
  }
  else
  {
    /* Disable the selected ETHERNET DMA interrupts */
    ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_DMAITConfig+0x18>)
   e:	6813      	ldr	r3, [r2, #0]
  10:	ea23 0300 	bic.w	r3, r3, r0
  14:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2107
  }
}
  16:	4770      	bx	lr
  18:	4002901c 	.word	0x4002901c
Disassembly of section .text.ETH_GetDMAOverflowStatus:

00000000 <ETH_GetDMAOverflowStatus>:
ETH_GetDMAOverflowStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2118
  *     @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter
  *     @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter
  * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET).
  */
FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
{
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_GetDMAOverflowStatus+0x10>)
   2:	681b      	ldr	r3, [r3, #0]
   4:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2132
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40029020 	.word	0x40029020
Disassembly of section .text.ETH_GetRxOverflowMissedFrameCounter:

00000000 <ETH_GetRxOverflowMissedFrameCounter>:
ETH_GetRxOverflowMissedFrameCounter():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2140
  * @brief  Get the ETHERNET DMA Rx Overflow Missed Frame Counter value.
  * @param  None
  * @retval The value of Rx overflow Missed Frame Counter.
  */
uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
{
   0:	4b02      	ldr	r3, [pc, #8]	(c <ETH_GetRxOverflowMissedFrameCounter+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2142
  return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
}
   4:	f3c0 404a 	ubfx	r0, r0, #17, #11
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40029020 	.word	0x40029020
Disassembly of section .text.ETH_GetBufferUnavailableMissedFrameCounter:

00000000 <ETH_GetBufferUnavailableMissedFrameCounter>:
ETH_GetBufferUnavailableMissedFrameCounter():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2150
  * @brief  Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value.
  * @param  None
  * @retval The value of Buffer unavailable Missed Frame Counter.
  */
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
{
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ETH_GetBufferUnavailableMissedFrameCounter+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2152
  return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
}
   4:	b280      	uxth	r0, r0
   6:	4770      	bx	lr
   8:	40029020 	.word	0x40029020
Disassembly of section .text.ETH_GetCurrentTxDescStartAddress:

00000000 <ETH_GetCurrentTxDescStartAddress>:
ETH_GetCurrentTxDescStartAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2160
  * @brief  Get the ETHERNET DMA DMACHTDR register value.
  * @param  None
  * @retval The value of the current Tx desc start address.
  */
uint32_t ETH_GetCurrentTxDescStartAddress(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_GetCurrentTxDescStartAddress+0xc>)
   2:	f241 0348 	movw	r3, #4168	; 0x1048
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2162
  return ((uint32_t)(ETH->DMACHTDR));
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetCurrentRxDescStartAddress:

00000000 <ETH_GetCurrentRxDescStartAddress>:
ETH_GetCurrentRxDescStartAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2170
  * @brief  Get the ETHERNET DMA DMACHRDR register value.
  * @param  None
  * @retval The value of the current Rx desc start address.
  */
uint32_t ETH_GetCurrentRxDescStartAddress(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_GetCurrentRxDescStartAddress+0xc>)
   2:	f241 034c 	movw	r3, #4172	; 0x104c
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2172
  return ((uint32_t)(ETH->DMACHRDR));
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetCurrentTxBufferAddress:

00000000 <ETH_GetCurrentTxBufferAddress>:
ETH_GetCurrentTxBufferAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2180
  * @brief  Get the ETHERNET DMA DMACHTBAR register value.
  * @param  None
  * @retval The value of the current Tx buffer address.
  */
uint32_t ETH_GetCurrentTxBufferAddress(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_GetCurrentTxBufferAddress+0xc>)
   2:	f241 0350 	movw	r3, #4176	; 0x1050
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2182
  return ((uint32_t)(ETH->DMACHTBAR));
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetCurrentRxBufferAddress:

00000000 <ETH_GetCurrentRxBufferAddress>:
ETH_GetCurrentRxBufferAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2190
  * @brief  Get the ETHERNET DMA DMACHRBAR register value.
  * @param  None
  * @retval The value of the current Rx buffer address.
  */
uint32_t ETH_GetCurrentRxBufferAddress(void)
{
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_GetCurrentRxBufferAddress+0xc>)
   2:	f241 0354 	movw	r3, #4180	; 0x1054
   6:	58d0      	ldr	r0, [r2, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2192
  return ((uint32_t)(ETH->DMACHRBAR));
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_ResumeDMATransmission:

00000000 <ETH_ResumeDMATransmission>:
ETH_ResumeDMATransmission():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2201
  *   (the data written could be anything). This forces  the DMA to resume transmission.
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMATransmission(void)
{
   0:	4b02      	ldr	r3, [pc, #8]	(c <ETH_ResumeDMATransmission+0xc>)
   2:	2100      	movs	r1, #0
   4:	f241 0204 	movw	r2, #4100	; 0x1004
   8:	5099      	str	r1, [r3, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2203
  ETH->DMATPDR = 0;
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_ResumeDMAReception:

00000000 <ETH_ResumeDMAReception>:
ETH_ResumeDMAReception():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2212
  *   (the data written could be anything). This forces the DMA to resume reception.
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMAReception(void)
{
   0:	4b02      	ldr	r3, [pc, #8]	(c <ETH_ResumeDMAReception+0xc>)
   2:	2100      	movs	r1, #0
   4:	f241 0208 	movw	r2, #4104	; 0x1008
   8:	5099      	str	r1, [r3, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2214
  ETH->DMARPDR = 0;
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_ResetWakeUpFrameFilterRegisterPointer:

00000000 <ETH_ResetWakeUpFrameFilterRegisterPointer>:
ETH_ResetWakeUpFrameFilterRegisterPointer():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2225
  * @retval None
  */
void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
{  
  /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
  ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
   0:	4a02      	ldr	r2, [pc, #8]	(c <ETH_ResetWakeUpFrameFilterRegisterPointer+0xc>)
   2:	6ad3      	ldr	r3, [r2, #44]
   4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8:	62d3      	str	r3, [r2, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2226
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_SetWakeUpFrameFilterRegister:

00000000 <ETH_SetWakeUpFrameFilterRegister>:
ETH_SetWakeUpFrameFilterRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2234
  * @brief  Populates the remote wakeup frame registers.
  * @param  Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words).
  * @retval None
  */
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
   0:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2241
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
   2:	5842      	ldr	r2, [r0, r1]
   4:	4b02      	ldr	r3, [pc, #8]	(10 <ETH_SetWakeUpFrameFilterRegister+0x10>)
   6:	3104      	adds	r1, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2238
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
   8:	2920      	cmp	r1, #32
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2241
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
   a:	629a      	str	r2, [r3, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2238
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
   c:	d1f9      	bne.n	2 <ETH_SetWakeUpFrameFilterRegister+0x2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2243
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
  }
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GlobalUnicastWakeUpCmd:

00000000 <ETH_GlobalUnicastWakeUpCmd>:
ETH_GlobalUnicastWakeUpCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2253
  * @param  NewState: new state of the MAC Global Unicast Wake-Up.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, c <ETH_GlobalUnicastWakeUpCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2260
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Global Unicast Wake-Up */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_GlobalUnicastWakeUpCmd+0x18>)
   4:	6ad3      	ldr	r3, [r2, #44]
   6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   a:	e003      	b.n	14 <ETH_GlobalUnicastWakeUpCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2265
  }
  else
  {
    /* Disable the MAC Global Unicast Wake-Up */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_GlobalUnicastWakeUpCmd+0x18>)
   e:	6ad3      	ldr	r3, [r2, #44]
  10:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  14:	62d3      	str	r3, [r2, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2267
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetPMTFlagStatus:

00000000 <ETH_GetPMTFlagStatus>:
ETH_GetPMTFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2279
  *     @arg ETH_PMT_FLAG_WUFR    : Wake-Up Frame Received 
  *     @arg ETH_PMT_FLAG_MPR     : Magic Packet Received
  * @retval The new state of ETHERNET PMT Flag (SET or RESET).
  */
FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
{
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_GetPMTFlagStatus+0x10>)
   2:	6adb      	ldr	r3, [r3, #44]
   4:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2293
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   6:	bf0c      	ite	eq
   8:	2000      	moveq	r0, #0
   a:	2001      	movne	r0, #1
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_WakeUpFrameDetectionCmd:

00000000 <ETH_WakeUpFrameDetectionCmd>:
ETH_WakeUpFrameDetectionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2302
  * @param  NewState: new state of the MAC Wake-Up Frame Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, c <ETH_WakeUpFrameDetectionCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2309
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Wake-Up Frame Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_WakeUpFrameDetectionCmd+0x18>)
   4:	6ad3      	ldr	r3, [r2, #44]
   6:	f043 0304 	orr.w	r3, r3, #4	; 0x4
   a:	e003      	b.n	14 <ETH_WakeUpFrameDetectionCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2314
  }
  else
  {
    /* Disable the MAC Wake-Up Frame Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_WakeUpFrameDetectionCmd+0x18>)
   e:	6ad3      	ldr	r3, [r2, #44]
  10:	f023 0304 	bic.w	r3, r3, #4	; 0x4
  14:	62d3      	str	r3, [r2, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2316
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MagicPacketDetectionCmd:

00000000 <ETH_MagicPacketDetectionCmd>:
ETH_MagicPacketDetectionCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2325
  * @param  NewState: new state of the MAC Magic Packet Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, c <ETH_MagicPacketDetectionCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2332
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Magic Packet Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_MagicPacketDetectionCmd+0x18>)
   4:	6ad3      	ldr	r3, [r2, #44]
   6:	f043 0302 	orr.w	r3, r3, #2	; 0x2
   a:	e003      	b.n	14 <ETH_MagicPacketDetectionCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2337
  }
  else
  {
    /* Disable the MAC Magic Packet Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_MagicPacketDetectionCmd+0x18>)
   e:	6ad3      	ldr	r3, [r2, #44]
  10:	f023 0302 	bic.w	r3, r3, #2	; 0x2
  14:	62d3      	str	r3, [r2, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2339
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_PowerDownCmd:

00000000 <ETH_PowerDownCmd>:
ETH_PowerDownCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2348
  * @param  NewState: new state of the MAC Power Down.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PowerDownCmd(FunctionalState NewState)
{ 
   0:	b120      	cbz	r0, c <ETH_PowerDownCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2356
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Power Down */
    /* This puts the MAC in power down mode */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ETH_PowerDownCmd+0x18>)
   4:	6ad3      	ldr	r3, [r2, #44]
   6:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   a:	e003      	b.n	14 <ETH_PowerDownCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2361
  }
  else
  {
    /* Disable the MAC Power Down */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ETH_PowerDownCmd+0x18>)
   e:	6ad3      	ldr	r3, [r2, #44]
  10:	f023 0301 	bic.w	r3, r3, #1	; 0x1
  14:	62d3      	str	r3, [r2, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2363
  }
}
  16:	4770      	bx	lr
  18:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MMCCounterFreezeCmd:

00000000 <ETH_MMCCounterFreezeCmd>:
ETH_MMCCounterFreezeCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2373
  * @param  NewState: new state of the MMC Counter Freeze.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
{
   0:	b128      	cbz	r0, e <ETH_MMCCounterFreezeCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2380
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter Freeze */
    ETH->MMCCR |= ETH_MMCCR_MCF;
   2:	4a07      	ldr	r2, [pc, #28]	(20 <ETH_MMCCounterFreezeCmd+0x20>)
   4:	f8d2 3100 	ldr.w	r3, [r2, #256]
   8:	f043 0308 	orr.w	r3, r3, #8	; 0x8
   c:	e004      	b.n	18 <ETH_MMCCounterFreezeCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2385
  }
  else
  {
    /* Disable the MMC Counter Freeze */
    ETH->MMCCR &= ~ETH_MMCCR_MCF;
   e:	4a04      	ldr	r2, [pc, #16]	(20 <ETH_MMCCounterFreezeCmd+0x20>)
  10:	f8d2 3100 	ldr.w	r3, [r2, #256]
  14:	f023 0308 	bic.w	r3, r3, #8	; 0x8
  18:	f8c2 3100 	str.w	r3, [r2, #256]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2387
  }
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MMCResetOnReadCmd:

00000000 <ETH_MMCResetOnReadCmd>:
ETH_MMCResetOnReadCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2396
  * @param  NewState: new state of the MMC Reset On Read.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCResetOnReadCmd(FunctionalState NewState)
{
   0:	b128      	cbz	r0, e <ETH_MMCResetOnReadCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2403
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter reset on read */
    ETH->MMCCR |= ETH_MMCCR_ROR; 
   2:	4a07      	ldr	r2, [pc, #28]	(20 <ETH_MMCResetOnReadCmd+0x20>)
   4:	f8d2 3100 	ldr.w	r3, [r2, #256]
   8:	f043 0304 	orr.w	r3, r3, #4	; 0x4
   c:	e004      	b.n	18 <ETH_MMCResetOnReadCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2408
  }
  else
  {
    /* Disable the MMC Counter reset on read */
    ETH->MMCCR &= ~ETH_MMCCR_ROR;
   e:	4a04      	ldr	r2, [pc, #16]	(20 <ETH_MMCResetOnReadCmd+0x20>)
  10:	f8d2 3100 	ldr.w	r3, [r2, #256]
  14:	f023 0304 	bic.w	r3, r3, #4	; 0x4
  18:	f8c2 3100 	str.w	r3, [r2, #256]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2410
  }
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MMCCounterRolloverCmd:

00000000 <ETH_MMCCounterRolloverCmd>:
ETH_MMCCounterRolloverCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2419
  * @param  NewState: new state of the MMC Counter Stop Rollover.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
{
   0:	b128      	cbz	r0, e <ETH_MMCCounterRolloverCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2426
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Disable the MMC Counter Stop Rollover  */
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
   2:	4a07      	ldr	r2, [pc, #28]	(20 <ETH_MMCCounterRolloverCmd+0x20>)
   4:	f8d2 3100 	ldr.w	r3, [r2, #256]
   8:	f023 0302 	bic.w	r3, r3, #2	; 0x2
   c:	e004      	b.n	18 <ETH_MMCCounterRolloverCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2431
  }
  else
  {
    /* Enable the MMC Counter Stop Rollover */
    ETH->MMCCR |= ETH_MMCCR_CSR; 
   e:	4a04      	ldr	r2, [pc, #16]	(20 <ETH_MMCCounterRolloverCmd+0x20>)
  10:	f8d2 3100 	ldr.w	r3, [r2, #256]
  14:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  18:	f8c2 3100 	str.w	r3, [r2, #256]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2433
  }
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MMCCountersReset:

00000000 <ETH_MMCCountersReset>:
ETH_MMCCountersReset():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2441
  * @brief  Resets the MMC Counters.
  * @param  None
  * @retval None
  */
void ETH_MMCCountersReset(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(10 <ETH_MMCCountersReset+0x10>)
   2:	f8d2 3100 	ldr.w	r3, [r2, #256]
   6:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   a:	f8c2 3100 	str.w	r3, [r2, #256]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2444
  /* Resets the MMC Counters */
  ETH->MMCCR |= ETH_MMCCR_CR; 
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_MMCITConfig:

00000000 <ETH_MMCITConfig>:
ETH_MMCITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2462
  * @param  NewState: new state of the specified ETHERNET MMC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
{ 
   0:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
   4:	d010      	beq.n	28 <ETH_MMCITConfig+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2470
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
  {
    /* Remove egister mak from IT */
    ETH_MMC_IT &= 0xEFFFFFFF;
   6:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2473
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
   a:	b129      	cbz	r1, 18 <ETH_MMCITConfig+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2476
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
   c:	4a0e      	ldr	r2, [pc, #56]	(48 <ETH_MMCITConfig+0x48>)
   e:	f8d2 310c 	ldr.w	r3, [r2, #268]
  12:	ea23 0300 	bic.w	r3, r3, r0
  16:	e004      	b.n	22 <ETH_MMCITConfig+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2481
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR |= ETH_MMC_IT;    
  18:	4a0b      	ldr	r2, [pc, #44]	(48 <ETH_MMCITConfig+0x48>)
  1a:	f8d2 310c 	ldr.w	r3, [r2, #268]
  1e:	ea40 0303 	orr.w	r3, r0, r3
  22:	f8c2 310c 	str.w	r3, [r2, #268]
  26:	e00d      	b.n	44 <ETH_MMCITConfig+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2487
    }
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
  28:	b129      	cbz	r1, 36 <ETH_MMCITConfig+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2490
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
  2a:	4a07      	ldr	r2, [pc, #28]	(48 <ETH_MMCITConfig+0x48>)
  2c:	f8d2 3110 	ldr.w	r3, [r2, #272]
  30:	ea23 0300 	bic.w	r3, r3, r0
  34:	e004      	b.n	40 <ETH_MMCITConfig+0x40>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2495
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR |= ETH_MMC_IT;    
  36:	4a04      	ldr	r2, [pc, #16]	(48 <ETH_MMCITConfig+0x48>)
  38:	f8d2 3110 	ldr.w	r3, [r2, #272]
  3c:	ea40 0303 	orr.w	r3, r0, r3
  40:	f8c2 3110 	str.w	r3, [r2, #272]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2498
    }  
  }
}
  44:	4770      	bx	lr
  46:	46c0      	nop			(mov r8, r8)
  48:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetMMCITStatus:

00000000 <ETH_GetMMCITStatus>:
ETH_GetMMCITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2513
  *     @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value 
  *     @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value 
  * @retval The value of ETHERNET MMC IT (SET or RESET).
  */
ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
{
   0:	f010 5f80 	tst.w	r0, #268435456	; 0x10000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2522
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
   4:	bf15      	itete	ne
   6:	4a08      	ldrne	r2, [pc, #32]	(28 <ETH_GetMMCITStatus+0x28>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2535
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
   8:	4a07      	ldreq	r2, [pc, #28]	(28 <ETH_GetMMCITStatus+0x28>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2522
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
   a:	f8d2 3104 	ldrne.w	r3, [r2, #260]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2535
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
   e:	f8d2 3108 	ldreq.w	r3, [r2, #264]
  12:	4218      	tst	r0, r3
  14:	d006      	beq.n	24 <ETH_GetMMCITStatus+0x24>
  16:	f8d2 310c 	ldr.w	r3, [r2, #268]
  1a:	4218      	tst	r0, r3
  1c:	bf0c      	ite	eq
  1e:	2000      	moveq	r0, #0
  20:	2001      	movne	r0, #1
  22:	e000      	b.n	26 <ETH_GetMMCITStatus+0x26>
  24:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2546
      bitstatus = RESET;
    }  
  }    
    
  return bitstatus;
}
  26:	4770      	bx	lr
  28:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetMMCRegister:

00000000 <ETH_GetMMCRegister>:
ETH_GetMMCRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2566
  *     @arg ETH_MMCRFAECR  : MMC RFAECR register 
  *     @arg ETH_MMCRGUFCR  : MMC RGUFCRregister 
  * @retval The value of ETHERNET MMC Register value.
  */
uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
{
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ETH_GetMMCRegister+0x8>)
   2:	58c0      	ldr	r0, [r0, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2572
  /* Check the parameters */
  assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_EnablePTPTimeStampAddend:

00000000 <ETH_EnablePTPTimeStampAddend>:
ETH_EnablePTPTimeStampAddend():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2581
  * @brief  Updated the PTP block for fine correction with the Time Stamp Addend register value.
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampAddend(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(10 <ETH_EnablePTPTimeStampAddend+0x10>)
   2:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   6:	f043 0320 	orr.w	r3, r3, #32	; 0x20
   a:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2584
  /* Enable the PTP block update with the Time Stamp Addend register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSARU;    
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_EnablePTPTimeStampInterruptTrigger:

00000000 <ETH_EnablePTPTimeStampInterruptTrigger>:
ETH_EnablePTPTimeStampInterruptTrigger():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2592
  * @brief  Enable the PTP Time Stamp interrupt trigger
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampInterruptTrigger(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(10 <ETH_EnablePTPTimeStampInterruptTrigger+0x10>)
   2:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   6:	f043 0310 	orr.w	r3, r3, #16	; 0x10
   a:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2595
  /* Enable the PTP target time interrupt */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSITE;    
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_EnablePTPTimeStampUpdate:

00000000 <ETH_EnablePTPTimeStampUpdate>:
ETH_EnablePTPTimeStampUpdate():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2603
  * @brief  Updated the PTP system time with the Time Stamp Update register value.
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampUpdate(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(10 <ETH_EnablePTPTimeStampUpdate+0x10>)
   2:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   6:	f043 0308 	orr.w	r3, r3, #8	; 0x8
   a:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2606
  /* Enable the PTP system time update with the Time Stamp Update register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTU;    
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_InitializePTPTimeStamp:

00000000 <ETH_InitializePTPTimeStamp>:
ETH_InitializePTPTimeStamp():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2614
  * @brief  Initialize the PTP Time Stamp
  * @param  None
  * @retval None
  */
void ETH_InitializePTPTimeStamp(void)
{
   0:	4a03      	ldr	r2, [pc, #12]	(10 <ETH_InitializePTPTimeStamp+0x10>)
   2:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   6:	f043 0304 	orr.w	r3, r3, #4	; 0x4
   a:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2617
  /* Initialize the PTP Time Stamp */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTI;    
}
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_PTPUpdateMethodConfig:

00000000 <ETH_PTPUpdateMethodConfig>:
ETH_PTPUpdateMethodConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2628
  *     @arg ETH_PTP_FineUpdate   : Fine Update method 
  *     @arg ETH_PTP_CoarseUpdate : Coarse Update method 
  * @retval None
  */
void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod)
{
   0:	b128      	cbz	r0, e <ETH_PTPUpdateMethodConfig+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2635
  assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));
  
  if (UpdateMethod != ETH_PTP_CoarseUpdate)
  {
    /* Enable the PTP Fine Update method */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSFCU;
   2:	4a07      	ldr	r2, [pc, #28]	(20 <ETH_PTPUpdateMethodConfig+0x20>)
   4:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   8:	f043 0302 	orr.w	r3, r3, #2	; 0x2
   c:	e004      	b.n	18 <ETH_PTPUpdateMethodConfig+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2640
  }
  else
  {
    /* Disable the PTP Coarse Update method */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSFCU);
   e:	4a04      	ldr	r2, [pc, #16]	(20 <ETH_PTPUpdateMethodConfig+0x20>)
  10:	f8d2 3700 	ldr.w	r3, [r2, #1792]
  14:	f023 0302 	bic.w	r3, r3, #2	; 0x2
  18:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2642
  } 
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_PTPTimeStampCmd:

00000000 <ETH_PTPTimeStampCmd>:
ETH_PTPTimeStampCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2651
  * @param  NewState: new state of the PTP time stamp for transmit and receive frames
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PTPTimeStampCmd(FunctionalState NewState)
{
   0:	b128      	cbz	r0, e <ETH_PTPTimeStampCmd+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2658
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSE;
   2:	4a07      	ldr	r2, [pc, #28]	(20 <ETH_PTPTimeStampCmd+0x20>)
   4:	f8d2 3700 	ldr.w	r3, [r2, #1792]
   8:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   c:	e004      	b.n	18 <ETH_PTPTimeStampCmd+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2663
  }
  else
  {
    /* Disable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSE);
   e:	4a04      	ldr	r2, [pc, #16]	(20 <ETH_PTPTimeStampCmd+0x20>)
  10:	f8d2 3700 	ldr.w	r3, [r2, #1792]
  14:	f023 0301 	bic.w	r3, r3, #1	; 0x1
  18:	f8c2 3700 	str.w	r3, [r2, #1792]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2665
  }
}
  1c:	4770      	bx	lr
  1e:	46c0      	nop			(mov r8, r8)
  20:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetPTPFlagStatus:

00000000 <ETH_GetPTPFlagStatus>:
ETH_GetPTPFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2678
  *     @arg ETH_PTP_FLAG_TSSTU : Time Stamp Update 
  *     @arg ETH_PTP_FLAG_TSSTI  : Time Stamp Initialize                       
  * @retval The new state of ETHERNET PTP Flag (SET or RESET).
  */
FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG)
{
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_GetPTPFlagStatus+0x10>)
   2:	f8d3 3700 	ldr.w	r3, [r3, #1792]
   6:	4218      	tst	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2692
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
   8:	bf0c      	ite	eq
   a:	2000      	moveq	r0, #0
   c:	2001      	movne	r0, #1
   e:	4770      	bx	lr
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_SetPTPSubSecondIncrement:

00000000 <ETH_SetPTPSubSecondIncrement>:
ETH_SetPTPSubSecondIncrement():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2700
  * @brief  Sets the system time Sub-Second Increment value.
  * @param  SubSecondValue: specifies the PTP Sub-Second Increment Register value.
  * @retval None
  */
void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue)
{
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ETH_SetPTPSubSecondIncrement+0x8>)
   2:	f8c3 0704 	str.w	r0, [r3, #1796]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2705
  /* Check the parameters */
  assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue));
  /* Set the PTP Sub-Second Increment Register */
  ETH->PTPSSIR = SubSecondValue;    
}
   6:	4770      	bx	lr
   8:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_SetPTPTimeStampUpdate:

00000000 <ETH_SetPTPTimeStampUpdate>:
ETH_SetPTPTimeStampUpdate():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2719
  * @param  SubSecondValue: specifies the PTP Time update sub-second value.
  *   This parameter is a 31 bit value, bit32 correspond to the sign.
  * @retval None
  */
void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue)
{
   0:	4b03      	ldr	r3, [pc, #12]	(10 <ETH_SetPTPTimeStampUpdate+0x10>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2727
  assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
  /* Set the PTP Time Update High Register */
  ETH->PTPTSHUR = SecondValue;
  
  /* Set the PTP Time Update Low Register with sign */
  ETH->PTPTSLUR = Sign | SubSecondValue;   
   2:	4302      	orrs	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2724
{
  /* Check the parameters */
  assert_param(IS_ETH_PTP_TIME_SIGN(Sign));  
  assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
  /* Set the PTP Time Update High Register */
  ETH->PTPTSHUR = SecondValue;
   4:	f8c3 1710 	str.w	r1, [r3, #1808]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2727
  
  /* Set the PTP Time Update Low Register with sign */
  ETH->PTPTSLUR = Sign | SubSecondValue;   
   8:	f8c3 2714 	str.w	r2, [r3, #1812]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2728
}
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_SetPTPTimeStampAddend:

00000000 <ETH_SetPTPTimeStampAddend>:
ETH_SetPTPTimeStampAddend():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2736
  * @brief  Sets the Time Stamp Addend value.
  * @param  Value: specifies the PTP Time Stamp Addend Register value.
  * @retval None
  */
void ETH_SetPTPTimeStampAddend(uint32_t Value)
{
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ETH_SetPTPTimeStampAddend+0x8>)
   2:	f8c3 0718 	str.w	r0, [r3, #1816]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2739
  /* Set the PTP Time Stamp Addend Register */
  ETH->PTPTSAR = Value;    
}
   6:	4770      	bx	lr
   8:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_SetPTPTargetTime:

00000000 <ETH_SetPTPTargetTime>:
ETH_SetPTPTargetTime():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2748
  * @param  HighValue: specifies the PTP Target Time High Register value.
  * @param  LowValue: specifies the PTP Target Time Low Register value.
  * @retval None
  */
void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue)
{
   0:	4b02      	ldr	r3, [pc, #8]	(c <ETH_SetPTPTargetTime+0xc>)
   2:	f8c3 071c 	str.w	r0, [r3, #1820]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2752
  /* Set the PTP Target Time High Register */
  ETH->PTPTTHR = HighValue;
  /* Set the PTP Target Time Low Register */
  ETH->PTPTTLR = LowValue;    
   6:	f8c3 1720 	str.w	r1, [r3, #1824]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2753
}
   a:	4770      	bx	lr
   c:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_GetPTPRegister:

00000000 <ETH_GetPTPRegister>:
ETH_GetPTPRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2771
  *     @arg ETH_PTPTTHR  : Target Time High Register 
  *     @arg ETH_PTPTTLR  : Target Time Low Register 
  * @retval The value of ETHERNET PTP Register value.
  */
uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg)
{
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ETH_GetPTPRegister+0x8>)
   2:	58c0      	ldr	r0, [r0, r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2777
  /* Check the parameters */
  assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg));
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	40028000 	.word	0x40028000
Disassembly of section .text.ETH_DMAPTPTxDescChainInit:

00000000 <ETH_DMAPTPTxDescChainInit>:
ETH_DMAPTPTxDescChainInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2789
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	461d      	mov	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2794
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   4:	4b16      	ldr	r3, [pc, #88]	(60 <ETH_DMAPTPTxDescChainInit+0x60>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2789
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
   6:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2794
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
   8:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2795
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
   a:	4b16      	ldr	r3, [pc, #88]	(64 <ETH_DMAPTPTxDescChainInit+0x64>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2789
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
   c:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2795
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
   e:	6019      	str	r1, [r3, #0]
  10:	f04f 0c00 	mov.w	ip, #0	; 0x0
  14:	f100 0110 	add.w	r1, r0, #16	; 0x10
  18:	4610      	mov	r0, r2
  1a:	4622      	mov	r2, r4
  1c:	e014      	b.n	48 <ETH_DMAPTPTxDescChainInit+0x48>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2802
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab+i;
    /* Set Second Address Chained bit and enable PTP */
    DMATxDesc->Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;  
  1e:	f04f 7304 	mov.w	r3, #34603008	; 0x2100000
  22:	f841 3c10 	str.w	r3, [r1, #-16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2808
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr =(uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
  26:	1e6b      	subs	r3, r5, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2811
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  28:	459c      	cmp	ip, r3
  2a:	bf2c      	ite	cs
  2c:	4633      	movcs	r3, r6
  2e:	460b      	movcc	r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2805
    DMATxDesc = DMATxDescTab+i;
    /* Set Second Address Chained bit and enable PTP */
    DMATxDesc->Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;  
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr =(uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
  30:	f841 0c08 	str.w	r0, [r1, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2811
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
  34:	f841 3c04 	str.w	r3, [r1, #-4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2819
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
  38:	6090      	str	r0, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2820
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  3a:	60d3      	str	r3, [r2, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2797
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
  3c:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  40:	3210      	adds	r2, #16
  42:	3110      	adds	r1, #16
  44:	f500 60be 	add.w	r0, r0, #1520	; 0x5f0
  48:	45ac      	cmp	ip, r5
  4a:	d3e8      	bcc.n	1e <ETH_DMAPTPTxDescChainInit+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2823
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPTxDescTab desc status record the first list address */
  (&DMAPTPTxDescTab[i-1])->Status = (uint32_t) DMAPTPTxDescTab;
  4c:	f1c5 0301 	rsb	r3, r5, #1	; 0x1
  50:	f06f 020f 	mvn.w	r2, #15	; 0xf
  54:	435a      	muls	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2826

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
  56:	4b04      	ldr	r3, [pc, #16]	(68 <ETH_DMAPTPTxDescChainInit+0x68>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2823
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPTxDescTab desc status record the first list address */
  (&DMAPTPTxDescTab[i-1])->Status = (uint32_t) DMAPTPTxDescTab;
  58:	50a4      	str	r4, [r4, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2826

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
  5a:	601e      	str	r6, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2827
}
  5c:	bd70      	pop	{r4, r5, r6, pc}
  5e:	46c0      	nop			(mov r8, r8)
	...
  68:	40029010 	.word	0x40029010
Disassembly of section .text.ETH_DMAPTPRxDescChainInit:

00000000 <ETH_DMAPTPRxDescChainInit>:
ETH_DMAPTPRxDescChainInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2839
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	461d      	mov	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2844
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   4:	4b18      	ldr	r3, [pc, #96]	(68 <ETH_DMAPTPRxDescChainInit+0x68>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2839
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
   6:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2844
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
   8:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2845
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
   a:	4b18      	ldr	r3, [pc, #96]	(6c <ETH_DMAPTPRxDescChainInit+0x6c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2839
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
   c:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2845
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
   e:	6019      	str	r1, [r3, #0]
  10:	f04f 0c00 	mov.w	ip, #0	; 0x0
  14:	f100 0110 	add.w	r1, r0, #16	; 0x10
  18:	4610      	mov	r0, r2
  1a:	4622      	mov	r2, r4
  1c:	e018      	b.n	50 <ETH_DMAPTPRxDescChainInit+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2852
  for(i=0; i < RxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
  1e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  22:	f841 3c10 	str.w	r3, [r1, #-16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2855

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
  26:	f244 53f0 	movw	r3, #17904	; 0x45f0
  2a:	f841 3c0c 	str.w	r3, [r1, #-12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2860
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
  2e:	1e6b      	subs	r3, r5, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2863
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  30:	459c      	cmp	ip, r3
  32:	bf2c      	ite	cs
  34:	4633      	movcs	r3, r6
  36:	460b      	movcc	r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2857
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
  38:	f841 0c08 	str.w	r0, [r1, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2863
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
  3c:	f841 3c04 	str.w	r3, [r1, #-4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2871
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
  40:	6090      	str	r0, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2872
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  42:	60d3      	str	r3, [r2, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2847
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
  44:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  48:	3210      	adds	r2, #16
  4a:	3110      	adds	r1, #16
  4c:	f500 60be 	add.w	r0, r0, #1520	; 0x5f0
  50:	45ac      	cmp	ip, r5
  52:	d3e4      	bcc.n	1e <ETH_DMAPTPRxDescChainInit+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2875
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPRxDescTab desc status record the first list address */
  (&DMAPTPRxDescTab[i-1])->Status = (uint32_t) DMAPTPRxDescTab;
  54:	f1c5 0301 	rsb	r3, r5, #1	; 0x1
  58:	f06f 020f 	mvn.w	r2, #15	; 0xf
  5c:	435a      	muls	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2878

  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  5e:	4b04      	ldr	r3, [pc, #16]	(70 <ETH_DMAPTPRxDescChainInit+0x70>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2875
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPRxDescTab desc status record the first list address */
  (&DMAPTPRxDescTab[i-1])->Status = (uint32_t) DMAPTPRxDescTab;
  60:	50a4      	str	r4, [r4, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2878

  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
  62:	601e      	str	r6, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2879
}
  64:	bd70      	pop	{r4, r5, r6, pc}
  66:	46c0      	nop			(mov r8, r8)
	...
  70:	4002900c 	.word	0x4002900c
Disassembly of section .text.ETH_HandlePTPTxPkt:

00000000 <ETH_HandlePTPTxPkt>:
ETH_HandlePTPTxPkt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2890
  * @param  PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
   0:	4b32      	ldr	r3, [pc, #200]	(cc <ETH_HandlePTPTxPkt+0xcc>)
   2:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2893
  uint32_t offset = 0, timeout = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   4:	681b      	ldr	r3, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2890
  * @param  PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
   6:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2893
  uint32_t offset = 0, timeout = 0;
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
   8:	681b      	ldr	r3, [r3, #0]
   a:	2b00      	cmp	r3, #0
   c:	db5c      	blt.n	c8 <ETH_HandlePTPTxPkt+0xc8>
   e:	f04f 0c00 	mov.w	ip, #0	; 0x0
  12:	e008      	b.n	26 <ETH_HandlePTPTxPkt+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2901
    return ETH_ERROR;
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  14:	4b2e      	ldr	r3, [pc, #184]	(d0 <ETH_HandlePTPTxPkt+0xd0>)
  16:	681b      	ldr	r3, [r3, #0]
  18:	689a      	ldr	r2, [r3, #8]
  1a:	f810 300c 	ldrb.w	r3, [r0, ip]
  1e:	f80c 3002 	strb.w	r3, [ip, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2899
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
  22:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
  26:	458c      	cmp	ip, r1
  28:	d3f4      	bcc.n	14 <ETH_HandlePTPTxPkt+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2904
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
  2a:	4b28      	ldr	r3, [pc, #160]	(cc <ETH_HandlePTPTxPkt+0xcc>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2910
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  2c:	4c29      	ldr	r4, [pc, #164]	(d4 <ETH_HandlePTPTxPkt+0xd4>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2904
  for(offset=0; offset<FrameLength; offset++)
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
  2e:	6818      	ldr	r0, [r3, #0]
  30:	04cb      	lsls	r3, r1, #19
  32:	0cdb      	lsrs	r3, r3, #19
  34:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2908
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
  36:	6803      	ldr	r3, [r0, #0]
  38:	f043 4130 	orr.w	r1, r3, #2952790016	; 0xb0000000
  3c:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2910
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
  3e:	6823      	ldr	r3, [r4, #0]
  40:	f013 0204 	ands.w	r2, r3, #4	; 0x4
  44:	d004      	beq.n	50 <ETH_HandlePTPTxPkt+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2913
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
  46:	2304      	movs	r3, #4
  48:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2915
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  4a:	4b23      	ldr	r3, [pc, #140]	(d8 <ETH_HandlePTPTxPkt+0xd8>)
  4c:	2200      	movs	r2, #0
  4e:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2920
  }
  /* Wait for ETH_DMATxDesc_TTSS flag to be set */
  do
  {
    timeout++;
  50:	3201      	adds	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2921
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
  52:	f411 3f00 	tst.w	r1, #131072	; 0x20000
  56:	d003      	beq.n	60 <ETH_HandlePTPTxPkt+0x60>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2923
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  58:	4b20      	ldr	r3, [pc, #128]	(dc <ETH_HandlePTPTxPkt+0xdc>)
  5a:	429a      	cmp	r2, r3
  5c:	d034      	beq.n	c8 <ETH_HandlePTPTxPkt+0xc8>
  5e:	e003      	b.n	68 <ETH_HandlePTPTxPkt+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2921
  }
  /* Wait for ETH_DMATxDesc_TTSS flag to be set */
  do
  {
    timeout++;
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
  60:	f64f 73ff 	movw	r3, #65535	; 0xffff
  64:	429a      	cmp	r2, r3
  66:	d1f3      	bne.n	50 <ETH_HandlePTPTxPkt+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2928
  if(timeout == PHY_READ_TO)
  {
    return ETH_ERROR;
  }
  /* Clear the DMATxDescToSet status register TTSS flag */
  DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
  68:	f421 3300 	bic.w	r3, r1, #131072	; 0x20000
  6c:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2929
  *PTPTxTab++ = DMATxDescToSet->Buffer1Addr;
  6e:	6883      	ldr	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2930
  *PTPTxTab = DMATxDescToSet->Buffer2NextDescAddr;
  70:	4816      	ldr	r0, [pc, #88]	(cc <ETH_HandlePTPTxPkt+0xcc>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2929
  {
    return ETH_ERROR;
  }
  /* Clear the DMATxDescToSet status register TTSS flag */
  DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
  *PTPTxTab++ = DMATxDescToSet->Buffer1Addr;
  72:	602b      	str	r3, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2930
  *PTPTxTab = DMATxDescToSet->Buffer2NextDescAddr;
  74:	6801      	ldr	r1, [r0, #0]
  76:	68cb      	ldr	r3, [r1, #12]
  78:	606b      	str	r3, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2933
  /* Update the ENET DMA current descriptor */
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
  7a:	680b      	ldr	r3, [r1, #0]
  7c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  80:	d009      	beq.n	96 <ETH_HandlePTPTxPkt+0x96>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2936
  {  
    /* Selects the next DMA Tx descriptor list for next buffer read */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Buffer2NextDescAddr);
  82:	4913      	ldr	r1, [pc, #76]	(d0 <ETH_HandlePTPTxPkt+0xd0>)
  84:	680a      	ldr	r2, [r1, #0]
  86:	68d3      	ldr	r3, [r2, #12]
  88:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2937
    if(DMAPTPTxDescToSet->Status != 0)
  8a:	6813      	ldr	r3, [r2, #0]
  8c:	b90b      	cbnz	r3, 92 <ETH_HandlePTPTxPkt+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2943
    { 
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Status);
    }
    else
    {
      DMAPTPTxDescToSet++;
  8e:	f102 0310 	add.w	r3, r2, #16	; 0x10
  92:	600b      	str	r3, [r1, #0]
  94:	e008      	b.n	a8 <ETH_HandlePTPTxPkt+0xa8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2948
    }
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
  96:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  9a:	4c0d      	ldr	r4, [pc, #52]	(d0 <ETH_HandlePTPTxPkt+0xd0>)
  9c:	d006      	beq.n	ac <ETH_HandlePTPTxPkt+0xac>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2952
    {
      /* Selects the next DMA Tx descriptor list for next buffer read: this will
         be the first Tx descriptor in this case */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR); 
  9e:	4b10      	ldr	r3, [pc, #64]	(e0 <ETH_HandlePTPTxPkt+0xe0>)
  a0:	681a      	ldr	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2953
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);
  a2:	681b      	ldr	r3, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2952
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
    {
      /* Selects the next DMA Tx descriptor list for next buffer read: this will
         be the first Tx descriptor in this case */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR); 
  a4:	6002      	str	r2, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2953
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);
  a6:	6023      	str	r3, [r4, #0]
  a8:	2001      	movs	r0, #1
  aa:	e00e      	b.n	ca <ETH_HandlePTPTxPkt+0xca>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2958
    }
    else
    {
      /* Selects the next DMA Tx descriptor list for next buffer read */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  ac:	4a0d      	ldr	r2, [pc, #52]	(e4 <ETH_HandlePTPTxPkt+0xe4>)
  ae:	6813      	ldr	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2959
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  b0:	6812      	ldr	r2, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2958
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);
    }
    else
    {
      /* Selects the next DMA Tx descriptor list for next buffer read */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  b2:	f3c3 0384 	ubfx	r3, r3, #2, #5
  b6:	3310      	adds	r3, #16
  b8:	18cb      	adds	r3, r1, r3
  ba:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2959
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  bc:	f3c2 0284 	ubfx	r2, r2, #2, #5
  c0:	6823      	ldr	r3, [r4, #0]
  c2:	3210      	adds	r2, #16
  c4:	189b      	adds	r3, r3, r2
  c6:	e7ee      	b.n	a6 <ETH_HandlePTPTxPkt+0xa6>
  c8:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2964
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;
}
  ca:	bd30      	pop	{r4, r5, pc}
	...
  d4:	40029014 	.word	0x40029014
  d8:	40029004 	.word	0x40029004
  dc:	0004ffff 	.word	0x0004ffff
  e0:	40029010 	.word	0x40029010
  e4:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_HandlePTPRxPkt:

00000000 <ETH_HandlePTPRxPkt>:
ETH_HandlePTPRxPkt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2974
  * @param  PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab)
{
   0:	4b28      	ldr	r3, [pc, #160]	(a4 <ETH_HandlePTPRxPkt+0xa4>)
   2:	681b      	ldr	r3, [r3, #0]
   4:	681b      	ldr	r3, [r3, #0]
   6:	2b00      	cmp	r3, #0
   8:	da02      	bge.n	10 <ETH_HandlePTPRxPkt+0x10>
   a:	f04f 0c00 	mov.w	ip, #0	; 0x0
   e:	e047      	b.n	a0 <ETH_HandlePTPRxPkt+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2982
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
  10:	f413 4200 	ands.w	r2, r3, #32768	; 0x8000
  14:	d113      	bne.n	3e <ETH_HandlePTPRxPkt+0x3e>
  16:	f413 7f80 	tst.w	r3, #256	; 0x100
  1a:	d010      	beq.n	3e <ETH_HandlePTPRxPkt+0x3e>
  1c:	f413 7f00 	tst.w	r3, #512	; 0x200
  20:	d00d      	beq.n	3e <ETH_HandlePTPRxPkt+0x3e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2987
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
  22:	f3c3 430d 	ubfx	r3, r3, #16, #14
  26:	f1a3 0c04 	sub.w	ip, r3, #4	; 0x4
  2a:	e005      	b.n	38 <ETH_HandlePTPRxPkt+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2991
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet->Buffer1Addr) + offset));
  2c:	4b1e      	ldr	r3, [pc, #120]	(a8 <ETH_HandlePTPRxPkt+0xa8>)
  2e:	681b      	ldr	r3, [r3, #0]
  30:	689b      	ldr	r3, [r3, #8]
  32:	5cd3      	ldrb	r3, [r2, r3]
  34:	5483      	strb	r3, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:2989
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
  36:	3201      	adds	r2, #1
  38:	4562      	cmp	r2, ip
  3a:	d3f7      	bcc.n	2c <ETH_HandlePTPRxPkt+0x2c>
  3c:	e001      	b.n	42 <ETH_HandlePTPRxPkt+0x42>
  3e:	f04f 0c00 	mov.w	ip, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3000
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
  }
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
  42:	4a1a      	ldr	r2, [pc, #104]	(ac <ETH_HandlePTPRxPkt+0xac>)
  44:	6813      	ldr	r3, [r2, #0]
  46:	f013 0f80 	tst.w	r3, #128	; 0x80
  4a:	d004      	beq.n	56 <ETH_HandlePTPRxPkt+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3003
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
  4c:	2380      	movs	r3, #128
  4e:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3005
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
  50:	4b17      	ldr	r3, [pc, #92]	(b0 <ETH_HandlePTPRxPkt+0xb0>)
  52:	2200      	movs	r2, #0
  54:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3007
  }
  *PTPRxTab++ = DMARxDescToGet->Buffer1Addr;
  56:	4813      	ldr	r0, [pc, #76]	(a4 <ETH_HandlePTPRxPkt+0xa4>)
  58:	6802      	ldr	r2, [r0, #0]
  5a:	6893      	ldr	r3, [r2, #8]
  5c:	600b      	str	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3008
  *PTPRxTab = DMARxDescToGet->Buffer2NextDescAddr;
  5e:	68d3      	ldr	r3, [r2, #12]
  60:	604b      	str	r3, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3010
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status |= ETH_DMARxDesc_OWN;
  62:	6813      	ldr	r3, [r2, #0]
  64:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  68:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3013
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
  6a:	6853      	ldr	r3, [r2, #4]
  6c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  70:	d009      	beq.n	86 <ETH_HandlePTPRxPkt+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3016
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Buffer2NextDescAddr);
  72:	490d      	ldr	r1, [pc, #52]	(a8 <ETH_HandlePTPRxPkt+0xa8>)
  74:	680a      	ldr	r2, [r1, #0]
  76:	68d3      	ldr	r3, [r2, #12]
  78:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3017
    if(DMAPTPRxDescToGet->Status != 0)
  7a:	6813      	ldr	r3, [r2, #0]
  7c:	b90b      	cbnz	r3, 82 <ETH_HandlePTPRxPkt+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3023
    {
      DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Status);
    }
    else
    {
      DMAPTPRxDescToGet++;
  7e:	f102 0310 	add.w	r3, r2, #16	; 0x10
  82:	600b      	str	r3, [r1, #0]
  84:	e00c      	b.n	a0 <ETH_HandlePTPRxPkt+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3028
    }
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
  86:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  8a:	d002      	beq.n	92 <ETH_HandlePTPRxPkt+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3031
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
  8c:	4b09      	ldr	r3, [pc, #36]	(b4 <ETH_HandlePTPRxPkt+0xb4>)
  8e:	681b      	ldr	r3, [r3, #0]
  90:	e005      	b.n	9e <ETH_HandlePTPRxPkt+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3036
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
  92:	4b09      	ldr	r3, [pc, #36]	(b8 <ETH_HandlePTPRxPkt+0xb8>)
  94:	681b      	ldr	r3, [r3, #0]
  96:	f3c3 0384 	ubfx	r3, r3, #2, #5
  9a:	3310      	adds	r3, #16
  9c:	18d3      	adds	r3, r2, r3
  9e:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3041
    }
  }
  /* Return Frame Length/ERROR */
  return (framelength);
}
  a0:	4660      	mov	r0, ip
  a2:	4770      	bx	lr
	...
  ac:	40029014 	.word	0x40029014
  b0:	40029008 	.word	0x40029008
  b4:	4002900c 	.word	0x4002900c
  b8:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_Delay:

00000000 <ETH_Delay>:
ETH_Delay():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3050
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
   0:	b084      	sub	sp, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3051
  __IO uint32_t index = 0; 
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3050
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
   4:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3051
  __IO uint32_t index = 0; 
   6:	9303      	str	r3, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3052
  for(index = nCount; index != 0; index--)
   8:	9b01      	ldr	r3, [sp, #4]
   a:	e001      	b.n	10 <ETH_Delay+0x10>
   c:	9b03      	ldr	r3, [sp, #12]
   e:	3b01      	subs	r3, #1
  10:	9303      	str	r3, [sp, #12]
  12:	9b03      	ldr	r3, [sp, #12]
  14:	2b00      	cmp	r3, #0
  16:	d1f9      	bne.n	c <ETH_Delay+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:3055
  {
  }
}
  18:	b004      	add	sp, #16
  1a:	4770      	bx	lr
Disassembly of section .text.ETH_Init:

00000000 <ETH_Init>:
ETH_Init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:141
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   4:	b088      	sub	sp, #32
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:141
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
   6:	9307      	str	r3, [sp, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:144
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
  __IO uint32_t timeout = 0;
   8:	9306      	str	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:196
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   a:	4b83      	ldr	r3, [pc, #524]	(218 <ETH_Init+0x218>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
   c:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:196
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
   e:	691b      	ldr	r3, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:200
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  10:	a801      	add	r0, sp, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:139
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
  12:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:198
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  14:	f023 051c 	bic.w	r5, r3, #28	; 0x1c
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:200
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  18:	f7ff fffe 	bl	0 <RCC_GetClocksFreq>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:201
  hclk = rcc_clocks.HCLK_Frequency;
  1c:	9902      	ldr	r1, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:203
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
  1e:	4b7f      	ldr	r3, [pc, #508]	(21c <ETH_Init+0x21c>)
  20:	4a7f      	ldr	r2, [pc, #508]	(220 <ETH_Init+0x220>)
  22:	18cb      	adds	r3, r1, r3
  24:	4293      	cmp	r3, r2
  26:	d802      	bhi.n	2e <ETH_Init+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:206
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
  28:	f045 0508 	orr.w	r5, r5, #8	; 0x8
  2c:	e006      	b.n	3c <ETH_Init+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:208
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
  2e:	4b7d      	ldr	r3, [pc, #500]	(224 <ETH_Init+0x224>)
  30:	4a7d      	ldr	r2, [pc, #500]	(228 <ETH_Init+0x228>)
  32:	18cb      	adds	r3, r1, r3
  34:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:211
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
  36:	bf98      	it	ls
  38:	f045 050c 	orrls.w	r5, r5, #12	; 0xc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:219
  {
    /* CSR Clock Range between 60-72 MHz */   
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
  3c:	4b76      	ldr	r3, [pc, #472]	(218 <ETH_Init+0x218>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:222
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  3e:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:219
  {
    /* CSR Clock Range between 60-72 MHz */   
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
  40:	611d      	str	r5, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:222
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  42:	2100      	movs	r1, #0
  44:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  48:	f7ff fffe 	bl	0 <ETH_Init>
  4c:	2800      	cmp	r0, #0
  4e:	f000 80df 	beq.w	210 <ETH_Init+0x210>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:229
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_ResetDelay);
  52:	4876      	ldr	r0, [pc, #472]	(1dc <ETH_Init+0x1dc>)
  54:	f7ff fffe 	bl	0 <ETH_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:232
  
    
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  58:	6821      	ldr	r1, [r4, #0]
  5a:	2900      	cmp	r1, #0
  5c:	d044      	beq.n	e8 <ETH_Init+0xe8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  5e:	9b06      	ldr	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  60:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  62:	3301      	adds	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  64:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:237
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked satus... */
    do
    {
      timeout++;
  66:	9306      	str	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:238
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
  68:	f7ff fffe 	bl	0 <ETH_Init>
  6c:	f010 0f04 	tst.w	r0, #4	; 0x4
  70:	d103      	bne.n	7a <ETH_Init+0x7a>
  72:	9a06      	ldr	r2, [sp, #24]
  74:	4b6e      	ldr	r3, [pc, #440]	(230 <ETH_Init+0x230>)
  76:	429a      	cmp	r2, r3
  78:	d9f1      	bls.n	5e <ETH_Init+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:240
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
  7a:	9a06      	ldr	r2, [sp, #24]
  7c:	4b6d      	ldr	r3, [pc, #436]	(234 <ETH_Init+0x234>)
  7e:	429a      	cmp	r2, r3
  80:	f000 80c6 	beq.w	210 <ETH_Init+0x210>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:245
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  84:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:248
    
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
  86:	4630      	mov	r0, r6
  88:	f44f 5280 	mov.w	r2, #4096	; 0x1000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:245
    if(timeout == PHY_READ_TO)
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  8c:	9106      	str	r1, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:248
    
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
  8e:	f7ff fffe 	bl	0 <ETH_Init>
  92:	2800      	cmp	r0, #0
  94:	f000 80bc 	beq.w	210 <ETH_Init+0x210>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  98:	9b06      	ldr	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  9a:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  9c:	3301      	adds	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  9e:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:257
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
  a0:	9306      	str	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:258
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
  a2:	f7ff fffe 	bl	0 <ETH_Init>
  a6:	f010 0f20 	tst.w	r0, #32	; 0x20
  aa:	d103      	bne.n	b4 <ETH_Init+0xb4>
  ac:	9a06      	ldr	r2, [sp, #24]
  ae:	4b60      	ldr	r3, [pc, #384]	(230 <ETH_Init+0x230>)
  b0:	429a      	cmp	r2, r3
  b2:	d9f1      	bls.n	98 <ETH_Init+0x98>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:260
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
  b4:	9a06      	ldr	r2, [sp, #24]
  b6:	4b5f      	ldr	r3, [pc, #380]	(234 <ETH_Init+0x234>)
  b8:	429a      	cmp	r2, r3
  ba:	f000 80a9 	beq.w	210 <ETH_Init+0x210>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:265
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  be:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:268
    
    /* Read the result of the autonegotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
  c0:	2110      	movs	r1, #16
  c2:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:265
    if(timeout == PHY_READ_TO)
    {
      return ETH_ERROR;
    }
    /* Reset Timeout counter */
    timeout = 0;
  c4:	9306      	str	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:268
    
    /* Read the result of the autonegotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
  c6:	f7ff fffe 	bl	0 <ETH_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:271
  
    /* Configure the MAC with the Duplex Mode fixed by the autonegotiation process */
    if((RegValue & PHY_Duplex_Status) != (uint32_t)RESET)
  ca:	f010 0304 	ands.w	r3, r0, #4	; 0x4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:274
    {
      /* Set Ethernet duplex mode to FullDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
  ce:	bf18      	it	ne
  d0:	f44f 6300 	movne.w	r3, #2048	; 0x800
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:283
    {
      /* Set Ethernet duplex mode to HalfDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
    }
    /* Configure the MAC with the speed fixed by the autonegotiation process */
    if(RegValue & PHY_Speed_Status)
  d4:	f010 0f02 	tst.w	r0, #2	; 0x2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:280
            
    }
    else
    {
      /* Set Ethernet duplex mode to HalfDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
  d8:	6223      	str	r3, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:283
    }
    /* Configure the MAC with the speed fixed by the autonegotiation process */
    if(RegValue & PHY_Speed_Status)
  da:	d001      	beq.n	e0 <ETH_Init+0xe0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:286
    {  
      /* Set Ethernet speed to 10M following the autonegotiation */    
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
  dc:	2300      	movs	r3, #0
  de:	e001      	b.n	e4 <ETH_Init+0xe4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:291
    }
    else
    {   
      /* Set Ethernet speed to 100M following the autonegotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
  e0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  e4:	6163      	str	r3, [r4, #20]
  e6:	e00f      	b.n	108 <ETH_Init+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:296
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
  e8:	6a22      	ldr	r2, [r4, #32]
  ea:	6963      	ldr	r3, [r4, #20]
  ec:	08d2      	lsrs	r2, r2, #3
  ee:	ea42 0253 	orr.w	r2, r2, r3, lsr #1
  f2:	4630      	mov	r0, r6
  f4:	b292      	uxth	r2, r2
  f6:	f7ff fffe 	bl	0 <ETH_Init>
  fa:	2800      	cmp	r0, #0
  fc:	f000 8088 	beq.w	210 <ETH_Init+0x210>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:303
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
    }
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_ConfigDelay);
 100:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 104:	f7ff fffe 	bl	0 <ETH_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:308
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 108:	4943      	ldr	r1, [pc, #268]	(218 <ETH_Init+0x218>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:310
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
 10a:	484b      	ldr	r0, [pc, #300]	(238 <ETH_Init+0x238>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:308
    _eth_delay_(PHY_ConfigDelay);
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 10c:	680b      	ldr	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:324
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 10e:	6862      	ldr	r2, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:310
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
 110:	ea03 0000 	and.w	r0, r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:324
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 114:	68a3      	ldr	r3, [r4, #8]
 116:	4313      	orrs	r3, r2
 118:	68e2      	ldr	r2, [r4, #12]
 11a:	4313      	orrs	r3, r2
 11c:	6922      	ldr	r2, [r4, #16]
 11e:	4313      	orrs	r3, r2
 120:	6962      	ldr	r2, [r4, #20]
 122:	4313      	orrs	r3, r2
 124:	69a2      	ldr	r2, [r4, #24]
 126:	4313      	orrs	r3, r2
 128:	69e2      	ldr	r2, [r4, #28]
 12a:	4313      	orrs	r3, r2
 12c:	6a22      	ldr	r2, [r4, #32]
 12e:	4313      	orrs	r3, r2
 130:	6a62      	ldr	r2, [r4, #36]
 132:	4313      	orrs	r3, r2
 134:	6aa2      	ldr	r2, [r4, #40]
 136:	4313      	orrs	r3, r2
 138:	6ae2      	ldr	r2, [r4, #44]
 13a:	4313      	orrs	r3, r2
 13c:	6b22      	ldr	r2, [r4, #48]
 13e:	4313      	orrs	r3, r2
 140:	6b62      	ldr	r2, [r4, #52]
 142:	4313      	orrs	r3, r2
 144:	4303      	orrs	r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:338
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                  ETH_InitStruct->ETH_BackOffLimit | 
                  ETH_InitStruct->ETH_DeferralCheck);
  /* Write to ETHERNET MACCR */
  ETH->MACCR = (uint32_t)tmpreg;
 146:	600b      	str	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:350
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 148:	6ba2      	ldr	r2, [r4, #56]
 14a:	6be3      	ldr	r3, [r4, #60]
 14c:	4313      	orrs	r3, r2
 14e:	6c22      	ldr	r2, [r4, #64]
 150:	4313      	orrs	r3, r2
 152:	6c62      	ldr	r2, [r4, #68]
 154:	4313      	orrs	r3, r2
 156:	6ca2      	ldr	r2, [r4, #72]
 158:	4313      	orrs	r3, r2
 15a:	6ce2      	ldr	r2, [r4, #76]
 15c:	4313      	orrs	r3, r2
 15e:	6d22      	ldr	r2, [r4, #80]
 160:	4313      	orrs	r3, r2
 162:	6d62      	ldr	r2, [r4, #84]
 164:	4313      	orrs	r3, r2
 166:	604b      	str	r3, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:360
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 168:	6da3      	ldr	r3, [r4, #88]
 16a:	608b      	str	r3, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:362
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
 16c:	6de3      	ldr	r3, [r4, #92]
 16e:	60cb      	str	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 170:	6e63      	ldr	r3, [r4, #100]
 172:	6ea2      	ldr	r2, [r4, #104]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:365
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
 174:	6988      	ldr	r0, [r1, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 176:	431a      	orrs	r2, r3
 178:	6ee3      	ldr	r3, [r4, #108]
 17a:	431a      	orrs	r2, r3
 17c:	6f23      	ldr	r3, [r4, #112]
 17e:	431a      	orrs	r2, r3
 180:	6f63      	ldr	r3, [r4, #116]
 182:	431a      	orrs	r2, r3
 184:	f64f 7341 	movw	r3, #65345	; 0xff41
 188:	ea00 0303 	and.w	r3, r0, r3
 18c:	431a      	orrs	r2, r3
 18e:	6e23      	ldr	r3, [r4, #96]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:392
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 190:	482a      	ldr	r0, [pc, #168]	(23c <ETH_Init+0x23c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:375
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 192:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:382
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                   ETH_InitStruct->ETH_ReceiveFlowControl |
                   ETH_InitStruct->ETH_TransmitFlowControl); 
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
 196:	618a      	str	r2, [r1, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:386
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 198:	6fa2      	ldr	r2, [r4, #120]
 19a:	6fe3      	ldr	r3, [r4, #124]
 19c:	4313      	orrs	r3, r2
 19e:	61cb      	str	r3, [r1, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:392
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 1a0:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:394
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 1a2:	4927      	ldr	r1, [pc, #156]	(240 <ETH_Init+0x240>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:405
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 1a4:	f8d4 2080 	ldr.w	r2, [r4, #128]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:394
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 1a8:	ea03 0101 	and.w	r1, r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:405
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 1ac:	f8d4 3084 	ldr.w	r3, [r4, #132]
 1b0:	4313      	orrs	r3, r2
 1b2:	f8d4 2088 	ldr.w	r2, [r4, #136]
 1b6:	4313      	orrs	r3, r2
 1b8:	f8d4 208c 	ldr.w	r2, [r4, #140]
 1bc:	4313      	orrs	r3, r2
 1be:	f8d4 2090 	ldr.w	r2, [r4, #144]
 1c2:	4313      	orrs	r3, r2
 1c4:	f8d4 2094 	ldr.w	r2, [r4, #148]
 1c8:	4313      	orrs	r3, r2
 1ca:	f8d4 2098 	ldr.w	r2, [r4, #152]
 1ce:	4313      	orrs	r3, r2
 1d0:	f8d4 209c 	ldr.w	r2, [r4, #156]
 1d4:	4313      	orrs	r3, r2
 1d6:	f8d4 20a0 	ldr.w	r2, [r4, #160]
 1da:	4313      	orrs	r3, r2
 1dc:	430b      	orrs	r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:415
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
                  ETH_InitStruct->ETH_SecondFrameOperate); 
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
 1de:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:424
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 1e0:	f8d4 20a8 	ldr.w	r2, [r4, #168]
 1e4:	f8d4 30a4 	ldr.w	r3, [r4, #164]
 1e8:	2001      	movs	r0, #1
 1ea:	4313      	orrs	r3, r2
 1ec:	f8d4 20ac 	ldr.w	r2, [r4, #172]
 1f0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 1f4:	4313      	orrs	r3, r2
 1f6:	f8d4 20b0 	ldr.w	r2, [r4, #176]
 1fa:	4313      	orrs	r3, r2
 1fc:	f8d4 20b8 	ldr.w	r2, [r4, #184]
 200:	4313      	orrs	r3, r2
 202:	f8d4 20b4 	ldr.w	r2, [r4, #180]
 206:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
 20a:	4a0e      	ldr	r2, [pc, #56]	(244 <ETH_Init+0x244>)
 20c:	6013      	str	r3, [r2, #0]
 20e:	e000      	b.n	212 <ETH_Init+0x212>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:432
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */  
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
 210:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:433
}
 212:	b008      	add	sp, #32
 214:	bd70      	pop	{r4, r5, r6, pc}
 216:	46c0      	nop			(mov r8, r8)
 218:	40028000 	.word	0x40028000
 21c:	feced300 	.word	0xfeced300
 220:	00e4e1bf 	.word	0x00e4e1bf
 224:	fde9f140 	.word	0xfde9f140
 228:	017d783f 	.word	0x017d783f
 22c:	000fffff 	.word	0x000fffff
 230:	0004fffe 	.word	0x0004fffe
 234:	0004ffff 	.word	0x0004ffff
 238:	ff20810f 	.word	0xff20810f
 23c:	40029018 	.word	0x40029018
 240:	f8de3f23 	.word	0xf8de3f23
 244:	40029000 	.word	0x40029000
Disassembly of section .text.ETH_DeInit:

00000000 <ETH_DeInit>:
ETH_DeInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:124
  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
   0:	2101      	movs	r1, #1
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:125
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
   4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   8:	f7ff fffe 	bl	0 <RCC_AHBPeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:126
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE);
   c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  10:	2100      	movs	r1, #0
  12:	f7ff fffe 	bl	0 <RCC_AHBPeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32_ETH_Driver\src/stm32_eth.c:127
}
  16:	bd10      	pop	{r4, pc}
