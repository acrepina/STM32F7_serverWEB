
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\raw.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\raw.o

Disassembly of section .text.raw_bind:

00000000 <raw_bind>:
raw_bind():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:143
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:144
  ip_addr_set(&pcb->local_ip, ipaddr);
   4:	b901      	cbnz	r1, 8 <raw_bind+0x8>
   6:	e009      	b.n	1c <raw_bind+0x1c>
   8:	784a      	ldrb	r2, [r1, #1]
   a:	780b      	ldrb	r3, [r1, #0]
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	788a      	ldrb	r2, [r1, #2]
  12:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  16:	78ca      	ldrb	r2, [r1, #3]
  18:	ea43 6102 	orr.w	r1, r3, r2, lsl #24
  1c:	6021      	str	r1, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:146
  return ERR_OK;
}
  1e:	2000      	movs	r0, #0
  20:	bd10      	pop	{r4, pc}
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.raw_connect:

00000000 <raw_connect>:
raw_connect():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:163
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:164
  ip_addr_set(&pcb->remote_ip, ipaddr);
   4:	b901      	cbnz	r1, 8 <raw_connect+0x8>
   6:	e009      	b.n	1c <raw_connect+0x1c>
   8:	784a      	ldrb	r2, [r1, #1]
   a:	780b      	ldrb	r3, [r1, #0]
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	788a      	ldrb	r2, [r1, #2]
  12:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  16:	78ca      	ldrb	r2, [r1, #3]
  18:	ea43 6102 	orr.w	r1, r3, r2, lsl #24
  1c:	6061      	str	r1, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:166
  return ERR_OK;
}
  1e:	2000      	movs	r0, #0
  20:	bd10      	pop	{r4, pc}
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.raw_recv:

00000000 <raw_recv>:
raw_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:189
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
   0:	6141      	str	r1, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:190
  pcb->recv_arg = recv_arg;
   2:	6182      	str	r2, [r0, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:191
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.raw_new:

00000000 <raw_new>:
raw_new():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:335
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:340
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
   4:	2000      	movs	r0, #0
   6:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:342
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
   a:	4604      	mov	r4, r0
   c:	b158      	cbz	r0, 26 <raw_new+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:344
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
   e:	221c      	movs	r2, #28
  10:	2100      	movs	r1, #0
  12:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:346
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
  16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:347
    pcb->next = raw_pcbs;
  1a:	4a04      	ldr	r2, [pc, #16]	(2c <raw_new+0x2c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:345
  pcb = memp_malloc(MEMP_RAW_PCB);
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
  1c:	7425      	strb	r5, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:346
    pcb->ttl = RAW_TTL;
  1e:	72e3      	strb	r3, [r4, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:347
    pcb->next = raw_pcbs;
  20:	6813      	ldr	r3, [r2, #0]
  22:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:348
    raw_pcbs = pcb;
  24:	6014      	str	r4, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:351
  }
  return pcb;
}
  26:	4620      	mov	r0, r4
  28:	bd70      	pop	{r4, r5, r6, pc}
  2a:	46c0      	nop			(mov r8, r8)
  2c:	00000000 	.word	0x00000000
Disassembly of section .text.raw_remove:

00000000 <raw_remove>:
raw_remove():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:305
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
   0:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:308
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
   2:	480a      	ldr	r0, [pc, #40]	(2c <raw_remove+0x2c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:305
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
   4:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:308
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
   6:	6802      	ldr	r2, [r0, #0]
   8:	428a      	cmp	r2, r1
   a:	d109      	bne.n	20 <raw_remove+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:310
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
   c:	68cb      	ldr	r3, [r1, #12]
   e:	6003      	str	r3, [r0, #0]
  10:	e008      	b.n	24 <raw_remove+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:315
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  12:	68d3      	ldr	r3, [r2, #12]
  14:	b11b      	cbz	r3, 1e <raw_remove+0x1e>
  16:	428b      	cmp	r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:317
        /* remove pcb from list */
        pcb2->next = pcb->next;
  18:	bf04      	itt	eq
  1a:	68cb      	ldreq	r3, [r1, #12]
  1c:	60d3      	streq	r3, [r2, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:313
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  1e:	68d2      	ldr	r2, [r2, #12]
  20:	2a00      	cmp	r2, #0
  22:	d1f6      	bne.n	12 <raw_remove+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:321
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  24:	2000      	movs	r0, #0
  26:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:322
}
  2a:	bd10      	pop	{r4, pc}
  2c:	00000000 	.word	0x00000000
Disassembly of section .text.raw_sendto:

00000000 <raw_sendto>:
raw_sendto():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:207
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
   0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   6:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:216
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
   8:	4608      	mov	r0, r1
   a:	2114      	movs	r1, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:207
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
   c:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:216
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
   e:	f7ff fffe 	bl	0 <pbuf_header>
  12:	b158      	cbz	r0, 2c <raw_sendto+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:218
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  14:	2100      	movs	r1, #0
  16:	2001      	movs	r0, #1
  18:	460a      	mov	r2, r1
  1a:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:220
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  1e:	4605      	mov	r5, r0
  20:	2800      	cmp	r0, #0
  22:	d02c      	beq.n	7e <raw_sendto+0x7e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:225
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  24:	4631      	mov	r1, r6
  26:	f7ff fffe 	bl	0 <pbuf_chain>
  2a:	e006      	b.n	3a <raw_sendto+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:231
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  2c:	4630      	mov	r0, r6
  2e:	f06f 0113 	mvn.w	r1, #19	; 0x13
  32:	f7ff fffe 	bl	0 <pbuf_header>
  36:	bb10      	cbnz	r0, 7e <raw_sendto+0x7e>
  38:	4635      	mov	r5, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:237
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
  3a:	4640      	mov	r0, r8
  3c:	f7ff fffe 	bl	0 <ip_route>
  40:	4607      	mov	r7, r0
  42:	b930      	cbnz	r0, 52 <raw_sendto+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:240
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  44:	42b5      	cmp	r5, r6
  46:	d002      	beq.n	4e <raw_sendto+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:241
      pbuf_free(q);
  48:	4628      	mov	r0, r5
  4a:	f7ff fffe 	bl	0 <pbuf_free>
  4e:	24fc      	movs	r4, #252
  50:	e016      	b.n	80 <raw_sendto+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:258
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
  52:	4621      	mov	r1, r4
  54:	b10c      	cbz	r4, 5a <raw_sendto+0x5a>
  56:	6823      	ldr	r3, [r4, #0]
  58:	b903      	cbnz	r3, 5c <raw_sendto+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:260
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  5a:	1d39      	adds	r1, r7, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:269
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  5c:	7aa2      	ldrb	r2, [r4, #10]
  5e:	7ae3      	ldrb	r3, [r4, #11]
  60:	9200      	str	r2, [sp, #0]
  62:	7c22      	ldrb	r2, [r4, #16]
  64:	4628      	mov	r0, r5
  66:	9201      	str	r2, [sp, #4]
  68:	4642      	mov	r2, r8
  6a:	9702      	str	r7, [sp, #8]
  6c:	f7ff fffe 	bl	0 <ip_output_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:275
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  70:	42b5      	cmp	r5, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:269
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  72:	b2c4      	uxtb	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:275
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  74:	d004      	beq.n	80 <raw_sendto+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:277
    /* free the header */
    pbuf_free(q);
  76:	4628      	mov	r0, r5
  78:	f7ff fffe 	bl	0 <pbuf_free>
  7c:	e000      	b.n	80 <pbuf_free+0x80>
  7e:	24ff      	movs	r4, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:280
  }
  return err;
}
  80:	b260      	sxtb	r0, r4
  82:	b004      	add	sp, #16
  84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.raw_send:

00000000 <raw_send>:
raw_send():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:291
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:292
  return raw_sendto(pcb, p, &pcb->remote_ip);
   2:	1d02      	adds	r2, r0, #4
   4:	f7ff fffe 	bl	0 <raw_send>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:293
}
   8:	b240      	sxtb	r0, r0
   a:	bd10      	pop	{r4, pc}
Disassembly of section .text.raw_input:

00000000 <raw_input>:
raw_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:79
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:87
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
   4:	6844      	ldr	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:79
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
   6:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:88
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);
   8:	7a23      	ldrb	r3, [r4, #8]
   a:	7a60      	ldrb	r0, [r4, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:104
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
   c:	f104 080c 	add.w	r8, r4, #12	; 0xc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:88
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);
  10:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  14:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:91

  prev = NULL;
  pcb = raw_pcbs;
  18:	4b13      	ldr	r3, [pc, #76]	(68 <raw_input+0x68>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:88
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);
  1a:	fa5f f980 	uxtb.w	r9, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:91

  prev = NULL;
  pcb = raw_pcbs;
  1e:	681d      	ldr	r5, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:104
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
  20:	2400      	movs	r4, #0
  22:	e01b      	b.n	5c <raw_input+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:95
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  24:	7c2b      	ldrb	r3, [r5, #16]
  26:	454b      	cmp	r3, r9
  28:	d113      	bne.n	52 <raw_input+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:102
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
  2a:	696e      	ldr	r6, [r5, #20]
  2c:	b18e      	cbz	r6, 52 <raw_input+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:104
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
  2e:	69a8      	ldr	r0, [r5, #24]
  30:	4629      	mov	r1, r5
  32:	463a      	mov	r2, r7
  34:	4643      	mov	r3, r8
  36:	47b0      	blx	r6
  38:	b158      	cbz	r0, 52 <raw_input+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:108
            /* receive function ate the packet */
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
  3a:	b90c      	cbnz	r4, 40 <raw_input+0x40>
  3c:	4627      	mov	r7, r4
  3e:	e006      	b.n	4e <raw_input+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:111
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
  40:	68eb      	ldr	r3, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:112
              pcb->next = raw_pcbs;
  42:	4a09      	ldr	r2, [pc, #36]	(68 <raw_input+0x68>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:111
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
  44:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:112
              pcb->next = raw_pcbs;
  46:	6813      	ldr	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:113
              raw_pcbs = pcb;
  48:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:112
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
              pcb->next = raw_pcbs;
  4a:	60eb      	str	r3, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:113
              raw_pcbs = pcb;
  4c:	6015      	str	r5, [r2, #0]
  4e:	2001      	movs	r0, #1
  50:	e000      	b.n	54 <raw_input+0x54>
  52:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:122
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  54:	68eb      	ldr	r3, [r5, #12]
  56:	462c      	mov	r4, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:94

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  58:	b918      	cbnz	r0, 62 <raw_input+0x62>
  5a:	461d      	mov	r5, r3
  5c:	2d00      	cmp	r5, #0
  5e:	d1e1      	bne.n	24 <raw_input+0x24>
  60:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/raw.c:125
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  66:	46c0      	nop			(mov r8, r8)
  68:	00000000 	.word	0x00000000
