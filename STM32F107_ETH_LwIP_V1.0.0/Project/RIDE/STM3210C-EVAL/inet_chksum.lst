
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\inet_chksum.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\inet_chksum.o

Disassembly of section .text.lwip_standard_chksum:

00000000 <lwip_standard_chksum>:
lwip_standard_chksum():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:93
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
   0:	468c      	mov	ip, r1
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:100
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
   4:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:93
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
   6:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:100
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
   8:	46e6      	mov	lr, ip
   a:	2000      	movs	r0, #0
   c:	e00a      	b.n	24 <lwip_standard_chksum+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:104
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
   e:	f811 3c02 	ldrb.w	r3, [r1, #-2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:109
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  12:	f811 2c01 	ldrb.w	r2, [r1, #-1]
  16:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:110
    len -= 2;
  1a:	f1ae 0302 	sub.w	r3, lr, #2	; 0x2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:109
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  1e:	1880      	adds	r0, r0, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:110
    len -= 2;
  20:	fa1f fe83 	uxth.w	lr, r3
  24:	3102      	adds	r1, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:101
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  26:	f1be 0f01 	cmp.w	lr, #1	; 0x1
  2a:	d8f0      	bhi.n	e <lwip_standard_chksum+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:112
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  2c:	f01c 0f01 	tst.w	ip, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:101
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  30:	ea4f 035c 	mov.w	r3, ip, lsr #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:115
    len -= 2;
  }
  if (len > 0) {
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  34:	bf1c      	itt	ne
  36:	f814 3013 	ldrbne.w	r3, [r4, r3, lsl #1]
  3a:	eb00 2003 	addne.w	r0, r0, r3, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:118
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  3e:	0403      	lsls	r3, r0, #16
  40:	0c1b      	lsrs	r3, r3, #16
  42:	eb03 4010 	add.w	r0, r3, r0, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:119
  if ((acc & 0xffff0000UL) != 0) {
  46:	0c02      	lsrs	r2, r0, #16
  48:	d002      	beq.n	50 <lwip_standard_chksum+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:120
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  4a:	0403      	lsls	r3, r0, #16
  4c:	0c1b      	lsrs	r3, r3, #16
  4e:	1898      	adds	r0, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:125
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  50:	b280      	uxth	r0, r0
  52:	f7ff fffe 	bl	0 <htons>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:126
}
  56:	bd10      	pop	{r4, pc}
Disassembly of section .text.inet_chksum_pbuf:

00000000 <inet_chksum_pbuf>:
inet_chksum_pbuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:418
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	2400      	movs	r4, #0
   4:	4605      	mov	r5, r0
   6:	4626      	mov	r6, r4
   8:	e017      	b.n	3a <inet_chksum_pbuf+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:426
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
   a:	6868      	ldr	r0, [r5, #4]
   c:	8969      	ldrh	r1, [r5, #10]
   e:	f7ff fffe 	bl	0 <inet_chksum_pbuf>
  12:	1900      	adds	r0, r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:427
    acc = FOLD_U32T(acc);
  14:	0403      	lsls	r3, r0, #16
  16:	0c1b      	lsrs	r3, r3, #16
  18:	eb03 4410 	add.w	r4, r3, r0, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:428
    if (q->len % 2 != 0) {
  1c:	896b      	ldrh	r3, [r5, #10]
  1e:	f013 0f01 	tst.w	r3, #1	; 0x1
  22:	d009      	beq.n	38 <inet_chksum_pbuf+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:429
      swapped = 1 - swapped;
  24:	f1c6 0301 	rsb	r3, r6, #1	; 0x1
  28:	b2de      	uxtb	r6, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:430
      acc = SWAP_BYTES_IN_WORD(acc);
  2a:	0223      	lsls	r3, r4, #8
  2c:	041b      	lsls	r3, r3, #16
  2e:	0c1b      	lsrs	r3, r3, #16
  30:	f3c4 2207 	ubfx	r2, r4, #8, #8
  34:	ea42 0403 	orr.w	r4, r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:425
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  38:	682d      	ldr	r5, [r5, #0]
  3a:	2d00      	cmp	r5, #0
  3c:	d1e5      	bne.n	a <inet_chksum_pbuf+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:434
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  3e:	b136      	cbz	r6, 4e <inet_chksum_pbuf+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:435
    acc = SWAP_BYTES_IN_WORD(acc);
  40:	0223      	lsls	r3, r4, #8
  42:	041b      	lsls	r3, r3, #16
  44:	0c1b      	lsrs	r3, r3, #16
  46:	f3c4 2207 	ubfx	r2, r4, #8, #8
  4a:	ea42 0403 	orr.w	r4, r2, r3
  4e:	43e0      	mvns	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:438
  }
  return (u16_t)~(acc & 0xffffUL);
}
  50:	b280      	uxth	r0, r0
  52:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.inet_chksum:

00000000 <inet_chksum>:
inet_chksum():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:405
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:406
  return ~LWIP_CHKSUM(dataptr, len);
   2:	f7ff fffe 	bl	0 <inet_chksum>
   6:	43c0      	mvns	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:407
}
   8:	b280      	uxth	r0, r0
   a:	bd10      	pop	{r4, pc}
Disassembly of section .text.inet_chksum_pseudo:

00000000 <inet_chksum_pseudo>:
inet_chksum_pseudo():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:286
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	2700      	movs	r7, #0
   6:	460e      	mov	r6, r1
   8:	4690      	mov	r8, r2
   a:	4699      	mov	r9, r3
   c:	f8bd a020 	ldrh.w	sl, [sp, #32]
  10:	4604      	mov	r4, r0
  12:	463d      	mov	r5, r7
  14:	e017      	b.n	46 <inet_chksum_pseudo+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:297
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  16:	6860      	ldr	r0, [r4, #4]
  18:	8961      	ldrh	r1, [r4, #10]
  1a:	f7ff fffe 	bl	0 <inet_chksum_pseudo>
  1e:	19c0      	adds	r0, r0, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:301
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  20:	0403      	lsls	r3, r0, #16
  22:	0c1b      	lsrs	r3, r3, #16
  24:	eb03 4710 	add.w	r7, r3, r0, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:302
    if (q->len % 2 != 0) {
  28:	8963      	ldrh	r3, [r4, #10]
  2a:	f013 0f01 	tst.w	r3, #1	; 0x1
  2e:	d009      	beq.n	44 <inet_chksum_pseudo+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:303
      swapped = 1 - swapped;
  30:	f1c5 0301 	rsb	r3, r5, #1	; 0x1
  34:	b2dd      	uxtb	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:304
      acc = SWAP_BYTES_IN_WORD(acc);
  36:	023b      	lsls	r3, r7, #8
  38:	041b      	lsls	r3, r3, #16
  3a:	0c1b      	lsrs	r3, r3, #16
  3c:	f3c7 2207 	ubfx	r2, r7, #8, #8
  40:	ea42 0703 	orr.w	r7, r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:294
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  44:	6824      	ldr	r4, [r4, #0]
  46:	2c00      	cmp	r4, #0
  48:	d1e5      	bne.n	16 <inet_chksum_pseudo+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:309
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  4a:	b135      	cbz	r5, 5a <inet_chksum_pseudo+0x5a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:310
    acc = SWAP_BYTES_IN_WORD(acc);
  4c:	023b      	lsls	r3, r7, #8
  4e:	041b      	lsls	r3, r3, #16
  50:	0c1b      	lsrs	r3, r3, #16
  52:	f3c7 2207 	ubfx	r2, r7, #8, #8
  56:	ea42 0703 	orr.w	r7, r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:312
  }
  acc += (src->addr & 0xffffUL);
  5a:	7873      	ldrb	r3, [r6, #1]
  5c:	7835      	ldrb	r5, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:314
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  5e:	f898 4000 	ldrb.w	r4, [r8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:312
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  62:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
  66:	78b3      	ldrb	r3, [r6, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:316
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  68:	4648      	mov	r0, r9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:312
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  6a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  6e:	78f3      	ldrb	r3, [r6, #3]
  70:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:314
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  74:	f898 3001 	ldrb.w	r3, [r8, #1]
  78:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  7c:	f898 3002 	ldrb.w	r3, [r8, #2]
  80:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  84:	f898 3003 	ldrb.w	r3, [r8, #3]
  88:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:316
  acc += ((dest->addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  8c:	f7ff fffe 	bl	0 <htons>
  90:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:317
  acc += (u32_t)htons(proto_len);
  92:	4650      	mov	r0, sl
  94:	f7ff fffe 	bl	0 <htons>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:312
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  98:	042b      	lsls	r3, r5, #16
  9a:	0c1b      	lsrs	r3, r3, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:313
  acc += ((src->addr >> 16) & 0xffffUL);
  9c:	0422      	lsls	r2, r4, #16
  9e:	0c12      	lsrs	r2, r2, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:312
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  a0:	eb03 4315 	add.w	r3, r3, r5, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:313
  acc += ((src->addr >> 16) & 0xffffUL);
  a4:	189b      	adds	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:314
  acc += (dest->addr & 0xffffUL);
  a6:	eb03 4314 	add.w	r3, r3, r4, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:315
  acc += ((dest->addr >> 16) & 0xffffUL);
  aa:	19db      	adds	r3, r3, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:316
  acc += (u32_t)htons((u16_t)proto);
  ac:	199b      	adds	r3, r3, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:317
  acc += (u32_t)htons(proto_len);
  ae:	181b      	adds	r3, r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:321

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  b0:	041a      	lsls	r2, r3, #16
  b2:	0c12      	lsrs	r2, r2, #16
  b4:	eb02 4213 	add.w	r2, r2, r3, lsr #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:322
  acc = FOLD_U32T(acc);
  b8:	0410      	lsls	r0, r2, #16
  ba:	0c00      	lsrs	r0, r0, #16
  bc:	eb00 4012 	add.w	r0, r0, r2, lsr #16
  c0:	43c0      	mvns	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/inet_chksum.c:325
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  c2:	b280      	uxth	r0, r0
  c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
