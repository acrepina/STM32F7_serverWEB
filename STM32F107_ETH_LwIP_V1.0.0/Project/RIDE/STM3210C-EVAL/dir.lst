
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\dir.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\dir.o

Disassembly of section .text.dir_findFreeEntryinBuf:

00000000 <dir_findFreeEntryinBuf>:
dir_findFreeEntryinBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:193
 * This function searches for a free entry in a given sector 'buf'.
 * It will put the offset into the loc->Offset field, given that loc is not 0.
 * Return value: 1 when it found a free spot, 0 if it hasn't.
*/
euint32 dir_findFreeEntryinBuf(euint8* buf, FileLocation *loc)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	f04f 0c00 	mov.w	ip, #0	; 0x0
   8:	b088      	sub	sp, #32
   a:	4680      	mov	r8, r0
   c:	460f      	mov	r7, r1
   e:	4666      	mov	r6, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:198
	FileRecord fileEntry;
	euint8 c;
	
	for(c=0;c<16;c++){
		fileEntry = *(((FileRecord*)buf) + c);
  10:	466c      	mov	r4, sp
  12:	eb08 0506 	add.w	r5, r8, r6
  16:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  18:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  1e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:199
		if( !( (fileEntry.Attribute & 0x0F) == 0x0F ) ){
  22:	f89d 300b 	ldrb.w	r3, [sp, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:198
{
	FileRecord fileEntry;
	euint8 c;
	
	for(c=0;c<16;c++){
		fileEntry = *(((FileRecord*)buf) + c);
  26:	f89d 2000 	ldrb.w	r2, [sp]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:199
		if( !( (fileEntry.Attribute & 0x0F) == 0x0F ) ){
  2a:	f003 030f 	and.w	r3, r3, #15	; 0xf
  2e:	2b0f      	cmp	r3, #15
  30:	d007      	beq.n	42 <dir_findFreeEntryinBuf+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:200
			if(fileEntry.FileName[0] == 0x00 ||
  32:	b10a      	cbz	r2, 38 <dir_findFreeEntryinBuf+0x38>
  34:	2ae5      	cmp	r2, #229
  36:	d104      	bne.n	42 <dir_findFreeEntryinBuf+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:202
			   fileEntry.FileName[0] == 0xE5 ){
				if(loc)loc->Offset=c;
  38:	b10f      	cbz	r7, 3e <dir_findFreeEntryinBuf+0x3e>
  3a:	f887 c004 	strb.w	ip, [r7, #4]
  3e:	2001      	movs	r0, #1
  40:	e008      	b.n	54 <dir_findFreeEntryinBuf+0x54>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:197
euint32 dir_findFreeEntryinBuf(euint8* buf, FileLocation *loc)
{
	FileRecord fileEntry;
	euint8 c;
	
	for(c=0;c<16;c++){
  42:	f10c 0301 	add.w	r3, ip, #1	; 0x1
  46:	fa5f fc83 	uxtb.w	ip, r3
  4a:	3620      	adds	r6, #32
  4c:	f1bc 0f10 	cmp.w	ip, #16	; 0x10
  50:	d1de      	bne.n	10 <dir_findFreeEntryinBuf+0x10>
  52:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:208
				return(1);
			}
		}
	}
	return(0);
}
  54:	b008      	add	sp, #32
  56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  5a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_addCluster:

00000000 <dir_addCluster>:
dir_addCluster():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:338
 * clusters you want pre-allocated. It will also delete the contents of that
 * cluster. (or clusters)
 * Return value: 0 on success, -1 on fail
*/
esint8 dir_addCluster(FileSystem *fs,euint32 firstCluster)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	460f      	mov	r7, r1
   4:	b087      	sub	sp, #28
   6:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:342
	euint32 lastc,logicalc;
	ClusterChain cache;
		
	fs_initClusterChain(fs,&cache,firstCluster);
   8:	4669      	mov	r1, sp
   a:	463a      	mov	r2, r7
   c:	f7ff fffe 	bl	0 <fs_initClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:343
	if(fat_allocClusterChain(fs,&cache,1)){
  10:	4628      	mov	r0, r5
  12:	4669      	mov	r1, sp
  14:	2201      	movs	r2, #1
  16:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  1a:	b280      	uxth	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:342
esint8 dir_addCluster(FileSystem *fs,euint32 firstCluster)
{
	euint32 lastc,logicalc;
	ClusterChain cache;
		
	fs_initClusterChain(fs,&cache,firstCluster);
  1c:	466c      	mov	r4, sp
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:343
	if(fat_allocClusterChain(fs,&cache,1)){
  1e:	bb08      	cbnz	r0, 64 <dir_addCluster+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:346
		return(-1);
	}
	lastc = fs_getLastCluster(fs,&cache);
  20:	4669      	mov	r1, sp
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <fs_getLastCluster>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:348
	if(CLUSTER_PREALLOC_DIRECTORY){
		if(fat_allocClusterChain(fs,&cache,CLUSTER_PREALLOC_DIRECTORY)){
  28:	4669      	mov	r1, sp
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:346
		
	fs_initClusterChain(fs,&cache,firstCluster);
	if(fat_allocClusterChain(fs,&cache,1)){
		return(-1);
	}
	lastc = fs_getLastCluster(fs,&cache);
  2a:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:348
	if(CLUSTER_PREALLOC_DIRECTORY){
		if(fat_allocClusterChain(fs,&cache,CLUSTER_PREALLOC_DIRECTORY)){
  2c:	2201      	movs	r2, #1
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  34:	b280      	uxth	r0, r0
  36:	b9a8      	cbnz	r0, 64 <dir_addCluster+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:351
			return(-1);
		}
		logicalc = fat_DiscToLogicCluster(fs,firstCluster,lastc);
  38:	4628      	mov	r0, r5
  3a:	4639      	mov	r1, r7
  3c:	4632      	mov	r2, r6
  3e:	f7ff fffe 	bl	0 <fat_DiscToLogicCluster>
  42:	4604      	mov	r4, r0
  44:	e003      	b.n	4e <dir_addCluster+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:353
		while(!fat_LogicToDiscCluster(fs,&cache,++logicalc)){
			fs_clearCluster(fs,cache.DiscCluster);
  46:	4628      	mov	r0, r5
  48:	9902      	ldr	r1, [sp, #8]
  4a:	f7ff fffe 	bl	0 <fs_clearCluster>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:352
	if(CLUSTER_PREALLOC_DIRECTORY){
		if(fat_allocClusterChain(fs,&cache,CLUSTER_PREALLOC_DIRECTORY)){
			return(-1);
		}
		logicalc = fat_DiscToLogicCluster(fs,firstCluster,lastc);
		while(!fat_LogicToDiscCluster(fs,&cache,++logicalc)){
  4e:	3401      	adds	r4, #1
  50:	4628      	mov	r0, r5
  52:	4669      	mov	r1, sp
  54:	4622      	mov	r2, r4
  56:	f7ff fffe 	bl	0 <fat_LogicToDiscCluster>
  5a:	b280      	uxth	r0, r0
  5c:	2800      	cmp	r0, #0
  5e:	d0f2      	beq.n	46 <fat_LogicToDiscCluster+0x46>
  60:	2000      	movs	r0, #0
  62:	e000      	b.n	66 <fat_LogicToDiscCluster+0x66>
  64:	20ff      	movs	r0, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:359
		}
	}else{
			fs_clearCluster(fs,lastc);
	}
	return(0);
}
  66:	b240      	sxtb	r0, r0
  68:	b007      	add	sp, #28
  6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
Disassembly of section .text.dir_createDefaultEntry:

00000000 <dir_createDefaultEntry>:
dir_createDefaultEntry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:80
 * a given fatfilename. If your system has a means of knowing time, here is an 
 * excellent place to apply it to the filerecord.  
 * Return value: void
*/
void dir_createDefaultEntry(FileSystem *fs,FileRecord *filerec,eint8* fatfilename)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:81
	memCpy(fatfilename,filerec->FileName,11);
   2:	4610      	mov	r0, r2
   4:	220b      	movs	r2, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:80
 * a given fatfilename. If your system has a means of knowing time, here is an 
 * excellent place to apply it to the filerecord.  
 * Return value: void
*/
void dir_createDefaultEntry(FileSystem *fs,FileRecord *filerec,eint8* fatfilename)
{
   6:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:81
	memCpy(fatfilename,filerec->FileName,11);
   8:	f7ff fffe 	bl	0 <memCpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:82
	filerec->Attribute=0x00;
   c:	2300      	movs	r3, #0
   e:	72e3      	strb	r3, [r4, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:83
	filerec->NTReserved=0x00;
  10:	7323      	strb	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:84
	filerec->MilliSecTimeStamp=0x00;
  12:	7363      	strb	r3, [r4, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:85
	filerec->CreatedTime=time_getTime();
  14:	81e3      	strh	r3, [r4, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:86
	filerec->CreatedDate=time_getDate(); 
  16:	8223      	strh	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:87
	filerec->AccessDate=filerec->CreatedDate;
  18:	8263      	strh	r3, [r4, #18]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:88
	filerec->FirstClusterHigh=0x0000;
  1a:	82a3      	strh	r3, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:89
	filerec->WriteTime=filerec->CreatedTime;
  1c:	82e3      	strh	r3, [r4, #22]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:90
	filerec->WriteDate=filerec->CreatedDate;
  1e:	8323      	strh	r3, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:91
	filerec->FirstClusterLow=0x0000;
  20:	8363      	strh	r3, [r4, #26]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:92
	filerec->FileSize=0x00000000;
  22:	61e3      	str	r3, [r4, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:93
}
  24:	bd10      	pop	{r4, pc}
  26:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_getFatFileName:

00000000 <dir_getFatFileName>:
dir_getFatFileName():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:314
 * This function will take a full directory path, and strip off all leading
 * dirs and characters, leaving you with the MS-DOS notation of the actual filename.
 * Return value: 1 on success, 0 on not being able to produca a filename
*/
esint8 dir_getFatFileName(eint8* filename, eint8* fatfilename)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	b085      	sub	sp, #20
   4:	4604      	mov	r4, r0
   6:	460f      	mov	r7, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:317
	eint8 ffnamec[11],*next,nn=0;
	
	memClr(ffnamec,11); memClr(fatfilename,11);
   8:	f10d 0005 	add.w	r0, sp, #5	; 0x5
   c:	210b      	movs	r1, #11
   e:	f7ff fffe 	bl	0 <memClr>
  12:	210b      	movs	r1, #11
  14:	4638      	mov	r0, r7
  16:	f7ff fffe 	bl	0 <memClr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:320
	next = filename;
	
	if(*filename=='/')next++;
  1a:	f994 3000 	ldrsb.w	r3, [r4]
  1e:	2b2f      	cmp	r3, #47
  20:	bf14      	ite	ne
  22:	4625      	movne	r5, r4
  24:	1c65      	addeq	r5, r4, #1
  26:	2400      	movs	r4, #0
  28:	e006      	b.n	38 <dir_getFatFileName+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:323
	
	while((next=file_normalToFatName(next,ffnamec))){
		memCpy(ffnamec,fatfilename,11);	
  2a:	4630      	mov	r0, r6
  2c:	4639      	mov	r1, r7
  2e:	220b      	movs	r2, #11
  30:	f7ff fffe 	bl	0 <memCpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:324
		nn++;
  34:	1c63      	adds	r3, r4, #1
  36:	b2dc      	uxtb	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:322
	memClr(ffnamec,11); memClr(fatfilename,11);
	next = filename;
	
	if(*filename=='/')next++;
	
	while((next=file_normalToFatName(next,ffnamec))){
  38:	f10d 0605 	add.w	r6, sp, #5	; 0x5
  3c:	4628      	mov	r0, r5
  3e:	4631      	mov	r1, r6
  40:	f7ff fffe 	bl	0 <file_normalToFatName>
  44:	4605      	mov	r5, r0
  46:	2800      	cmp	r0, #0
  48:	d1ef      	bne.n	2a <file_normalToFatName+0x2a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:328
		memCpy(ffnamec,fatfilename,11);	
		nn++;
	}
	if(nn)return(1);
	return(0);
}
  4a:	1e20      	subs	r0, r4, #0
  4c:	bf18      	it	ne
  4e:	2001      	movne	r0, #1
  50:	b005      	add	sp, #20
  52:	bdf0      	pop	{r4, r5, r6, r7, pc}
Disassembly of section .text.dir_updateDirectoryEntry:

00000000 <dir_updateDirectoryEntry>:
dir_updateDirectoryEntry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:136
 * This function changes the entire entity stores at loc to the data recorded
 * in entry. This is for custom updates to the directoryentry.
 * Return value: 0 on success, -1 on failure
*/
esint8 dir_updateDirectoryEntry(FileSystem *fs,FileRecord *entry,FileLocation *loc)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4680      	mov	r8, r0
   6:	460e      	mov	r6, r1
   8:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:139
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
   a:	6811      	ldr	r1, [r2, #0]
   c:	6800      	ldr	r0, [r0, #0]
   e:	2202      	movs	r2, #2
  10:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:140
	memCpy(entry,buf+(loc->Offset*sizeof(*entry)),sizeof(*entry));
  14:	7921      	ldrb	r1, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:139
*/
esint8 dir_updateDirectoryEntry(FileSystem *fs,FileRecord *entry,FileLocation *loc)
{
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
  16:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:140
	memCpy(entry,buf+(loc->Offset*sizeof(*entry)),sizeof(*entry));
  18:	eb05 1141 	add.w	r1, r5, r1, lsl #5
  1c:	4630      	mov	r0, r6
  1e:	2220      	movs	r2, #32
  20:	f7ff fffe 	bl	0 <memCpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:141
	part_relSect(fs->part,buf);
  24:	f8d8 0000 	ldr.w	r0, [r8]
  28:	4629      	mov	r1, r5
  2a:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:143
	return(0);
}
  2e:	2000      	movs	r0, #0
  30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.dir_setFileSize:

00000000 <dir_setFileSize>:
dir_setFileSize():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:120
 * Description: This function changes the filesize recorded at loc->Sector
 * to 'numbytes'.
 * Return value: void
*/
void dir_setFileSize(FileSystem *fs, FileLocation *loc,euint32 numbytes)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
   6:	4616      	mov	r6, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:123
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
   8:	6809      	ldr	r1, [r1, #0]
   a:	2202      	movs	r2, #2
   c:	6800      	ldr	r0, [r0, #0]
   e:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:124
	(((FileRecord*)buf)+loc->Offset)->FileSize=numbytes;
  12:	7923      	ldrb	r3, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:123
*/
void dir_setFileSize(FileSystem *fs, FileLocation *loc,euint32 numbytes)
{
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
  14:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:124
	(((FileRecord*)buf)+loc->Offset)->FileSize=numbytes;
  16:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  1a:	61de      	str	r6, [r3, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:125
	part_relSect(fs->part,buf);
  1c:	6828      	ldr	r0, [r5, #0]
  1e:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:126
}
  22:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.dir_setFirstCluster:

00000000 <dir_setFirstCluster>:
dir_setFirstCluster():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:103
 * Description: This function requires modification to release it from
 * depending on the file object.
 * Return value:
*/
void dir_setFirstCluster(FileSystem *fs,FileLocation *loc,euint32 cluster_addr)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460c      	mov	r4, r1
   4:	4615      	mov	r5, r2
   6:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:106
	euint8 *buf;
 	
 	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
   8:	2202      	movs	r2, #2
   a:	6809      	ldr	r1, [r1, #0]
   c:	6800      	ldr	r0, [r0, #0]
   e:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:107
	(((FileRecord*)buf)+loc->Offset)->FirstClusterHigh=cluster_addr>>16;
  12:	7923      	ldrb	r3, [r4, #4]
  14:	0c2a      	lsrs	r2, r5, #16
  16:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  1a:	829a      	strh	r2, [r3, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:108
	(((FileRecord*)buf)+loc->Offset)->FirstClusterLow=cluster_addr&0xFFFF;	
  1c:	7923      	ldrb	r3, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:106
*/
void dir_setFirstCluster(FileSystem *fs,FileLocation *loc,euint32 cluster_addr)
{
	euint8 *buf;
 	
 	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
  1e:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:108
	(((FileRecord*)buf)+loc->Offset)->FirstClusterHigh=cluster_addr>>16;
	(((FileRecord*)buf)+loc->Offset)->FirstClusterLow=cluster_addr&0xFFFF;	
  20:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  24:	835d      	strh	r5, [r3, #26]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:109
	part_relSect(fs->part,buf);
  26:	6830      	ldr	r0, [r6, #0]
  28:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:110
}
  2c:	bd70      	pop	{r4, r5, r6, pc}
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_createDirectoryEntry:

00000000 <dir_createDirectoryEntry>:
dir_createDirectoryEntry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:63
 * Description: This function writes the filerecord stored in filerec to disc at
 * location loc. 
 * Return value: void
*/
void dir_createDirectoryEntry(FileSystem *fs,FileRecord *filerec,FileLocation *loc)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4680      	mov	r8, r0
   6:	460e      	mov	r6, r1
   8:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:66
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
   a:	6811      	ldr	r1, [r2, #0]
   c:	6800      	ldr	r0, [r0, #0]
   e:	2202      	movs	r2, #2
  10:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:67
	memCpy(filerec,buf+(loc->Offset*sizeof(*filerec)),sizeof(*filerec));
  14:	7921      	ldrb	r1, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:66
*/
void dir_createDirectoryEntry(FileSystem *fs,FileRecord *filerec,FileLocation *loc)
{
	euint8 *buf;
	
	buf = part_getSect(fs->part,loc->Sector,IOM_MODE_READWRITE);
  16:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:67
	memCpy(filerec,buf+(loc->Offset*sizeof(*filerec)),sizeof(*filerec));
  18:	eb05 1141 	add.w	r1, r5, r1, lsl #5
  1c:	4630      	mov	r0, r6
  1e:	2220      	movs	r2, #32
  20:	f7ff fffe 	bl	0 <memCpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:68
	part_relSect(fs->part,buf);
  24:	f8d8 0000 	ldr.w	r0, [r8]
  28:	4629      	mov	r1, r5
  2a:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:69
}
  2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  32:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_getFileStructure:

00000000 <dir_getFileStructure>:
dir_getFileStructure():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:46
 * Description: This function stores the filerecord located at loc in filerec.
 * It fetches the required sector for this.
 * Return value: void
*/
void dir_getFileStructure(FileSystem *fs,FileRecord *filerec,FileLocation *loc)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4680      	mov	r8, r0
   6:	460e      	mov	r6, r1
   8:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:49
	euint8 *buf;

	buf=part_getSect(fs->part,loc->Sector,IOM_MODE_READONLY);
   a:	6811      	ldr	r1, [r2, #0]
   c:	6800      	ldr	r0, [r0, #0]
   e:	2201      	movs	r2, #1
  10:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:50
	*filerec=*(((FileRecord*)buf)+loc->Offset);
  14:	7923      	ldrb	r3, [r4, #4]
  16:	4635      	mov	r5, r6
  18:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  1c:	461c      	mov	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:49
*/
void dir_getFileStructure(FileSystem *fs,FileRecord *filerec,FileLocation *loc)
{
	euint8 *buf;

	buf=part_getSect(fs->part,loc->Sector,IOM_MODE_READONLY);
  1e:	4684      	mov	ip, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:50
	*filerec=*(((FileRecord*)buf)+loc->Offset);
  20:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  22:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  24:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  28:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:51
	part_relSect(fs->part,buf);
  2c:	4661      	mov	r1, ip
  2e:	f8d8 0000 	ldr.w	r0, [r8]
  32:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:52
}	
  36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  3a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_findFileinBuf:

00000000 <dir_findFileinBuf>:
dir_findFileinBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:156
 * If loc is 0, then it's members are not touched.
 * Return value: This function returns 0 when it cannot find the file,
 * if it can find the file it will return the first cluster number.
*/
euint32 dir_findFileinBuf(euint8 *buf, eint8 *fatname, FileLocation *loc)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	2600      	movs	r6, #0
   6:	b088      	sub	sp, #32
   8:	4682      	mov	sl, r0
   a:	4689      	mov	r9, r1
   c:	4690      	mov	r8, r2
   e:	4637      	mov	r7, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:162
	FileRecord fileEntry;
	euint8 c;
	
	for(c=0; c<16; c++)
	{
		fileEntry = *(((FileRecord*)buf) + c);
  10:	466c      	mov	r4, sp
  12:	eb0a 0507 	add.w	r5, sl, r7
  16:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  18:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  1e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:164
		/* Check if the entry is for short filenames */
		if( !( (fileEntry.Attribute & 0x0F) == 0x0F ) )
  22:	f89d 300b 	ldrb.w	r3, [sp, #11]
  26:	f003 030f 	and.w	r3, r3, #15	; 0xf
  2a:	2b0f      	cmp	r3, #15
  2c:	d017      	beq.n	5e <dir_findFileinBuf+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:166
		{
			if( strMatch((eint8*)fileEntry.FileName,fatname,11) == 0 )
  2e:	4668      	mov	r0, sp
  30:	4649      	mov	r1, r9
  32:	220b      	movs	r2, #11
  34:	f7ff fffe 	bl	0 <strMatch>
  38:	b988      	cbnz	r0, 5e <strMatch+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:169
			{
				/* The entry has been found, return the location in the dir */
				if(loc)loc->Offset = c;
  3a:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
  3e:	d005      	beq.n	4c <strMatch+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:170
				if(loc)loc->attrib = fileEntry.Attribute;
  40:	f89d 300b 	ldrb.w	r3, [sp, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:169
		if( !( (fileEntry.Attribute & 0x0F) == 0x0F ) )
		{
			if( strMatch((eint8*)fileEntry.FileName,fatname,11) == 0 )
			{
				/* The entry has been found, return the location in the dir */
				if(loc)loc->Offset = c;
  44:	f888 6004 	strb.w	r6, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:170
				if(loc)loc->attrib = fileEntry.Attribute;
  48:	f888 3005 	strb.w	r3, [r8, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:171
				if((((euint32 )fileEntry.FirstClusterHigh)<<16)+ fileEntry.FirstClusterLow==0){
  4c:	f8bd 2014 	ldrh.w	r2, [sp, #20]
  50:	f8bd 301a 	ldrh.w	r3, [sp, #26]
  54:	eb13 4002 	adds.w	r0, r3, r2, lsl #16
  58:	bf08      	it	eq
  5a:	2001      	moveq	r0, #1
  5c:	e005      	b.n	6a <strMatch+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:160
euint32 dir_findFileinBuf(euint8 *buf, eint8 *fatname, FileLocation *loc)
{
	FileRecord fileEntry;
	euint8 c;
	
	for(c=0; c<16; c++)
  5e:	1c73      	adds	r3, r6, #1
  60:	b2de      	uxtb	r6, r3
  62:	3720      	adds	r7, #32
  64:	2e10      	cmp	r6, #16
  66:	d1d3      	bne.n	10 <strMatch+0x10>
  68:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:184
				}
			}
		}
	}
	return(0);
}
  6a:	b008      	add	sp, #32
  6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
Disassembly of section .text.dir_findinBuf:

00000000 <dir_findinBuf>:
dir_findinBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:216
 * euint32  dir_findinBuf(euint8 *buf, eint8 *fatname, FileLocation *loc)
 * Description: This function searches for a given fatfilename in a buffer.
 * Return value: Returns 0 on not found, and the firstcluster when the name is found.
*/
euint32  dir_findinBuf(euint8 *buf, eint8 *fatname, FileLocation *loc, euint8 mode)
{
   0:	b510      	push	{r4, lr}
   2:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:217
	switch(mode){
   4:	b11b      	cbz	r3, e <dir_findinBuf+0xe>
   6:	2b01      	cmp	r3, #1
   8:	d004      	beq.n	14 <dir_findinBuf+0x14>
   a:	2000      	movs	r0, #0
   c:	e005      	b.n	1a <dir_findinBuf+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:219
		case DIRFIND_FILE:
			return(dir_findFileinBuf(buf,fatname,loc));
   e:	f7ff fffe 	bl	0 <dir_findinBuf>
  12:	e002      	b.n	1a <dir_findinBuf+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:222
			//break;
		case DIRFIND_FREE:
			return(dir_findFreeEntryinBuf(buf,loc));
  14:	4611      	mov	r1, r2
  16:	f7ff fffe 	bl	0 <dir_findinBuf>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:229
		default:
			return(0);
			//break;
	}
	//return(0);
}
  1a:	bd10      	pop	{r4, pc}
Disassembly of section .text.dir_findinRootArea:

00000000 <dir_findinRootArea>:
dir_findinRootArea():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:288
 * This function will search for an existing (fatname) or free directory entry
 * in the rootdirectory-area of a FAT12/FAT16 filesystem.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinRootArea(FileSystem *fs,eint8* fatname, FileLocation *loc, euint8 mode)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4699      	mov	r9, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:292
	euint32 c,fclus;
	euint8 *buf=0;
	
	if((fs->type != FAT12) && (fs->type != FAT16))return(0);
   6:	f890 303c 	ldrb.w	r3, [r0, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:288
 * This function will search for an existing (fatname) or free directory entry
 * in the rootdirectory-area of a FAT12/FAT16 filesystem.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinRootArea(FileSystem *fs,eint8* fatname, FileLocation *loc, euint8 mode)
{
   a:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:292
	euint32 c,fclus;
	euint8 *buf=0;
	
	if((fs->type != FAT12) && (fs->type != FAT16))return(0);
   c:	3b01      	subs	r3, #1
   e:	b2db      	uxtb	r3, r3
  10:	2b01      	cmp	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:288
 * This function will search for an existing (fatname) or free directory entry
 * in the rootdirectory-area of a FAT12/FAT16 filesystem.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinRootArea(FileSystem *fs,eint8* fatname, FileLocation *loc, euint8 mode)
{
  12:	468a      	mov	sl, r1
  14:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:292
	euint32 c,fclus;
	euint8 *buf=0;
	
	if((fs->type != FAT12) && (fs->type != FAT16))return(0);
  16:	d828      	bhi.n	6a <dir_findinRootArea+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:294
	
	for(c=fs->FirstSectorRootDir;c<(fs->FirstSectorRootDir+fs->volumeId.RootEntryCount/32);c++){
  18:	6ac6      	ldr	r6, [r0, #44]
  1a:	2700      	movs	r7, #0
  1c:	e01b      	b.n	56 <dir_findinRootArea+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:295
		buf = part_getSect(fs->part,c,IOM_MODE_READONLY);
  1e:	4631      	mov	r1, r6
  20:	2201      	movs	r2, #1
  22:	6820      	ldr	r0, [r4, #0]
  24:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:296
		if((fclus=dir_findinBuf(buf,fatname,loc,mode))){
  28:	4651      	mov	r1, sl
  2a:	4642      	mov	r2, r8
  2c:	464b      	mov	r3, r9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:295
	euint8 *buf=0;
	
	if((fs->type != FAT12) && (fs->type != FAT16))return(0);
	
	for(c=fs->FirstSectorRootDir;c<(fs->FirstSectorRootDir+fs->volumeId.RootEntryCount/32);c++){
		buf = part_getSect(fs->part,c,IOM_MODE_READONLY);
  2e:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:296
		if((fclus=dir_findinBuf(buf,fatname,loc,mode))){
  30:	f7ff fffe 	bl	0 <dir_findinRootArea>
  34:	4605      	mov	r5, r0
  36:	b148      	cbz	r0, 4c <dir_findinRootArea+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:297
			if(loc)loc->Sector=c;
  38:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
  3c:	d001      	beq.n	42 <dir_findinRootArea+0x42>
  3e:	f8c8 6000 	str.w	r6, [r8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:298
			part_relSect(fs->part,buf);
  42:	6820      	ldr	r0, [r4, #0]
  44:	4639      	mov	r1, r7
  46:	f7ff fffe 	bl	0 <part_relSect>
  4a:	e00f      	b.n	6c <dir_findinRootArea+0x6c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:301
			return(fclus);
		}	
		part_relSect(fs->part,buf);	
  4c:	6820      	ldr	r0, [r4, #0]
  4e:	4639      	mov	r1, r7
  50:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:294
	euint32 c,fclus;
	euint8 *buf=0;
	
	if((fs->type != FAT12) && (fs->type != FAT16))return(0);
	
	for(c=fs->FirstSectorRootDir;c<(fs->FirstSectorRootDir+fs->volumeId.RootEntryCount/32);c++){
  54:	3601      	adds	r6, #1
  56:	89a2      	ldrh	r2, [r4, #12]
  58:	6ae3      	ldr	r3, [r4, #44]
  5a:	eb03 1352 	add.w	r3, r3, r2, lsr #5
  5e:	429e      	cmp	r6, r3
  60:	d3dd      	bcc.n	1e <dir_findinRootArea+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:303
			part_relSect(fs->part,buf);
			return(fclus);
		}	
		part_relSect(fs->part,buf);	
	}
	part_relSect(fs->part,buf);
  62:	6820      	ldr	r0, [r4, #0]
  64:	4639      	mov	r1, r7
  66:	f7ff fffe 	bl	0 <part_relSect>
  6a:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:305
	return(0);
}
  6c:	4628      	mov	r0, r5
  6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  72:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_findinCluster:

00000000 <dir_findinCluster>:
dir_findinCluster():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:239
 * This function will search for an existing (fatname) or free directory entry
 * in a full cluster.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinCluster(FileSystem *fs,euint32 cluster,eint8 *fatname, FileLocation *loc, euint8 mode)
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4606      	mov	r6, r0
   6:	4689      	mov	r9, r1
   8:	4693      	mov	fp, r2
   a:	461f      	mov	r7, r3
   c:	f89d a028 	ldrb.w	sl, [sp, #40]
  10:	2500      	movs	r5, #0
  12:	e023      	b.n	5c <dir_findinCluster+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:244
	euint8 c,*buf=0;
	euint32 fclus;
	
	for(c=0;c<fs->volumeId.SectorsPerCluster;c++){
		buf = part_getSect(fs->part,fs_clusterToSector(fs,cluster)+c,IOM_MODE_READONLY);
  14:	4649      	mov	r1, r9
  16:	4630      	mov	r0, r6
  18:	6834      	ldr	r4, [r6, #0]
  1a:	f7ff fffe 	bl	0 <fs_clusterToSector>
  1e:	2201      	movs	r2, #1
  20:	1941      	adds	r1, r0, r5
  22:	4620      	mov	r0, r4
  24:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:245
		if((fclus=dir_findinBuf(buf,fatname,loc,mode))){
  28:	4659      	mov	r1, fp
  2a:	463a      	mov	r2, r7
  2c:	4653      	mov	r3, sl
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:244
{
	euint8 c,*buf=0;
	euint32 fclus;
	
	for(c=0;c<fs->volumeId.SectorsPerCluster;c++){
		buf = part_getSect(fs->part,fs_clusterToSector(fs,cluster)+c,IOM_MODE_READONLY);
  2e:	4680      	mov	r8, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:245
		if((fclus=dir_findinBuf(buf,fatname,loc,mode))){
  30:	f7ff fffe 	bl	0 <dir_findinCluster>
  34:	4604      	mov	r4, r0
  36:	b158      	cbz	r0, 50 <dir_findinCluster+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:246
			if(loc)loc->Sector=fs_clusterToSector(fs,cluster)+c;
  38:	b12f      	cbz	r7, 46 <dir_findinCluster+0x46>
  3a:	4630      	mov	r0, r6
  3c:	4649      	mov	r1, r9
  3e:	f7ff fffe 	bl	0 <fs_clusterToSector>
  42:	1940      	adds	r0, r0, r5
  44:	6038      	str	r0, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:247
			part_relSect(fs->part,buf);
  46:	6830      	ldr	r0, [r6, #0]
  48:	4641      	mov	r1, r8
  4a:	f7ff fffe 	bl	0 <part_relSect>
  4e:	e009      	b.n	64 <dir_findinCluster+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:250
			return(fclus);
		}
		part_relSect(fs->part,buf); /* Thanks Mike ;) */
  50:	6830      	ldr	r0, [r6, #0]
  52:	4641      	mov	r1, r8
  54:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:243
euint32 dir_findinCluster(FileSystem *fs,euint32 cluster,eint8 *fatname, FileLocation *loc, euint8 mode)
{
	euint8 c,*buf=0;
	euint32 fclus;
	
	for(c=0;c<fs->volumeId.SectorsPerCluster;c++){
  58:	1c6b      	adds	r3, r5, #1
  5a:	b2dd      	uxtb	r5, r3
  5c:	79b3      	ldrb	r3, [r6, #6]
  5e:	42ab      	cmp	r3, r5
  60:	d8d8      	bhi.n	14 <part_relSect+0x14>
  62:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:253
			return(fclus);
		}
		part_relSect(fs->part,buf); /* Thanks Mike ;) */
	}
	return(0);
}
  64:	4620      	mov	r0, r4
  66:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  6a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dir_findinDir:

00000000 <dir_findinDir>:
dir_findinDir():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:262
 * This function will search for an existing (fatname) or free directory entry
 * in a directory, following the clusterchains.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinDir(FileSystem *fs, eint8* fatname,euint32 firstcluster, FileLocation *loc, euint8 mode)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	461d      	mov	r5, r3
   6:	b088      	sub	sp, #32
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:267
	euint32 c=0,cluster;
	ClusterChain Cache;
	
	Cache.DiscCluster = Cache.FirstCluster = firstcluster;
	Cache.LogicCluster = Cache.LastCluster = Cache.Linear = 0;
   8:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:269
	
	if(firstcluster <= 1){
   a:	2a01      	cmp	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:262
 * This function will search for an existing (fatname) or free directory entry
 * in a directory, following the clusterchains.
 * Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
*/
euint32 dir_findinDir(FileSystem *fs, eint8* fatname,euint32 firstcluster, FileLocation *loc, euint8 mode)
{
   c:	4607      	mov	r7, r0
   e:	4688      	mov	r8, r1
  10:	f89d 6038 	ldrb.w	r6, [sp, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:266
	euint32 c=0,cluster;
	ClusterChain Cache;
	
	Cache.DiscCluster = Cache.FirstCluster = firstcluster;
  14:	9205      	str	r2, [sp, #20]
  16:	9204      	str	r2, [sp, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:267
	Cache.LogicCluster = Cache.LastCluster = Cache.Linear = 0;
  18:	f88d 3008 	strb.w	r3, [sp, #8]
  1c:	9306      	str	r3, [sp, #24]
  1e:	9303      	str	r3, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:269
	
	if(firstcluster <= 1){
  20:	d901      	bls.n	26 <dir_findinDir+0x26>
  22:	461a      	mov	r2, r3
  24:	e00f      	b.n	46 <dir_findinDir+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:270
		return(dir_findinRootArea(fs,fatname,loc,mode));	
  26:	4633      	mov	r3, r6
  28:	462a      	mov	r2, r5
  2a:	f7ff fffe 	bl	0 <dir_findinDir>
  2e:	4603      	mov	r3, r0
  30:	e012      	b.n	58 <dir_findinDir+0x58>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:274
	}
	
	while(!fat_LogicToDiscCluster(fs,&Cache,c++)){
		if((cluster=dir_findinCluster(fs,Cache.DiscCluster,fatname,loc,mode))){
  32:	462b      	mov	r3, r5
  34:	4638      	mov	r0, r7
  36:	9904      	ldr	r1, [sp, #16]
  38:	4642      	mov	r2, r8
  3a:	9600      	str	r6, [sp, #0]
  3c:	f7ff fffe 	bl	0 <dir_findinDir>
  40:	4603      	mov	r3, r0
  42:	b948      	cbnz	r0, 58 <dir_findinDir+0x58>
  44:	4622      	mov	r2, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:273
	
	if(firstcluster <= 1){
		return(dir_findinRootArea(fs,fatname,loc,mode));	
	}
	
	while(!fat_LogicToDiscCluster(fs,&Cache,c++)){
  46:	4638      	mov	r0, r7
  48:	a902      	add	r1, sp, #8
  4a:	1c54      	adds	r4, r2, #1
  4c:	f7ff fffe 	bl	0 <fat_LogicToDiscCluster>
  50:	b280      	uxth	r0, r0
  52:	2800      	cmp	r0, #0
  54:	d0ed      	beq.n	32 <fat_LogicToDiscCluster+0x32>
  56:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/dir.c:279
		if((cluster=dir_findinCluster(fs,Cache.DiscCluster,fatname,loc,mode))){
			return(cluster);
		}
	}
	return(0);
}
  58:	4618      	mov	r0, r3
  5a:	b008      	add	sp, #32
  5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
