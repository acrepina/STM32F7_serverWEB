
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\pbuf.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\pbuf.o

Disassembly of section .text.pbuf_header:

00000000 <pbuf_header>:
pbuf_header():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:398
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
   0:	468c      	mov	ip, r1
   2:	2900      	cmp	r1, #0
   4:	d02e      	beq.n	64 <pbuf_header+0x64>
   6:	2800      	cmp	r0, #0
   8:	d02c      	beq.n	64 <pbuf_header+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:401
    return 0;
 
  if (header_size_increment < 0){
   a:	2900      	cmp	r1, #0
   c:	da06      	bge.n	1c <pbuf_header+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:402
    increment_magnitude = -header_size_increment;
   e:	f1c1 0300 	rsb	r3, r1, #0	; 0x0
  12:	b29a      	uxth	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:404
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  14:	8943      	ldrh	r3, [r0, #10]
  16:	4293      	cmp	r3, r2
  18:	d201      	bcs.n	1e <pbuf_header+0x1e>
  1a:	e025      	b.n	68 <pbuf_header+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:406
  } else {
    increment_magnitude = header_size_increment;
  1c:	b28a      	uxth	r2, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:419
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  1e:	7b03      	ldrb	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:421
  /* remember current payload pointer */
  payload = p->payload;
  20:	6841      	ldr	r1, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:424

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  22:	b10b      	cbz	r3, 28 <pbuf_header+0x28>
  24:	2b03      	cmp	r3, #3
  26:	d108      	bne.n	3a <pbuf_header+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:426
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  28:	ebcc 0201 	rsb	r2, ip, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:428
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  2c:	f100 0310 	add.w	r3, r0, #16	; 0x10
  30:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:426
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  32:	6042      	str	r2, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:428
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  34:	d20e      	bcs.n	54 <pbuf_header+0x54>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:433
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  36:	6041      	str	r1, [r0, #4]
  38:	e016      	b.n	68 <pbuf_header+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:438
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  3a:	3b01      	subs	r3, #1
  3c:	b29b      	uxth	r3, r3
  3e:	2b01      	cmp	r3, #1
  40:	d812      	bhi.n	68 <pbuf_header+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:440
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  42:	f1bc 0f00 	cmp.w	ip, #0	; 0x0
  46:	da0f      	bge.n	68 <pbuf_header+0x68>
  48:	8943      	ldrh	r3, [r0, #10]
  4a:	4293      	cmp	r3, r2
  4c:	d30c      	bcc.n	68 <pbuf_header+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:442
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  4e:	ebcc 0301 	rsb	r3, ip, r1
  52:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:455
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  54:	8942      	ldrh	r2, [r0, #10]
  56:	fa1f f38c 	uxth.w	r3, ip
  5a:	189a      	adds	r2, r3, r2
  5c:	8142      	strh	r2, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:456
  p->tot_len += header_size_increment;
  5e:	8902      	ldrh	r2, [r0, #8]
  60:	189b      	adds	r3, r3, r2
  62:	8103      	strh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:461

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  64:	2000      	movs	r0, #0
  66:	e000      	b.n	6a <pbuf_header+0x6a>
  68:	2001      	movs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:462
}
  6a:	4770      	bx	lr
Disassembly of section .text.pbuf_clen:

00000000 <pbuf_clen>:
pbuf_clen():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:574
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
   0:	4602      	mov	r2, r0
   2:	2000      	movs	r0, #0
   4:	e002      	b.n	c <pbuf_clen+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:579
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
   6:	1c43      	adds	r3, r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:580
    p = p->next;
   8:	6812      	ldr	r2, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:579
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
   a:	b2d8      	uxtb	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:578
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
   c:	2a00      	cmp	r2, #0
   e:	d1fa      	bne.n	6 <pbuf_clen+0x6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:583
    ++len;
    p = p->next;
  }
  return len;
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_ref:

00000000 <pbuf_ref>:
pbuf_ref():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:596
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
   0:	b110      	cbz	r0, 8 <pbuf_ref+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:598
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
   2:	89c3      	ldrh	r3, [r0, #14]
   4:	3301      	adds	r3, #1
   6:	81c3      	strh	r3, [r0, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:601
    SYS_ARCH_UNPROTECT(old_level);
  }
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_cat:

00000000 <pbuf_cat>:
pbuf_cat():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:615
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:618
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
   2:	b160      	cbz	r0, 1e <pbuf_cat+0x1e>
   4:	b919      	cbnz	r1, e <pbuf_cat+0xe>
   6:	e00a      	b.n	1e <pbuf_cat+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:624
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
   8:	189b      	adds	r3, r3, r2
   a:	8103      	strh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:622

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
   c:	4620      	mov	r0, r4
   e:	6804      	ldr	r4, [r0, #0]
  10:	890b      	ldrh	r3, [r1, #8]
  12:	8902      	ldrh	r2, [r0, #8]
  14:	2c00      	cmp	r4, #0
  16:	d1f7      	bne.n	8 <pbuf_cat+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:630
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  18:	189b      	adds	r3, r3, r2
  1a:	8103      	strh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:632
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  1c:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:636
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.pbuf_chain:

00000000 <pbuf_chain>:
pbuf_chain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:656
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:657
  pbuf_cat(h, t);
   4:	f7ff fffe 	bl	0 <pbuf_chain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:659
  /* t is now referenced by h */
  pbuf_ref(t);
   8:	4620      	mov	r0, r4
   a:	f7ff fffe 	bl	0 <pbuf_chain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:661
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
   e:	bd10      	pop	{r4, pc}
Disassembly of section .text.pbuf_take:

00000000 <pbuf_take>:
pbuf_take():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:836
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4688      	mov	r8, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:842
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
   6:	b1e0      	cbz	r0, 42 <pbuf_take+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:843
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
   8:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
   c:	d019      	beq.n	42 <pbuf_take+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:845

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
   e:	8903      	ldrh	r3, [r0, #8]
  10:	4293      	cmp	r3, r2
  12:	d201      	bcs.n	18 <pbuf_take+0x18>
  14:	20f6      	movs	r0, #246
  16:	e015      	b.n	44 <pbuf_take+0x44>
  18:	4606      	mov	r6, r0
  1a:	4615      	mov	r5, r2
  1c:	2700      	movs	r7, #0
  1e:	e00e      	b.n	3e <pbuf_take+0x3e>
  20:	8974      	ldrh	r4, [r6, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:858
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
  22:	6870      	ldr	r0, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:845
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
  24:	42a5      	cmp	r5, r4
  26:	bf38      	it	cc
  28:	462c      	movcc	r4, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:858
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
  2a:	eb08 0107 	add.w	r1, r8, r7
  2e:	4622      	mov	r2, r4
  30:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:859
    total_copy_len -= buf_copy_len;
  34:	1b2b      	subs	r3, r5, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:850
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
  36:	6836      	ldr	r6, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:860
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  38:	19e4      	adds	r4, r4, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:859
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
  3a:	b29d      	uxth	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:860
    copied_total += buf_copy_len;
  3c:	b2a7      	uxth	r7, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:850
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
  3e:	2d00      	cmp	r5, #0
  40:	d1ee      	bne.n	20 <memcpy+0x20>
  42:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:864
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
}
  44:	b240      	sxtb	r0, r0
  46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_copy_partial:

00000000 <pbuf_copy_partial>:
pbuf_copy_partial():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:788
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4689      	mov	r9, r1
   6:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:794
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
   8:	b340      	cbz	r0, 5c <pbuf_copy_partial+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:795
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
   a:	b339      	cbz	r1, 5c <pbuf_copy_partial+0x5c>
   c:	2600      	movs	r6, #0
   e:	4605      	mov	r5, r0
  10:	4637      	mov	r7, r6
  12:	e01d      	b.n	50 <pbuf_copy_partial+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:805
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  14:	b12b      	cbz	r3, 22 <pbuf_copy_partial+0x22>
  16:	896a      	ldrh	r2, [r5, #10]
  18:	4293      	cmp	r3, r2
  1a:	d302      	bcc.n	22 <pbuf_copy_partial+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:807
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  1c:	1a9b      	subs	r3, r3, r2
  1e:	b29b      	uxth	r3, r3
  20:	e015      	b.n	4e <pbuf_copy_partial+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:810
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  22:	896c      	ldrh	r4, [r5, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:814
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  24:	6869      	ldr	r1, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:810
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  26:	1ae4      	subs	r4, r4, r3
  28:	b2a4      	uxth	r4, r4
  2a:	4544      	cmp	r4, r8
  2c:	bf28      	it	cs
  2e:	4644      	movcs	r4, r8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:814
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  30:	eb09 0006 	add.w	r0, r9, r6
  34:	18c9      	adds	r1, r1, r3
  36:	4622      	mov	r2, r4
  38:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:815
      copied_total += buf_copy_len;
  3c:	19e3      	adds	r3, r4, r7
  3e:	b29f      	uxth	r7, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:816
      left += buf_copy_len;
  40:	19a3      	adds	r3, r4, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:817
      len -= buf_copy_len;
  42:	ebc4 0408 	rsb	r4, r4, r8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:816
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
  46:	b29e      	uxth	r6, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:817
      len -= buf_copy_len;
  48:	fa1f f884 	uxth.w	r8, r4
  4c:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:804
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  4e:	682d      	ldr	r5, [r5, #0]
  50:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
  54:	d003      	beq.n	5e <memcpy+0x5e>
  56:	2d00      	cmp	r5, #0
  58:	d1dc      	bne.n	14 <memcpy+0x14>
  5a:	e000      	b.n	5e <memcpy+0x5e>
  5c:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:822
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  5e:	4638      	mov	r0, r7
  60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
Disassembly of section .text.pbuf_copy:

00000000 <pbuf_copy>:
pbuf_copy():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:722
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:729

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
   6:	4606      	mov	r6, r0
   8:	2800      	cmp	r0, #0
   a:	d03a      	beq.n	82 <pbuf_copy+0x82>
   c:	2900      	cmp	r1, #0
   e:	d038      	beq.n	82 <pbuf_copy+0x82>
  10:	8902      	ldrh	r2, [r0, #8]
  12:	890b      	ldrh	r3, [r1, #8]
  14:	429a      	cmp	r2, r3
  16:	d334      	bcc.n	82 <pbuf_copy+0x82>
  18:	2700      	movs	r7, #0
  1a:	46b8      	mov	r8, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:737
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  1c:	8973      	ldrh	r3, [r6, #10]
  1e:	896a      	ldrh	r2, [r5, #10]
  20:	1bdb      	subs	r3, r3, r7
  22:	ebc8 0202 	rsb	r2, r8, r2
  26:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:744
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  28:	6870      	ldr	r0, [r6, #4]
  2a:	6869      	ldr	r1, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:739
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  2c:	bfac      	ite	ge
  2e:	b294      	uxthge	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:742
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  30:	b29c      	uxthlt	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:744
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  32:	4441      	add	r1, r8
  34:	19c0      	adds	r0, r0, r7
  36:	4622      	mov	r2, r4
  38:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:745
    offset_to += len;
  3c:	19e3      	adds	r3, r4, r7
  3e:	b29f      	uxth	r7, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:746
    offset_from += len;
  40:	eb04 0308 	add.w	r3, r4, r8
  44:	fa1f f883 	uxth.w	r8, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:748
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
  48:	8973      	ldrh	r3, [r6, #10]
  4a:	42bb      	cmp	r3, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:754
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
  4c:	896b      	ldrh	r3, [r5, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:751
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  4e:	bf04      	itt	eq
  50:	6836      	ldreq	r6, [r6, #0]
  52:	2700      	moveq	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:754
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
  54:	4543      	cmp	r3, r8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:757
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  56:	bf9c      	itt	ls
  58:	682d      	ldrls	r5, [r5, #0]
  5a:	f04f 0800 	movls.w	r8, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:760
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  5e:	b12d      	cbz	r5, 6c <memcpy+0x6c>
  60:	896a      	ldrh	r2, [r5, #10]
  62:	892b      	ldrh	r3, [r5, #8]
  64:	429a      	cmp	r2, r3
  66:	d101      	bne.n	6c <memcpy+0x6c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:762
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  68:	682b      	ldr	r3, [r5, #0]
  6a:	b963      	cbnz	r3, 86 <memcpy+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:765
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  6c:	b12e      	cbz	r6, 7a <memcpy+0x7a>
  6e:	8972      	ldrh	r2, [r6, #10]
  70:	8933      	ldrh	r3, [r6, #8]
  72:	429a      	cmp	r2, r3
  74:	d101      	bne.n	7a <memcpy+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:767
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  76:	6833      	ldr	r3, [r6, #0]
  78:	b92b      	cbnz	r3, 86 <memcpy+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:770
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  7a:	2d00      	cmp	r5, #0
  7c:	d1ce      	bne.n	1c <memcpy+0x1c>
  7e:	4629      	mov	r1, r5
  80:	e002      	b.n	88 <memcpy+0x88>
  82:	21f6      	movs	r1, #246
  84:	e000      	b.n	88 <memcpy+0x88>
  86:	21f7      	movs	r1, #247
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:773
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  88:	b248      	sxtb	r0, r1
  8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  8e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_free:

00000000 <pbuf_free>:
pbuf_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:499
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:504
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
   2:	4601      	mov	r1, r0
   4:	b908      	cbnz	r0, a <pbuf_free+0xa>
   6:	4604      	mov	r4, r0
   8:	e01b      	b.n	42 <pbuf_free+0x42>
   a:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:531
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
   c:	89cb      	ldrh	r3, [r1, #14]
   e:	3b01      	subs	r3, #1
  10:	b29b      	uxth	r3, r3
  12:	81cb      	strh	r3, [r1, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:534
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  14:	b9ab      	cbnz	r3, 42 <pbuf_free+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:538
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  16:	7b0b      	ldrb	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:536
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  18:	680d      	ldr	r5, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:540
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  1a:	2b03      	cmp	r3, #3
  1c:	d101      	bne.n	22 <pbuf_free+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:541
        memp_free(MEMP_PBUF_POOL, p);
  1e:	2008      	movs	r0, #8
  20:	e004      	b.n	2c <pbuf_free+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:543
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  22:	3b01      	subs	r3, #1
  24:	b29b      	uxth	r3, r3
  26:	2b01      	cmp	r3, #1
  28:	d803      	bhi.n	32 <pbuf_free+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:544
        memp_free(MEMP_PBUF, p);
  2a:	2007      	movs	r0, #7
  2c:	f7ff fffe 	bl	0 <memp_free>
  30:	e002      	b.n	38 <pbuf_free+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:547
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  32:	4608      	mov	r0, r1
  34:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:549
      }
      count++;
  38:	1c63      	adds	r3, r4, #1
  3a:	b2dc      	uxtb	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:521
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  3c:	4629      	mov	r1, r5
  3e:	2d00      	cmp	r5, #0
  40:	d1e4      	bne.n	c <mem_free+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:563
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  42:	4620      	mov	r0, r4
  44:	bd70      	pop	{r4, r5, r6, pc}
  46:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_dechain:

00000000 <pbuf_dechain>:
pbuf_dechain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:673
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:677
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
   2:	6804      	ldr	r4, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:679
  /* pbuf has successor in chain? */
  if (q != NULL) {
   4:	b164      	cbz	r4, 20 <pbuf_dechain+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:683
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
   6:	8903      	ldrh	r3, [r0, #8]
   8:	8942      	ldrh	r2, [r0, #10]
   a:	1a9b      	subs	r3, r3, r2
   c:	8123      	strh	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:685
    /* decouple pbuf from remainder */
    p->next = NULL;
   e:	2300      	movs	r3, #0
  10:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:687
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  12:	8102      	strh	r2, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:690
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  14:	4620      	mov	r0, r4
  16:	f7ff fffe 	bl	0 <pbuf_dechain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:699
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
  1a:	2800      	cmp	r0, #0
  1c:	bf18      	it	ne
  1e:	2400      	movne	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:700
}
  20:	4620      	mov	r0, r4
  22:	bd10      	pop	{r4, pc}
Disassembly of section .text.pbuf_realloc:

00000000 <pbuf_realloc>:
pbuf_realloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:323
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
   0:	8903      	ldrh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:311
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
   2:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:323
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
   4:	4299      	cmp	r1, r3
   6:	d221      	bcs.n	4c <pbuf_realloc+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:330
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
   8:	ebc3 0c01 	rsb	ip, r3, r1
   c:	4604      	mov	r4, r0
   e:	460d      	mov	r5, r1
  10:	e005      	b.n	1e <pbuf_realloc+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:338
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  12:	1aab      	subs	r3, r5, r2
  14:	b29d      	uxth	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:341
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
  16:	8923      	ldrh	r3, [r4, #8]
  18:	4463      	add	r3, ip
  1a:	8123      	strh	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:343
    /* proceed to next pbuf in chain */
    q = q->next;
  1c:	6824      	ldr	r4, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:336

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  1e:	8962      	ldrh	r2, [r4, #10]
  20:	4295      	cmp	r5, r2
  22:	d8f6      	bhi.n	12 <pbuf_realloc+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:351
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  24:	7b23      	ldrb	r3, [r4, #12]
  26:	b94b      	cbnz	r3, 3c <pbuf_realloc+0x3c>
  28:	4295      	cmp	r5, r2
  2a:	d007      	beq.n	3c <pbuf_realloc+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:353
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  2c:	6861      	ldr	r1, [r4, #4]
  2e:	4620      	mov	r0, r4
  30:	1869      	adds	r1, r5, r1
  32:	1b09      	subs	r1, r1, r4
  34:	b289      	uxth	r1, r1
  36:	f7ff fffe 	bl	0 <mem_realloc>
  3a:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:361
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  q->tot_len = q->len;

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  3c:	6820      	ldr	r0, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:357
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  3e:	8165      	strh	r5, [r4, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:358
  q->tot_len = q->len;
  40:	8125      	strh	r5, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:361

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  42:	b108      	cbz	r0, 48 <pbuf_realloc+0x48>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:363
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  44:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:366
  }
  /* q is last packet in chain */
  q->next = NULL;
  48:	2300      	movs	r3, #0
  4a:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:368

}
  4c:	bd70      	pop	{r4, r5, r6, pc}
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.pbuf_alloc:

00000000 <pbuf_alloc>:
pbuf_alloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:153
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4617      	mov	r7, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:161
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
   8:	2803      	cmp	r0, #3
   a:	f200 8083 	bhi.w	114 <pbuf_alloc+0x114>
   e:	e8df f000 	tbb	[pc, r0]
  12:	0806      	.short	0x0806
  14:	0204      	.short	0x0204
  16:	2400      	movs	r4, #0
  18:	e007      	b.n	2a <pbuf_alloc+0x2a>
  1a:	2300      	movs	r3, #0
  1c:	e003      	b.n	26 <pbuf_alloc+0x26>
  1e:	2314      	movs	r3, #20
  20:	e000      	b.n	24 <pbuf_alloc+0x24>
  22:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:168
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  24:	3314      	adds	r3, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:172
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  26:	330e      	adds	r3, #14
  28:	b29c      	uxth	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:181
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  2a:	2f03      	cmp	r7, #3
  2c:	d872      	bhi.n	114 <pbuf_alloc+0x114>
  2e:	e8df f007 	tbb	[pc, r7]
  32:	604a      	.short	0x604a
  34:	0260      	.short	0x0260
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:184
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    ALLOC_POOL_PBUF(p);
  36:	2008      	movs	r0, #8
  38:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:186
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  3c:	4605      	mov	r5, r0
  3e:	2800      	cmp	r0, #0
  40:	d069      	beq.n	116 <pbuf_alloc+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:189
      return NULL;
    }
    p->type = type;
  42:	2303      	movs	r3, #3
  44:	7303      	strb	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:190
    p->next = NULL;
  46:	2300      	movs	r3, #0
  48:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:193

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  4a:	f104 0313 	add.w	r3, r4, #19	; 0x13
  4e:	18c3      	adds	r3, r0, r3
  50:	f023 0303 	bic.w	r3, r3, #3	; 0x3
  54:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:199
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  56:	1ce3      	adds	r3, r4, #3
  58:	f023 0303 	bic.w	r3, r3, #3	; 0x3
  5c:	f5c3 63ba 	rsb	r3, r3, #1488	; 0x5d0
  60:	330c      	adds	r3, #12
  62:	42b3      	cmp	r3, r6
  64:	bfa8      	it	ge
  66:	4633      	movge	r3, r6
  68:	8143      	strh	r3, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:206
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  6a:	f04f 0301 	mov.w	r3, #1	; 0x1
  6e:	81c3      	strh	r3, [r0, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:213
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  70:	8943      	ldrh	r3, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:197
    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  72:	8106      	strh	r6, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:213
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  74:	4607      	mov	r7, r0
  76:	1af6      	subs	r6, r6, r3
  78:	e022      	b.n	c0 <pbuf_alloc+0xc0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:216
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      ALLOC_POOL_PBUF(q);
  7a:	2008      	movs	r0, #8
  7c:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:217
      if (q == NULL) {
  80:	4604      	mov	r4, r0
  82:	b920      	cbnz	r0, 8e <pbuf_alloc+0x8e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:219
        /* free chain so far allocated */
        pbuf_free(p);
  84:	4628      	mov	r0, r5
  86:	f7ff fffe 	bl	0 <pbuf_alloc>
  8a:	4625      	mov	r5, r4
  8c:	e043      	b.n	116 <pbuf_alloc+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:223
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
  8e:	2303      	movs	r3, #3
  90:	7303      	strb	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:224
      q->flags = 0;
  92:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:225
      q->next = NULL;
  94:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:224
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
      q->flags = 0;
  96:	7343      	strb	r3, [r0, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:232
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  98:	f240 51dc 	movw	r1, #1500	; 0x5dc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:230
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
  9c:	b2b3      	uxth	r3, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:232
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  9e:	f240 52db 	movw	r2, #1499	; 0x5db
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:230
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
  a2:	8103      	strh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:232
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  a4:	4293      	cmp	r3, r2
  a6:	bf88      	it	hi
  a8:	460b      	movhi	r3, r1
  aa:	8143      	strh	r3, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:233
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  ac:	f100 0310 	add.w	r3, r0, #16	; 0x10
  b0:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:239
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  b2:	f04f 0301 	mov.w	r3, #1	; 0x1
  b6:	81c3      	strh	r3, [r0, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:241
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  b8:	8943      	ldrh	r3, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:227
      }
      q->type = type;
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
  ba:	6038      	str	r0, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:241
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  bc:	1af6      	subs	r6, r6, r3
  be:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:215
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  c0:	2e00      	cmp	r6, #0
  c2:	dcda      	bgt.n	7a <pbuf_alloc+0x7a>
  c4:	e020      	b.n	108 <pbuf_alloc+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:251
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  c6:	3413      	adds	r4, #19
  c8:	1cf3      	adds	r3, r6, #3
  ca:	f023 0303 	bic.w	r3, r3, #3	; 0x3
  ce:	f024 0003 	bic.w	r0, r4, #3	; 0x3
  d2:	18c0      	adds	r0, r0, r3
  d4:	b280      	uxth	r0, r0
  d6:	f7ff fffe 	bl	0 <mem_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:252
    if (p == NULL) {
  da:	4605      	mov	r5, r0
  dc:	b1d8      	cbz	r0, 116 <pbuf_alloc+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:256
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  de:	1903      	adds	r3, r0, r4
  e0:	f023 0303 	bic.w	r3, r3, #3	; 0x3
  e4:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:258
    p->len = p->tot_len = length;
    p->next = NULL;
  e6:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:257
    if (p == NULL) {
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    p->len = p->tot_len = length;
  e8:	8106      	strh	r6, [r0, #8]
  ea:	8146      	strh	r6, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:258
    p->next = NULL;
  ec:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:259
    p->type = type;
  ee:	7303      	strb	r3, [r0, #12]
  f0:	e00a      	b.n	108 <pbuf_alloc+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:269
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  f2:	2007      	movs	r0, #7
  f4:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:270
    if (p == NULL) {
  f8:	4605      	mov	r5, r0
  fa:	b160      	cbz	r0, 116 <memp_malloc+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:276
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  fc:	2300      	movs	r3, #0
  fe:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:277
    p->len = p->tot_len = length;
 100:	8106      	strh	r6, [r0, #8]
 102:	8146      	strh	r6, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:278
    p->next = NULL;
 104:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:279
    p->type = type;
 106:	7307      	strb	r7, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:286
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 108:	f04f 0301 	mov.w	r3, #1	; 0x1
 10c:	81eb      	strh	r3, [r5, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:288
  /* set flags */
  p->flags = 0;
 10e:	2300      	movs	r3, #0
 110:	736b      	strb	r3, [r5, #13]
 112:	e000      	b.n	116 <memp_malloc+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:290
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 114:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:291
}
 116:	4628      	mov	r0, r5
 118:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.pbuf_coalesce:

00000000 <pbuf_coalesce>:
pbuf_coalesce():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:880
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:883
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
   4:	6823      	ldr	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:880
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
   6:	4608      	mov	r0, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:883
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
   8:	b163      	cbz	r3, 24 <pbuf_coalesce+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:886
    return p;
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
   a:	8921      	ldrh	r1, [r4, #8]
   c:	2200      	movs	r2, #0
   e:	f7ff fffe 	bl	0 <pbuf_coalesce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:887
  if (q == NULL) {
  12:	4605      	mov	r5, r0
  14:	b130      	cbz	r0, 24 <pbuf_coalesce+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:891
    /* @todo: what do we do now? */
    return p;
  }
  err = pbuf_copy(q, p);
  16:	4621      	mov	r1, r4
  18:	f7ff fffe 	bl	0 <pbuf_coalesce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:893
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
  1c:	4620      	mov	r0, r4
  1e:	f7ff fffe 	bl	0 <pbuf_coalesce>
  22:	462c      	mov	r4, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/pbuf.c:895
  return q;
}
  24:	4620      	mov	r0, r4
  26:	bd70      	pop	{r4, r5, r6, pc}
