
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\ip_frag.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\ip_frag.o

Disassembly of section .text.ip_frag:

00000000 <ip_frag>:
ip_frag():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:629
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36
   6:	9002      	str	r0, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:656
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
   8:	2002      	movs	r0, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:629
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
   a:	9101      	str	r1, [sp, #4]
   c:	9200      	str	r2, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:640
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
   e:	f8b1 b02c 	ldrh.w	fp, [r1, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:656
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  12:	4602      	mov	r2, r0
  14:	2100      	movs	r1, #0
  16:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:657
  if (rambuf == NULL) {
  1a:	4607      	mov	r7, r0
  1c:	b908      	cbnz	r0, 22 <ip_frag+0x22>
  1e:	30ff      	adds	r0, #255
  20:	e097      	b.n	152 <ip_frag+0x152>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:662
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  22:	4b4e      	ldr	r3, [pc, #312]	(15c <ip_frag+0x15c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:666

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  24:	9a02      	ldr	r2, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:662
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  26:	f023 0603 	bic.w	r6, r3, #3	; 0x3
  2a:	6046      	str	r6, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:666

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  2c:	6851      	ldr	r1, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:661
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  2e:	f8a0 b00a 	strh.w	fp, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:666
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  32:	2214      	movs	r2, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:661
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  34:	f8a0 b008 	strh.w	fp, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:666
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:673
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  3e:	79b3      	ldrb	r3, [r6, #6]
  40:	79f0      	ldrb	r0, [r6, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:690
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  42:	f04f 0a14 	mov.w	sl, #20	; 0x14
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:673
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  46:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  4a:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:677
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
  4e:	9a02      	ldr	r2, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:674
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  50:	ea4f 49c0 	mov.w	r9, r0, lsl #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:677
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
  54:	8913      	ldrh	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:679

  nfb = (mtu - IP_HLEN) / 8;
  56:	2208      	movs	r2, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:677
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
  58:	3b14      	subs	r3, #20
  5a:	b29d      	uxth	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:679

  nfb = (mtu - IP_HLEN) / 8;
  5c:	f1ab 0314 	sub.w	r3, fp, #20	; 0x14
  60:	fb93 f3f2 	sdiv	r3, r3, r2
  64:	b29b      	uxth	r3, r3
  66:	9304      	str	r3, [sp, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:690
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  68:	00db      	lsls	r3, r3, #3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:675
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  6a:	f400 5000 	and.w	r0, r0, #8192	; 0x2000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:690
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  6e:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:674
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  70:	ea4f 49d9 	mov.w	r9, r9, lsr #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:675
  omf = tmp & IP_MF;
  74:	9005      	str	r0, [sp, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:690
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  76:	9307      	str	r3, [sp, #28]
  78:	e065      	b.n	146 <ip_frag+0x146>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:682
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  7a:	f1ab 0313 	sub.w	r3, fp, #19	; 0x13
  7e:	42ab      	cmp	r3, r5
  80:	bfd4      	ite	le
  82:	2300      	movle	r3, #0
  84:	2301      	movgt	r3, #1
  86:	9306      	str	r3, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:685

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  88:	9a05      	ldr	r2, [sp, #20]
  8a:	ea4f 43c9 	mov.w	r3, r9, lsl #19
  8e:	0cdb      	lsrs	r3, r3, #19
  90:	ea43 0402 	orr.w	r4, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:686
    if (!last)
  94:	9b06      	ldr	r3, [sp, #24]
  96:	b10b      	cbz	r3, 9c <ip_frag+0x9c>
  98:	46a8      	mov	r8, r5
  9a:	e003      	b.n	a4 <ip_frag+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:687
      tmp = tmp | IP_MF;
  9c:	f8dd 801c 	ldr.w	r8, [sp, #28]
  a0:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:693

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  a4:	4642      	mov	r2, r8
  a6:	f106 0114 	add.w	r1, r6, #20	; 0x14
  aa:	4653      	mov	r3, sl
  ac:	9802      	ldr	r0, [sp, #8]
  ae:	f7ff fffe 	bl	0 <pbuf_copy_partial>
  b2:	9003      	str	r0, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:741
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  b4:	4620      	mov	r0, r4
  b6:	f7ff fffe 	bl	0 <htons>
  ba:	71b0      	strb	r0, [r6, #6]
  bc:	f3c0 200f 	ubfx	r0, r0, #8, #16
  c0:	71f0      	strb	r0, [r6, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:742
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  c2:	f108 0014 	add.w	r0, r8, #20	; 0x14
  c6:	b280      	uxth	r0, r0
  c8:	f7ff fffe 	bl	0 <htons>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:741
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  cc:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:742
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  ce:	70b0      	strb	r0, [r6, #2]
  d0:	f3c0 200f 	ubfx	r0, r0, #8, #16
  d4:	70f0      	strb	r0, [r6, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:743
    IPH_CHKSUM_SET(iphdr, 0);
  d6:	72b4      	strb	r4, [r6, #10]
  d8:	72f4      	strb	r4, [r6, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:744
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  da:	4630      	mov	r0, r6
  dc:	2114      	movs	r1, #20
  de:	f7ff fffe 	bl	0 <inet_chksum>
  e2:	72b0      	strb	r0, [r6, #10]
  e4:	f3c0 200f 	ubfx	r0, r0, #8, #16
  e8:	72f0      	strb	r0, [r6, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:747

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  ea:	9a06      	ldr	r2, [sp, #24]
  ec:	b12a      	cbz	r2, fa <ip_frag+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:748
      pbuf_realloc(rambuf, left + IP_HLEN);
  ee:	f105 0114 	add.w	r1, r5, #20	; 0x14
  f2:	4638      	mov	r0, r7
  f4:	b289      	uxth	r1, r1
  f6:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:755
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  fa:	2100      	movs	r1, #0
  fc:	2002      	movs	r0, #2
  fe:	460a      	mov	r2, r1
 100:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:756
    if (header != NULL) {
 104:	4604      	mov	r4, r0
 106:	b1c8      	cbz	r0, 13c <ip_frag+0x13c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:693

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 108:	9a03      	ldr	r2, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:757
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
 10a:	4639      	mov	r1, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:693

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 10c:	eb02 030a 	add.w	r3, r2, sl
 110:	fa1f fa83 	uxth.w	sl, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:757
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
 114:	f7ff fffe 	bl	0 <pbuf_chain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:758
      netif->output(netif, header, dest);
 118:	9a01      	ldr	r2, [sp, #4]
 11a:	4621      	mov	r1, r4
 11c:	6953      	ldr	r3, [r2, #20]
 11e:	4610      	mov	r0, r2
 120:	9a00      	ldr	r2, [sp, #0]
 122:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:761
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 124:	4620      	mov	r0, r4
 126:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:784
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
 12a:	9a04      	ldr	r2, [sp, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:783
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 12c:	ebc8 0305 	rsb	r3, r8, r5
 130:	b29d      	uxth	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:784
    ofo += nfb;
 132:	eb09 0302 	add.w	r3, r9, r2
 136:	fa1f f983 	uxth.w	r9, r3
 13a:	e004      	b.n	146 <ip_frag+0x146>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:764
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
 13c:	4638      	mov	r0, r7
 13e:	f7ff fffe 	bl	0 <pbuf_free>
 142:	20ff      	movs	r0, #255
 144:	e005      	b.n	152 <ip_frag+0x152>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:681

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 146:	2d00      	cmp	r5, #0
 148:	d197      	bne.n	7a <ip_frag+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:787
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
 14a:	4638      	mov	r0, r7
 14c:	f7ff fffe 	bl	0 <pbuf_free>
 150:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:791
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 152:	b240      	sxtb	r0, r0
 154:	b009      	add	sp, #36
 156:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 15a:	46c0      	nop			(mov r8, r8)
 15c:	00000003 	.word	0x00000003
Disassembly of section .text.ip_reass_dequeue_datagram:

00000000 <ip_reass_dequeue_datagram>:
ip_reass_dequeue_datagram():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:298
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   0:	4602      	mov	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:301
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
   2:	4807      	ldr	r0, [pc, #28]	(20 <ip_reass_dequeue_datagram+0x20>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:298
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   4:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:301
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
   6:	f8d0 35e0 	ldr.w	r3, [r0, #1504]
   a:	4293      	cmp	r3, r2
   c:	6813      	ldr	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:307
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
   e:	bf14      	ite	ne
  10:	600b      	strne	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:303
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  12:	f8c0 35e0 	streq.w	r3, [r0, #1504]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:311
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  16:	4611      	mov	r1, r2
  18:	2005      	movs	r0, #5
  1a:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:312
}
  1e:	bd10      	pop	{r4, pc}
  20:	00000000 	.word	0x00000000
Disassembly of section .text.ip_reass_free_complete_datagram:

00000000 <ip_reass_free_complete_datagram>:
ip_reass_free_complete_datagram():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:157
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:169
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
   4:	6844      	ldr	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:157
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   6:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:169
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
   8:	6860      	ldr	r0, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:157
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   a:	4688      	mov	r8, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:170
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
   c:	7902      	ldrb	r2, [r0, #4]
   e:	7943      	ldrb	r3, [r0, #5]
  10:	ea52 2303 	orrs.w	r3, r2, r3, lsl #8
  14:	d001      	beq.n	1a <ip_reass_free_complete_datagram+0x1a>
  16:	2600      	movs	r6, #0
  18:	e01a      	b.n	50 <ip_reass_free_complete_datagram+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:174
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  1a:	7842      	ldrb	r2, [r0, #1]
  1c:	7803      	ldrb	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:176
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  1e:	f107 0108 	add.w	r1, r7, #8	; 0x8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:174
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  22:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  26:	7882      	ldrb	r2, [r0, #2]
  28:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  2c:	78c2      	ldrb	r2, [r0, #3]
  2e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  32:	607b      	str	r3, [r7, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:176
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  34:	2214      	movs	r2, #20
  36:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:177
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  3a:	4620      	mov	r0, r4
  3c:	2101      	movs	r1, #1
  3e:	f7ff fffe 	bl	0 <icmp_time_exceeded>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:178
    pbufs_freed += pbuf_clen(p);
  42:	4620      	mov	r0, r4
  44:	f7ff fffe 	bl	0 <pbuf_clen>
  48:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:179
    pbuf_free(p);
  4a:	4620      	mov	r0, r4
  4c:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:185
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  50:	687d      	ldr	r5, [r7, #4]
  52:	e012      	b.n	7a <ip_reass_free_complete_datagram+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:188
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  54:	686a      	ldr	r2, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:192
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
  56:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:191
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  58:	7853      	ldrb	r3, [r2, #1]
  5a:	7814      	ldrb	r4, [r2, #0]
  5c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  60:	7893      	ldrb	r3, [r2, #2]
  62:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  66:	78d3      	ldrb	r3, [r2, #3]
  68:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:192
    pbufs_freed += pbuf_clen(pcur);
  6c:	f7ff fffe 	bl	0 <pbuf_clen>
  70:	1836      	adds	r6, r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:193
    pbuf_free(pcur);    
  72:	4628      	mov	r0, r5
  74:	f7ff fffe 	bl	0 <pbuf_free>
  78:	4625      	mov	r5, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:186
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  7a:	2d00      	cmp	r5, #0
  7c:	d1ea      	bne.n	54 <ip_reass_free_complete_datagram+0x54>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:196
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  7e:	4638      	mov	r0, r7
  80:	4641      	mov	r1, r8
  82:	f7ff fffe 	bl	0 <ip_reass_free_complete_datagram>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:198
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
  86:	4a04      	ldr	r2, [pc, #16]	(98 <ip_reass_free_complete_datagram+0x98>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:201

  return pbufs_freed;
}
  88:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:198
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
  8a:	f8b2 35e4 	ldrh.w	r3, [r2, #1508]
  8e:	1b9b      	subs	r3, r3, r6
  90:	f8a2 35e4 	strh.w	r3, [r2, #1508]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:201

  return pbufs_freed;
}
  94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  98:	00000000 	.word	0x00000000
Disassembly of section .text.ip_reass_remove_oldest_datagram:

00000000 <ip_reass_remove_oldest_datagram>:
ip_reass_remove_oldest_datagram():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:215
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   6:	4688      	mov	r8, r1
   8:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:229
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
   a:	4b21      	ldr	r3, [pc, #132]	(90 <ip_reass_remove_oldest_datagram+0x90>)
   c:	2600      	movs	r6, #0
   e:	f8d3 05e0 	ldr.w	r0, [r3, #1504]
  12:	4635      	mov	r5, r6
  14:	46b4      	mov	ip, r6
  16:	e02c      	b.n	72 <ip_reass_remove_oldest_datagram+0x72>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:231
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  18:	7b62      	ldrb	r2, [r4, #13]
  1a:	7b23      	ldrb	r3, [r4, #12]
  1c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  20:	7ba2      	ldrb	r2, [r4, #14]
  22:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  26:	7be2      	ldrb	r2, [r4, #15]
  28:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  2c:	6942      	ldr	r2, [r0, #20]
  2e:	429a      	cmp	r2, r3
  30:	d113      	bne.n	5a <ip_reass_remove_oldest_datagram+0x5a>
  32:	7c62      	ldrb	r2, [r4, #17]
  34:	7c23      	ldrb	r3, [r4, #16]
  36:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  3a:	7ca2      	ldrb	r2, [r4, #18]
  3c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40:	7ce2      	ldrb	r2, [r4, #19]
  42:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  46:	6982      	ldr	r2, [r0, #24]
  48:	429a      	cmp	r2, r3
  4a:	d106      	bne.n	5a <ip_reass_remove_oldest_datagram+0x5a>
  4c:	7923      	ldrb	r3, [r4, #4]
  4e:	7962      	ldrb	r2, [r4, #5]
  50:	8981      	ldrh	r1, [r0, #12]
  52:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  56:	4299      	cmp	r1, r3
  58:	d006      	beq.n	68 <ip_reass_remove_oldest_datagram+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:233
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  5a:	3601      	adds	r6, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:234
        if (oldest == NULL) {
  5c:	b11d      	cbz	r5, 66 <ip_reass_remove_oldest_datagram+0x66>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:236
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  5e:	7fc2      	ldrb	r2, [r0, #31]
  60:	7feb      	ldrb	r3, [r5, #31]
  62:	429a      	cmp	r2, r3
  64:	d800      	bhi.n	68 <ip_reass_remove_oldest_datagram+0x68>
  66:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:241
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  68:	6803      	ldr	r3, [r0, #0]
  6a:	2b00      	cmp	r3, #0
  6c:	bf18      	it	ne
  6e:	4684      	movne	ip, r0
  70:	4618      	mov	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:230
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  72:	2800      	cmp	r0, #0
  74:	d1d0      	bne.n	18 <ip_reass_remove_oldest_datagram+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:246
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  76:	b125      	cbz	r5, 82 <ip_reass_remove_oldest_datagram+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:247
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  78:	4628      	mov	r0, r5
  7a:	4661      	mov	r1, ip
  7c:	f7ff fffe 	bl	0 <ip_reass_remove_oldest_datagram>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:248
      pbufs_freed += pbufs_freed_current;
  80:	183f      	adds	r7, r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:250
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  82:	4547      	cmp	r7, r8
  84:	da01      	bge.n	8a <ip_reass_remove_oldest_datagram+0x8a>
  86:	2e01      	cmp	r6, #1
  88:	dcbf      	bgt.n	a <ip_reass_remove_oldest_datagram+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:252
  return pbufs_freed;
}
  8a:	4638      	mov	r0, r7
  8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  90:	00000000 	.word	0x00000000
Disassembly of section .text.ip_reass_tmr:

00000000 <ip_reass_tmr>:
ip_reass_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:124
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
   0:	4b09      	ldr	r3, [pc, #36]	(28 <ip_reass_tmr+0x28>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:121
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
   2:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:124
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
   4:	f8d3 05e0 	ldr.w	r0, [r3, #1504]
   8:	2500      	movs	r5, #0
   a:	e00a      	b.n	22 <ip_reass_tmr+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:128
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
   c:	7fc3      	ldrb	r3, [r0, #31]
   e:	6804      	ldr	r4, [r0, #0]
  10:	b11b      	cbz	r3, 1a <ip_reass_tmr+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:129
      r->timer--;
  12:	3b01      	subs	r3, #1
  14:	77c3      	strb	r3, [r0, #31]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:132
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  16:	4605      	mov	r5, r0
  18:	e002      	b.n	20 <ip_reass_tmr+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:141
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  1a:	4629      	mov	r1, r5
  1c:	f7ff fffe 	bl	0 <ip_reass_tmr>
  20:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:125
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  22:	2800      	cmp	r0, #0
  24:	d1f2      	bne.n	c <ip_reass_tmr+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:144
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  26:	bd70      	pop	{r4, r5, r6, pc}
  28:	00000000 	.word	0x00000000
Disassembly of section .text.ip_reass:

00000000 <ip_reass>:
ip_reass():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:470
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:482
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
   4:	6844      	ldr	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:470
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
   6:	4680      	mov	r8, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:484
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
   8:	7863      	ldrb	r3, [r4, #1]
   a:	7820      	ldrb	r0, [r4, #0]
   c:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  10:	f7ff fffe 	bl	0 <ntohs>
  14:	f3c0 2003 	ubfx	r0, r0, #8, #4
  18:	2805      	cmp	r0, #5
  1a:	f040 81a9 	bne.w	370 <ip_reass+0x370>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:490
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  1e:	79a3      	ldrb	r3, [r4, #6]
  20:	79e0      	ldrb	r0, [r4, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:495
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  22:	4da1      	ldr	r5, [pc, #644]	(2a8 <ip_reass+0x2a8>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:490
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  24:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  28:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:491
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  2c:	78a3      	ldrb	r3, [r4, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:490
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  2e:	4683      	mov	fp, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:491
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  30:	78e0      	ldrb	r0, [r4, #3]
  32:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  36:	f7ff fffe 	bl	0 <ntohs>
  3a:	7823      	ldrb	r3, [r4, #0]
  3c:	4682      	mov	sl, r0
  3e:	7860      	ldrb	r0, [r4, #1]
  40:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  44:	f7ff fffe 	bl	0 <ntohs>
  48:	4681      	mov	r9, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:494

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  4a:	4640      	mov	r0, r8
  4c:	f7ff fffe 	bl	0 <pbuf_clen>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:495
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  50:	f8b5 35e4 	ldrh.w	r3, [r5, #1508]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:494

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  54:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:495
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  56:	18c3      	adds	r3, r0, r3
  58:	2b0a      	cmp	r3, #10
  5a:	dd0c      	ble.n	76 <ip_reass+0x76>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:497
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  5c:	4620      	mov	r0, r4
  5e:	4631      	mov	r1, r6
  60:	f7ff fffe 	bl	0 <ip_reass>
  64:	2800      	cmp	r0, #0
  66:	f000 8183 	beq.w	370 <ip_reass+0x370>
  6a:	f8b5 35e4 	ldrh.w	r3, [r5, #1508]
  6e:	18f3      	adds	r3, r6, r3
  70:	2b0a      	cmp	r3, #10
  72:	f300 817d 	bgt.w	370 <ip_reass+0x370>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:513
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  76:	4b8c      	ldr	r3, [pc, #560]	(2a8 <ip_reass+0x2a8>)
  78:	f8d3 75e0 	ldr.w	r7, [r3, #1504]
  7c:	2300      	movs	r3, #0
  7e:	9301      	str	r3, [sp, #4]
  80:	e022      	b.n	c8 <ip_reass+0xc8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:517
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  82:	7b62      	ldrb	r2, [r4, #13]
  84:	7b23      	ldrb	r3, [r4, #12]
  86:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  8a:	7ba2      	ldrb	r2, [r4, #14]
  8c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  90:	7be2      	ldrb	r2, [r4, #15]
  92:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  96:	697a      	ldr	r2, [r7, #20]
  98:	429a      	cmp	r2, r3
  9a:	d113      	bne.n	c4 <ip_reass+0xc4>
  9c:	7c62      	ldrb	r2, [r4, #17]
  9e:	7c23      	ldrb	r3, [r4, #16]
  a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  a4:	7ca2      	ldrb	r2, [r4, #18]
  a6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  aa:	7ce2      	ldrb	r2, [r4, #19]
  ac:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  b0:	69ba      	ldr	r2, [r7, #24]
  b2:	429a      	cmp	r2, r3
  b4:	d106      	bne.n	c4 <ip_reass+0xc4>
  b6:	7923      	ldrb	r3, [r4, #4]
  b8:	7962      	ldrb	r2, [r4, #5]
  ba:	89b9      	ldrh	r1, [r7, #12]
  bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  c0:	4299      	cmp	r1, r3
  c2:	d004      	beq.n	ce <ip_reass+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:513
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  c4:	9701      	str	r7, [sp, #4]
  c6:	683f      	ldr	r7, [r7, #0]
  c8:	2f00      	cmp	r7, #0
  ca:	d1da      	bne.n	82 <ip_reass+0x82>
  cc:	e157      	b.n	37e <ip_reass+0x37e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:534
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  ce:	79a3      	ldrb	r3, [r4, #6]
  d0:	79e0      	ldrb	r0, [r4, #7]
  d2:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  d6:	f7ff fffe 	bl	0 <ntohs>
  da:	04c0      	lsls	r0, r0, #19
  dc:	0cc0      	lsrs	r0, r0, #19
  de:	bb40      	cbnz	r0, 132 <ip_reass+0x132>
  e0:	e01b      	b.n	11a <ip_reass+0x11a>
ip_reass_enqueue_new_datagram():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:269
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  e2:	4620      	mov	r0, r4
  e4:	4631      	mov	r1, r6
  e6:	f7ff fffe 	bl	0 <ip_reass>
  ea:	42b0      	cmp	r0, r6
  ec:	f2c0 8140 	blt.w	370 <ip_reass+0x370>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:270
      ipr = memp_malloc(MEMP_REASSDATA);
  f0:	2005      	movs	r0, #5
  f2:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:272
    }
    if (ipr == NULL)
  f6:	4607      	mov	r7, r0
  f8:	2800      	cmp	r0, #0
  fa:	f000 8139 	beq.w	370 <ip_reass+0x370>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:280
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  fe:	2220      	movs	r2, #32
 100:	4638      	mov	r0, r7
 102:	2100      	movs	r1, #0
 104:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:281
  ipr->timer = IP_REASS_MAXAGE;
 108:	2303      	movs	r3, #3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:284

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 10a:	4a67      	ldr	r2, [pc, #412]	(2a8 <ip_reass+0x2a8>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:281
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;
 10c:	77fb      	strb	r3, [r7, #31]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:284

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 10e:	f8d2 35e0 	ldr.w	r3, [r2, #1504]
 112:	603b      	str	r3, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:285
  reassdatagrams = ipr;
 114:	f8c2 75e0 	str.w	r7, [r2, #1504]
 118:	e005      	b.n	126 <ip_reass+0x126>
ip_reass():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:534
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 11a:	89f8      	ldrh	r0, [r7, #14]
 11c:	f7ff fffe 	bl	0 <ntohs>
 120:	04c0      	lsls	r0, r0, #19
 122:	0cc0      	lsrs	r0, r0, #19
 124:	b128      	cbz	r0, 132 <ip_reass+0x132>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:540
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 126:	f107 0008 	add.w	r0, r7, #8	; 0x8
 12a:	4621      	mov	r1, r4
 12c:	2214      	movs	r2, #20
 12e:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:545
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 132:	4a5d      	ldr	r2, [pc, #372]	(2a8 <ip_reass+0x2a8>)
 134:	f8b2 35e4 	ldrh.w	r3, [r2, #1508]
 138:	18f3      	adds	r3, r6, r3
 13a:	f8a2 35e4 	strh.w	r3, [r2, #1508]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:551

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
 13e:	79a3      	ldrb	r3, [r4, #6]
 140:	79e0      	ldrb	r0, [r4, #7]
 142:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 146:	f7ff fffe 	bl	0 <ntohs>
 14a:	f410 5f00 	tst.w	r0, #8192	; 0x2000
 14e:	d10f      	bne.n	170 <ip_reass+0x170>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:552
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 150:	7fbb      	ldrb	r3, [r7, #30]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:553
    ipr->datagram_len = offset + len;
 152:	ea4f 42cb 	mov.w	r2, fp, lsl #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:552
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 156:	f043 0301 	orr.w	r3, r3, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:553
    ipr->datagram_len = offset + len;
 15a:	0cd2      	lsrs	r2, r2, #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:552
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 15c:	77bb      	strb	r3, [r7, #30]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:553
    ipr->datagram_len = offset + len;
 15e:	eb0a 02c2 	add.w	r2, sl, r2, lsl #3
 162:	f3c9 2303 	ubfx	r3, r9, #8, #4
 166:	f06f 0103 	mvn.w	r1, #3	; 0x3
 16a:	fb01 2303 	mla	r3, r1, r3, r2
 16e:	83bb      	strh	r3, [r7, #28]
ip_reass_chain_frag_into_datagram_and_validate():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:333
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 170:	f8d8 5004 	ldr.w	r5, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:334
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 174:	78ab      	ldrb	r3, [r5, #2]
 176:	78e8      	ldrb	r0, [r5, #3]
 178:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 17c:	f7ff fffe 	bl	0 <ntohs>
 180:	782b      	ldrb	r3, [r5, #0]
 182:	4606      	mov	r6, r0
 184:	7868      	ldrb	r0, [r5, #1]
 186:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 18a:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:335
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 18e:	79ab      	ldrb	r3, [r5, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:334
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 190:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:335
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 192:	79e8      	ldrb	r0, [r5, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:345
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
 194:	f3c4 2403 	ubfx	r4, r4, #8, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:335
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 198:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 19c:	f7ff fffe 	bl	0 <ntohs>
 1a0:	04c0      	lsls	r0, r0, #19
 1a2:	0cc0      	lsrs	r0, r0, #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:342
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 1a4:	f8d8 5004 	ldr.w	r5, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:335
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 1a8:	00c0      	lsls	r0, r0, #3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:344
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
 1aa:	0a03      	lsrs	r3, r0, #8
 1ac:	7128      	strb	r0, [r5, #4]
 1ae:	716b      	strb	r3, [r5, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:345
  iprh->end = offset + len;
 1b0:	1980      	adds	r0, r0, r6
 1b2:	f06f 0303 	mvn.w	r3, #3	; 0x3
 1b6:	fb03 0404 	mla	r4, r3, r4, r0
 1ba:	b2a4      	uxth	r4, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:343
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 1bc:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:345
  iprh->start = offset;
  iprh->end = offset + len;
 1be:	71ac      	strb	r4, [r5, #6]
 1c0:	0a24      	lsrs	r4, r4, #8
 1c2:	71ec      	strb	r4, [r5, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:343
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 1c4:	702a      	strb	r2, [r5, #0]
 1c6:	706a      	strb	r2, [r5, #1]
 1c8:	70aa      	strb	r2, [r5, #2]
 1ca:	70ea      	strb	r2, [r5, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:349
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 1cc:	6879      	ldr	r1, [r7, #4]
 1ce:	f04f 0c01 	mov.w	ip, #1	; 0x1
 1d2:	4614      	mov	r4, r2
 1d4:	e04d      	b.n	272 <ip_reass+0x272>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:350
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 1d6:	684e      	ldr	r6, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:351
    if (iprh->start < iprh_tmp->start) {
 1d8:	792a      	ldrb	r2, [r5, #4]
 1da:	796b      	ldrb	r3, [r5, #5]
 1dc:	ea42 2003 	orr.w	r0, r2, r3, lsl #8
 1e0:	7932      	ldrb	r2, [r6, #4]
 1e2:	7973      	ldrb	r3, [r6, #5]
 1e4:	ea42 2e03 	orr.w	lr, r2, r3, lsl #8
 1e8:	4570      	cmp	r0, lr
 1ea:	d227      	bcs.n	23c <ip_reass+0x23c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:353
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 1ec:	f3c1 2307 	ubfx	r3, r1, #8, #8
 1f0:	706b      	strb	r3, [r5, #1]
 1f2:	f3c1 4307 	ubfx	r3, r1, #16, #8
 1f6:	70ab      	strb	r3, [r5, #2]
 1f8:	0e0b      	lsrs	r3, r1, #24
 1fa:	7029      	strb	r1, [r5, #0]
 1fc:	70eb      	strb	r3, [r5, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:354
      if (iprh_prev != NULL) {
 1fe:	2c00      	cmp	r4, #0
 200:	d054      	beq.n	2ac <ip_reass+0x2ac>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:357
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 202:	79a3      	ldrb	r3, [r4, #6]
 204:	79e2      	ldrb	r2, [r4, #7]
 206:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 20a:	4298      	cmp	r0, r3
 20c:	f0c0 8082 	bcc.w	314 <ip_reass+0x314>
 210:	79aa      	ldrb	r2, [r5, #6]
 212:	79e8      	ldrb	r0, [r5, #7]
 214:	7933      	ldrb	r3, [r6, #4]
 216:	7971      	ldrb	r1, [r6, #5]
 218:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 21c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 220:	429a      	cmp	r2, r3
 222:	d877      	bhi.n	314 <ip_reass+0x314>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:362
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 224:	f3c8 2307 	ubfx	r3, r8, #8, #8
 228:	7063      	strb	r3, [r4, #1]
 22a:	f3c8 4307 	ubfx	r3, r8, #16, #8
 22e:	70a3      	strb	r3, [r4, #2]
 230:	ea4f 6318 	mov.w	r3, r8, lsr #24
 234:	f884 8000 	strb.w	r8, [r4]
 238:	70e3      	strb	r3, [r4, #3]
 23a:	e039      	b.n	2b0 <ip_reass+0x2b0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:368
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 23c:	d06a      	beq.n	314 <ip_reass+0x314>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:372
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 23e:	79b3      	ldrb	r3, [r6, #6]
 240:	79f2      	ldrb	r2, [r6, #7]
 242:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 246:	4298      	cmp	r0, r3
 248:	d364      	bcc.n	314 <ip_reass+0x314>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:378
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 24a:	b13c      	cbz	r4, 25c <ip_reass+0x25c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:379
        if (iprh_prev->end != iprh_tmp->start) {
 24c:	79a3      	ldrb	r3, [r4, #6]
 24e:	79e2      	ldrb	r2, [r4, #7]
 250:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 254:	4573      	cmp	r3, lr
 256:	bf18      	it	ne
 258:	f04f 0c00 	movne.w	ip, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:386
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 25c:	7872      	ldrb	r2, [r6, #1]
 25e:	7833      	ldrb	r3, [r6, #0]
 260:	4634      	mov	r4, r6
 262:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 266:	78b2      	ldrb	r2, [r6, #2]
 268:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 26c:	78f2      	ldrb	r2, [r6, #3]
 26e:	ea43 6102 	orr.w	r1, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:349
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 272:	2900      	cmp	r1, #0
 274:	d1af      	bne.n	1d6 <ip_reass+0x1d6>
 276:	e08a      	b.n	38e <ip_reass+0x38e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:398
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 278:	f3c8 2307 	ubfx	r3, r8, #8, #8
 27c:	7063      	strb	r3, [r4, #1]
 27e:	f3c8 4307 	ubfx	r3, r8, #16, #8
 282:	70a3      	strb	r3, [r4, #2]
 284:	ea4f 6318 	mov.w	r3, r8, lsr #24
 288:	f884 8000 	strb.w	r8, [r4]
 28c:	70e3      	strb	r3, [r4, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:399
      if (iprh_prev->end != iprh->start) {
 28e:	79a2      	ldrb	r2, [r4, #6]
 290:	79e0      	ldrb	r0, [r4, #7]
 292:	792b      	ldrb	r3, [r5, #4]
 294:	7969      	ldrb	r1, [r5, #5]
 296:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 29a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 29e:	429a      	cmp	r2, r3
 2a0:	bf18      	it	ne
 2a2:	f04f 0c00 	movne.w	ip, #0	; 0x0
 2a6:	e003      	b.n	a <ip_reass+0xa>
 2a8:	00000000 	.word	0x00000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:408
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 2ac:	f8c7 8004 	str.w	r8, [r7, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:414
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 2b0:	7fbb      	ldrb	r3, [r7, #30]
 2b2:	f013 0f01 	tst.w	r3, #1	; 0x1
 2b6:	d05e      	beq.n	376 <ip_reass+0x376>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:416
    /* and had no wholes so far */
    if (valid) {
 2b8:	f1bc 0f00 	cmp.w	ip, #0	; 0x0
 2bc:	d05b      	beq.n	376 <ip_reass+0x376>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:419
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 2be:	687b      	ldr	r3, [r7, #4]
 2c0:	685b      	ldr	r3, [r3, #4]
 2c2:	791a      	ldrb	r2, [r3, #4]
 2c4:	795b      	ldrb	r3, [r3, #5]
 2c6:	ea52 2303 	orrs.w	r3, r2, r3, lsl #8
 2ca:	d154      	bne.n	376 <ip_reass+0x376>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:424
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
 2cc:	786a      	ldrb	r2, [r5, #1]
 2ce:	782b      	ldrb	r3, [r5, #0]
 2d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 2d4:	78aa      	ldrb	r2, [r5, #2]
 2d6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 2da:	78ea      	ldrb	r2, [r5, #3]
 2dc:	ea43 6602 	orr.w	r6, r3, r2, lsl #24
 2e0:	e015      	b.n	30e <ip_reass+0x30e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:426
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
 2e2:	6874      	ldr	r4, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:427
          if (iprh_prev->end != iprh->start) {
 2e4:	79aa      	ldrb	r2, [r5, #6]
 2e6:	79e8      	ldrb	r0, [r5, #7]
 2e8:	7923      	ldrb	r3, [r4, #4]
 2ea:	7961      	ldrb	r1, [r4, #5]
 2ec:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 2f0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 2f4:	429a      	cmp	r2, r3
 2f6:	d13e      	bne.n	376 <ip_reass+0x376>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:432
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
 2f8:	7862      	ldrb	r2, [r4, #1]
 2fa:	7823      	ldrb	r3, [r4, #0]
 2fc:	4625      	mov	r5, r4
 2fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 302:	78a2      	ldrb	r2, [r4, #2]
 304:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 308:	78e2      	ldrb	r2, [r4, #3]
 30a:	ea43 6602 	orr.w	r6, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:425
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 30e:	2e00      	cmp	r6, #0
 310:	d1e7      	bne.n	2e2 <ip_reass+0x2e2>
 312:	e040      	b.n	396 <ip_reass+0x396>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:456
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 314:	4d35      	ldr	r5, [pc, #212]	(3ec <ip_reass+0x3ec>)
 316:	4640      	mov	r0, r8
 318:	f8b5 45e4 	ldrh.w	r4, [r5, #1508]
 31c:	f7ff fffe 	bl	0 <pbuf_clen>
 320:	1a24      	subs	r4, r4, r0
 322:	f8a5 45e4 	strh.w	r4, [r5, #1508]
 326:	e023      	b.n	370 <ip_reass+0x370>
ip_reass():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:581

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
 328:	686c      	ldr	r4, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:584

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 32a:	4628      	mov	r0, r5
 32c:	f06f 0113 	mvn.w	r1, #19	; 0x13
 330:	f7ff fffe 	bl	0 <pbuf_header>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:585
      pbuf_cat(p, r);
 334:	4629      	mov	r1, r5
 336:	4630      	mov	r0, r6
 338:	f7ff fffe 	bl	0 <pbuf_cat>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:586
      r = iprh->next_pbuf;
 33c:	7862      	ldrb	r2, [r4, #1]
 33e:	7823      	ldrb	r3, [r4, #0]
 340:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 344:	78a2      	ldrb	r2, [r4, #2]
 346:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 34a:	78e2      	ldrb	r2, [r4, #3]
 34c:	ea43 6502 	orr.w	r5, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:580
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 350:	2d00      	cmp	r5, #0
 352:	d1e9      	bne.n	328 <ip_reass+0x328>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:589
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 354:	4638      	mov	r0, r7
 356:	9901      	ldr	r1, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:592

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 358:	4d24      	ldr	r5, [pc, #144]	(3ec <ip_reass+0x3ec>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:589
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 35a:	f7ff fffe 	bl	0 <ip_reass>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:592

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 35e:	4630      	mov	r0, r6
 360:	f8b5 45e4 	ldrh.w	r4, [r5, #1508]
 364:	f7ff fffe 	bl	0 <pbuf_clen>
 368:	1a24      	subs	r4, r4, r0
 36a:	f8a5 45e4 	strh.w	r4, [r5, #1508]
 36e:	e003      	b.n	378 <ip_reass+0x378>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:604
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 370:	4640      	mov	r0, r8
 372:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:605
  return NULL;
 376:	2600      	movs	r6, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:606
}
 378:	4630      	mov	r0, r6
 37a:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
ip_reass_enqueue_new_datagram():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:266
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
 37e:	2005      	movs	r0, #5
 380:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:267
  if (ipr == NULL) {
 384:	4607      	mov	r7, r0
 386:	2800      	cmp	r0, #0
 388:	f47f aeb9 	bne.w	fe <ip_reass+0xfe>
 38c:	e6a9      	b.n	e2 <ip_reass+0xe2>
ip_reass_chain_frag_into_datagram_and_validate():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:392
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
 38e:	2c00      	cmp	r4, #0
 390:	f47f af72 	bne.w	278 <ip_reass+0x278>
 394:	e78a      	b.n	2ac <ip_reass+0x2ac>
ip_reass():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:563
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 396:	8bbb      	ldrh	r3, [r7, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:570
    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 398:	f107 0108 	add.w	r1, r7, #8	; 0x8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:563
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 39c:	3314      	adds	r3, #20
 39e:	83bb      	strh	r3, [r7, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:566

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 3a0:	687b      	ldr	r3, [r7, #4]
 3a2:	685c      	ldr	r4, [r3, #4]
 3a4:	7862      	ldrb	r2, [r4, #1]
 3a6:	7823      	ldrb	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:570

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 3a8:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:566
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 3aa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 3ae:	78a2      	ldrb	r2, [r4, #2]
 3b0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 3b4:	78e2      	ldrb	r2, [r4, #3]
 3b6:	ea43 6502 	orr.w	r5, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:570

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 3ba:	2214      	movs	r2, #20
 3bc:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:571
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 3c0:	8bb8      	ldrh	r0, [r7, #28]
 3c2:	f7ff fffe 	bl	0 <htons>
 3c6:	70a0      	strb	r0, [r4, #2]
 3c8:	f3c0 200f 	ubfx	r0, r0, #8, #16
 3cc:	70e0      	strb	r0, [r4, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:572
    IPH_OFFSET_SET(fraghdr, 0);
 3ce:	71a6      	strb	r6, [r4, #6]
 3d0:	71e6      	strb	r6, [r4, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:573
    IPH_CHKSUM_SET(fraghdr, 0);
 3d2:	72a6      	strb	r6, [r4, #10]
 3d4:	72e6      	strb	r6, [r4, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:575
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 3d6:	4620      	mov	r0, r4
 3d8:	2114      	movs	r1, #20
 3da:	f7ff fffe 	bl	0 <inet_chksum>
 3de:	72a0      	strb	r0, [r4, #10]
 3e0:	f3c0 200f 	ubfx	r0, r0, #8, #16
 3e4:	72e0      	strb	r0, [r4, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip_frag.c:577

    p = ipr->p;
 3e6:	687e      	ldr	r6, [r7, #4]
 3e8:	e7b2      	b.n	350 <ip_reass+0x350>
 3ea:	46c0      	nop			(mov r8, r8)
 3ec:	00000000 	.word	0x00000000
