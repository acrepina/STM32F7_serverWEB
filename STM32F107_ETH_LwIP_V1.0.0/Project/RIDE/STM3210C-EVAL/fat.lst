
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\fat.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\fat.o

Disassembly of section .text.fat_getSectorAddressFatEntry:

00000000 <fat_getSectorAddressFatEntry>:
fat_getSectorAddressFatEntry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:48
*/
euint32 fat_getSectorAddressFatEntry(FileSystem *fs,euint32 cluster_addr)
{ 
	euint32 base = fs->volumeId.ReservedSectorCount,res;
	
	switch(fs->type){
   0:	f890 303c 	ldrb.w	r3, [r0, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:46
 * This works for all FAT types.
 * Return value: Sectornumber, or 0. Warning, no boundary check.
*/
euint32 fat_getSectorAddressFatEntry(FileSystem *fs,euint32 cluster_addr)
{ 
	euint32 base = fs->volumeId.ReservedSectorCount,res;
   4:	8902      	ldrh	r2, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:48
	
	switch(fs->type){
   6:	2b02      	cmp	r3, #2
   8:	d007      	beq.n	1a <fat_getSectorAddressFatEntry+0x1a>
   a:	2b03      	cmp	r3, #3
   c:	d007      	beq.n	1e <fat_getSectorAddressFatEntry+0x1e>
   e:	2b01      	cmp	r3, #1
  10:	d10b      	bne.n	2a <fat_getSectorAddressFatEntry+0x2a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:50
		case FAT12:
			res=(cluster_addr*3/1024);
  12:	2303      	movs	r3, #3
  14:	434b      	muls	r3, r1
  16:	0a99      	lsrs	r1, r3, #10
  18:	e002      	b.n	20 <fat_getSectorAddressFatEntry+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:58
			}else{
				return(base+res);
			}
			//break;
		case FAT16:
			res=cluster_addr/256;
  1a:	0a09      	lsrs	r1, r1, #8
  1c:	e000      	b.n	20 <fat_getSectorAddressFatEntry+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:66
			}else{
				return(base+res);
			}
			//break;
		case FAT32:
			res=cluster_addr/128;
  1e:	09c9      	lsrs	r1, r1, #7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:67
			if(res>=fs->FatSectorCount){
  20:	6a43      	ldr	r3, [r0, #36]
  22:	4299      	cmp	r1, r3
  24:	d201      	bcs.n	2a <fat_getSectorAddressFatEntry+0x2a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:70
				return(0);
			}else{
				return(base+res);
  26:	1888      	adds	r0, r1, r2
  28:	e000      	b.n	2c <fat_getSectorAddressFatEntry+0x2c>
  2a:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:75
			}
			//break; 
	}
	return(0);
}
  2c:	4770      	bx	lr
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_isEocMarker:

00000000 <fat_isEocMarker>:
fat_isEocMarker():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:208
 * noted in fs->type.
 * Return value: Returns 0 when it is the EoC marker, and 1 otherwise.
*/
eint16 fat_isEocMarker(FileSystem *fs,euint32 fat_entry)
{
	switch(fs->type){
   0:	f890 303c 	ldrb.w	r3, [r0, #60]
   4:	2b02      	cmp	r3, #2
   6:	d008      	beq.n	1a <fat_isEocMarker+0x1a>
   8:	2b03      	cmp	r3, #3
   a:	d00d      	beq.n	28 <fat_isEocMarker+0x28>
   c:	2b01      	cmp	r3, #1
   e:	d001      	beq.n	14 <fat_isEocMarker+0x14>
  10:	2001      	movs	r0, #1
  12:	e010      	b.n	36 <fat_isEocMarker+0x36>
  14:	f640 73f7 	movw	r3, #4087	; 0xff7
  18:	e001      	b.n	1e <fat_isEocMarker+0x1e>
  1a:	f64f 73f7 	movw	r3, #65527	; 0xfff7
  1e:	4299      	cmp	r1, r3
  20:	bf94      	ite	ls
  22:	2000      	movls	r0, #0
  24:	2001      	movhi	r0, #1
  26:	e006      	b.n	36 <fat_isEocMarker+0x36>
  28:	4b03      	ldr	r3, [pc, #12]	(38 <fat_isEocMarker+0x38>)
  2a:	f021 4270 	bic.w	r2, r1, #4026531840	; 0xf0000000
  2e:	429a      	cmp	r2, r3
  30:	bf94      	ite	ls
  32:	2000      	movls	r0, #0
  34:	2001      	movhi	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:226
				return(0);
			}
			break;
	}
	return(1);
}
  36:	4770      	bx	lr
  38:	0ffffff7 	.word	0x0ffffff7
Disassembly of section .text.fat_giveEocMarker:

00000000 <fat_giveEocMarker>:
fat_giveEocMarker():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:240
 * touched according to MicroSoft specifications. I didn't care.
 * Return value: The EoC marker cast to an ulong.
*/
euint32 fat_giveEocMarker(FileSystem *fs)
{
	switch(fs->type)
   0:	f890 003c 	ldrb.w	r0, [r0, #60]
   4:	2802      	cmp	r0, #2
   6:	d008      	beq.n	1a <fat_giveEocMarker+0x1a>
   8:	2803      	cmp	r0, #3
   a:	d009      	beq.n	20 <fat_giveEocMarker+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:249
			//break;
		case FAT16:
			return(0xFFFF);
			//break;
		case FAT32:
			return(0x0FFFFFFF);
   c:	f640 73ff 	movw	r3, #4095	; 0xfff
  10:	2801      	cmp	r0, #1
  12:	bf0c      	ite	eq
  14:	4618      	moveq	r0, r3
  16:	2000      	movne	r0, #0
  18:	e004      	b.n	24 <fat_giveEocMarker+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:240
 * touched according to MicroSoft specifications. I didn't care.
 * Return value: The EoC marker cast to an ulong.
*/
euint32 fat_giveEocMarker(FileSystem *fs)
{
	switch(fs->type)
  1a:	f64f 70ff 	movw	r0, #65535	; 0xffff
  1e:	e001      	b.n	24 <fat_giveEocMarker+0x24>
  20:	f06f 4070 	mvn.w	r0, #4026531840	; 0xf0000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:253
		case FAT32:
			return(0x0FFFFFFF);
			//break;
	}
	return(0);
}
  24:	4770      	bx	lr
  26:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_setNextClusterAddressWBuf:

00000000 <fat_setNextClusterAddressWBuf>:
fat_setNextClusterAddressWBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:310
 * not write the data itself, except in the case of FAT 12 cross sector data, where
 * the second sector is handled by this function.
 * Return value:
*/
void fat_setNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr,euint32 next_cluster_addr,euint8* buf)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	461c      	mov	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:314
	euint16 offset;
	euint8 *buf2;
		
	switch(fs->type)
   6:	f890 303c 	ldrb.w	r3, [r0, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:310
 * not write the data itself, except in the case of FAT 12 cross sector data, where
 * the second sector is handled by this function.
 * Return value:
*/
void fat_setNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr,euint32 next_cluster_addr,euint8* buf)
{
   a:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:314
	euint16 offset;
	euint8 *buf2;
		
	switch(fs->type)
   c:	2b02      	cmp	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:310
 * not write the data itself, except in the case of FAT 12 cross sector data, where
 * the second sector is handled by this function.
 * Return value:
*/
void fat_setNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr,euint32 next_cluster_addr,euint8* buf)
{
   e:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:314
	euint16 offset;
	euint8 *buf2;
		
	switch(fs->type)
  10:	d043      	beq.n	9a <fat_setNextClusterAddressWBuf+0x9a>
  12:	2b03      	cmp	r3, #3
  14:	d045      	beq.n	a2 <fat_setNextClusterAddressWBuf+0xa2>
  16:	2b01      	cmp	r3, #1
  18:	d147      	bne.n	aa <fat_setNextClusterAddressWBuf+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:317
	{
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
  1a:	2303      	movs	r3, #3
  1c:	434b      	muls	r3, r1
  1e:	f3c3 0048 	ubfx	r0, r3, #1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:318
			if(offset == 511){
  22:	f240 13ff 	movw	r3, #511	; 0x1ff
  26:	4298      	cmp	r0, r3
  28:	f001 0601 	and.w	r6, r1, #1	; 0x1
  2c:	d120      	bne.n	70 <fat_setNextClusterAddressWBuf+0x70>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:319
				if(cluster_addr%2==0){
  2e:	b916      	cbnz	r6, 36 <fat_setNextClusterAddressWBuf+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:320
					buf[offset]=next_cluster_addr&0xFF;
  30:	f884 21ff 	strb.w	r2, [r4, #511]
  34:	e005      	b.n	42 <fat_setNextClusterAddressWBuf+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:322
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
  36:	5c23      	ldrb	r3, [r4, r0]
  38:	f003 030f 	and.w	r3, r3, #15	; 0xf
  3c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
  40:	5423      	strb	r3, [r4, r0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:324
				}
				buf2=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,cluster_addr)+1,IOM_MODE_READWRITE);
  42:	4638      	mov	r0, r7
  44:	f7ff fffe 	bl	0 <fat_setNextClusterAddressWBuf>
  48:	2202      	movs	r2, #2
  4a:	1c41      	adds	r1, r0, #1
  4c:	6838      	ldr	r0, [r7, #0]
  4e:	f7ff fffe 	bl	0 <part_getSect>
  52:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:325
				if(cluster_addr%2==0){
  54:	b936      	cbnz	r6, 64 <fat_setNextClusterAddressWBuf+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:326
					buf2[0]=(buf2[0]&0xF0)+((next_cluster_addr>>8)&0xF);
  56:	7803      	ldrb	r3, [r0, #0]
  58:	f3c5 2203 	ubfx	r2, r5, #8, #4
  5c:	f023 030f 	bic.w	r3, r3, #15	; 0xf
  60:	189b      	adds	r3, r3, r2
  62:	e000      	b.n	66 <fat_setNextClusterAddressWBuf+0x66>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:328
				}else{
					buf2[0]=(next_cluster_addr>>4)&0xFF;
  64:	092b      	lsrs	r3, r5, #4
  66:	700b      	strb	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:330
				}
				part_relSect(fs->part,buf2);
  68:	6838      	ldr	r0, [r7, #0]
  6a:	f7ff fffe 	bl	0 <part_relSect>
  6e:	e01c      	b.n	aa <part_relSect+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:332
			}else{
				if(cluster_addr%2==0){
  70:	b94e      	cbnz	r6, 86 <part_relSect+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:333
					buf[offset]=next_cluster_addr&0xFF;
  72:	5422      	strb	r2, [r4, r0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:334
					buf[offset+1]=(buf[offset+1]&0xF0)+((next_cluster_addr>>8)&0xF);
  74:	1c43      	adds	r3, r0, #1
  76:	5ce2      	ldrb	r2, [r4, r3]
  78:	f3c5 2103 	ubfx	r1, r5, #8, #4
  7c:	f022 020f 	bic.w	r2, r2, #15	; 0xf
  80:	1852      	adds	r2, r2, r1
  82:	54e2      	strb	r2, [r4, r3]
  84:	e011      	b.n	aa <part_relSect+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:336
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
  86:	5c22      	ldrb	r2, [r4, r0]
  88:	1823      	adds	r3, r4, r0
  8a:	f002 020f 	and.w	r2, r2, #15	; 0xf
  8e:	eb02 1205 	add.w	r2, r2, r5, lsl #4
  92:	5422      	strb	r2, [r4, r0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:337
					buf[offset+1]=(next_cluster_addr>>4)&0xFF;
  94:	092a      	lsrs	r2, r5, #4
  96:	705a      	strb	r2, [r3, #1]
  98:	e007      	b.n	aa <part_relSect+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:343
				}
			}
			break;
		case FAT16:
			offset=cluster_addr%256;
			*((euint16*)buf+offset)=next_cluster_addr;
  9a:	b2cb      	uxtb	r3, r1
  9c:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
  a0:	e003      	b.n	aa <part_relSect+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:347
			break;
		case FAT32:
			offset=cluster_addr%128;
			*((euint32*)buf+offset)=next_cluster_addr;
  a2:	f001 037f 	and.w	r3, r1, #127	; 0x7f
  a6:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:350
			break;
	}
}
  aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  ae:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_getNextClusterAddressWBuf:

00000000 <fat_getNextClusterAddressWBuf>:
fat_getNextClusterAddressWBuf():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:264
 * it's own buffer, it is given as a parameter. (ioman makes this function rather obsolete)
 * Only in the case of a FAT12 crosssector data entry a sector is retrieved here.
 * Return value: The value of the clusterfield is returned.
*/
euint32 fat_getNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr, euint8* buf)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:270
	euint8  *buf2; /* For FAT12 fallover only */
	euint8 hb,lb;
	euint16 offset;
	euint32 nextcluster=0;
	
	switch(fs->type)
   4:	f890 403c 	ldrb.w	r4, [r0, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:264
 * it's own buffer, it is given as a parameter. (ioman makes this function rather obsolete)
 * Only in the case of a FAT12 crosssector data entry a sector is retrieved here.
 * Return value: The value of the clusterfield is returned.
*/
euint32 fat_getNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr, euint8* buf)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:270
	euint8  *buf2; /* For FAT12 fallover only */
	euint8 hb,lb;
	euint16 offset;
	euint32 nextcluster=0;
	
	switch(fs->type)
   a:	2c02      	cmp	r4, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:264
 * it's own buffer, it is given as a parameter. (ioman makes this function rather obsolete)
 * Only in the case of a FAT12 crosssector data entry a sector is retrieved here.
 * Return value: The value of the clusterfield is returned.
*/
euint32 fat_getNextClusterAddressWBuf(FileSystem *fs,euint32 cluster_addr, euint8* buf)
{
   c:	460f      	mov	r7, r1
   e:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:270
	euint8  *buf2; /* For FAT12 fallover only */
	euint8 hb,lb;
	euint16 offset;
	euint32 nextcluster=0;
	
	switch(fs->type)
  10:	d02a      	beq.n	68 <fat_getNextClusterAddressWBuf+0x68>
  12:	2c03      	cmp	r4, #3
  14:	d02c      	beq.n	70 <fat_getNextClusterAddressWBuf+0x70>
  16:	2c01      	cmp	r4, #1
  18:	d001      	beq.n	1e <fat_getNextClusterAddressWBuf+0x1e>
  1a:	2000      	movs	r0, #0
  1c:	e02c      	b.n	78 <fat_getNextClusterAddressWBuf+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:273
	{
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
  1e:	2303      	movs	r3, #3
  20:	434b      	muls	r3, r1
  22:	f3c3 0248 	ubfx	r2, r3, #1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:275
			hb = buf[offset];
			if(offset == 511){
  26:	f240 13ff 	movw	r3, #511	; 0x1ff
  2a:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:274
	
	switch(fs->type)
	{
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
			hb = buf[offset];
  2c:	f815 8002 	ldrb.w	r8, [r5, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:275
			if(offset == 511){
  30:	d10c      	bne.n	1c <fat_getNextClusterAddressWBuf+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:276
				buf2=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,cluster_addr)+1,IOM_MODE_READONLY);
  32:	f7ff fffe 	bl	0 <fat_getNextClusterAddressWBuf>
  36:	4622      	mov	r2, r4
  38:	1c41      	adds	r1, r0, #1
  3a:	6830      	ldr	r0, [r6, #0]
  3c:	f7ff fffe 	bl	0 <part_getSect>
  40:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:277
				lb = buf2[0];
  42:	7804      	ldrb	r4, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:278
				part_relSect(fs->part,buf2);
  44:	6830      	ldr	r0, [r6, #0]
  46:	f7ff fffe 	bl	0 <part_relSect>
  4a:	e001      	b.n	50 <part_relSect+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:280
			}else{
				lb = buf[offset + 1];
  4c:	18ab      	adds	r3, r5, r2
  4e:	785c      	ldrb	r4, [r3, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:282
			}
			if(cluster_addr%2==0){
  50:	f017 0f01 	tst.w	r7, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:283
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
  54:	bf0b      	itete	eq
  56:	f004 030f 	andeq.w	r3, r4, #15	; 0xf
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:285
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
  5a:	ea4f 1318 	movne.w	r3, r8, lsr #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:283
				part_relSect(fs->part,buf2);
			}else{
				lb = buf[offset + 1];
			}
			if(cluster_addr%2==0){
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
  5e:	eb08 2003 	addeq.w	r0, r8, r3, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:285
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
  62:	eb03 1004 	addne.w	r0, r3, r4, lsl #4
  66:	e007      	b.n	78 <part_relSect+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:290
			}
			break;
		case FAT16:
			offset=cluster_addr%256;
			nextcluster = *((euint16*)buf + offset);
  68:	b2cb      	uxtb	r3, r1
  6a:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
  6e:	e003      	b.n	78 <part_relSect+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:294
			break;
		case FAT32:
			offset=cluster_addr%128;
			nextcluster = *((euint32*)buf + offset);
  70:	f001 037f 	and.w	r3, r1, #127	; 0x7f
  74:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:298
			break;
	}
	return(nextcluster);
}
  78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.fat_allocClusterChain:

00000000 <fat_allocClusterChain>:
fat_allocClusterChain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:462
{
	euint32 cc,ncl=num_clusters,lc;
	euint8 *bufa=0,*bufb=0;
	euint8  overflow=0;

	if(Cache->FirstCluster<=1)return(num_clusters);
   0:	68cb      	ldr	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:457
 * number of clusters it *failed* to allocate. 
 * Return value: 0 on success, all other values are the number of clusters it could
 * not allocate.
*/
eint16 fat_allocClusterChain(FileSystem *fs,ClusterChain *Cache,euint32 num_clusters)
{
   2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:462
	euint32 cc,ncl=num_clusters,lc;
	euint8 *bufa=0,*bufb=0;
	euint8  overflow=0;

	if(Cache->FirstCluster<=1)return(num_clusters);
   6:	2b01      	cmp	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:457
 * number of clusters it *failed* to allocate. 
 * Return value: 0 on success, all other values are the number of clusters it could
 * not allocate.
*/
eint16 fat_allocClusterChain(FileSystem *fs,ClusterChain *Cache,euint32 num_clusters)
{
   8:	4605      	mov	r5, r0
   a:	468a      	mov	sl, r1
   c:	4691      	mov	r9, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:462
	euint32 cc,ncl=num_clusters,lc;
	euint8 *bufa=0,*bufb=0;
	euint8  overflow=0;

	if(Cache->FirstCluster<=1)return(num_clusters);
   e:	d801      	bhi.n	14 <fat_allocClusterChain+0x14>
  10:	b290      	uxth	r0, r2
  12:	e084      	b.n	11e <fat_allocClusterChain+0x11e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:464
	
	lc=fs_getLastCluster(fs,Cache);
  14:	f7ff fffe 	bl	0 <fs_getLastCluster>
  18:	2300      	movs	r3, #0
  1a:	4607      	mov	r7, r0
  1c:	4606      	mov	r6, r0
  1e:	46c8      	mov	r8, r9
  20:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:467
	cc=lc;
	
	while(ncl > 0){
  22:	f1b9 0f00 	cmp.w	r9, #0	; 0x0
  26:	d072      	beq.n	10e <fat_allocClusterChain+0x10e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:469
		cc++;
		if(cc>=fs->DataClusterCount+1){
  28:	6a2b      	ldr	r3, [r5, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:468
	
	lc=fs_getLastCluster(fs,Cache);
	cc=lc;
	
	while(ncl > 0){
		cc++;
  2a:	3601      	adds	r6, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:469
		if(cc>=fs->DataClusterCount+1){
  2c:	3301      	adds	r3, #1
  2e:	429e      	cmp	r6, r3
  30:	d326      	bcc.n	80 <fat_allocClusterChain+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:470
			if(overflow){
  32:	9b01      	ldr	r3, [sp, #4]
  34:	b30b      	cbz	r3, 7a <fat_allocClusterChain+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:471
				bufa=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,lc),IOM_MODE_READWRITE);
  36:	4639      	mov	r1, r7
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  3e:	2202      	movs	r2, #2
  40:	4601      	mov	r1, r0
  42:	6828      	ldr	r0, [r5, #0]
  44:	f7ff fffe 	bl	0 <part_getSect>
  48:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:472
				fat_setNextClusterAddressWBuf(fs,lc,fat_giveEocMarker(fs),bufa);
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  50:	4623      	mov	r3, r4
  52:	4602      	mov	r2, r0
  54:	4639      	mov	r1, r7
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <fat_allocClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:473
				Cache->LastCluster=lc;
  5c:	f8ca 7010 	str.w	r7, [sl, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:474
				part_relSect(fs->part,bufa);
  60:	6828      	ldr	r0, [r5, #0]
  62:	4621      	mov	r1, r4
  64:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:475
				fs->FreeClusterCount-=num_clusters-ncl;
  68:	6b6b      	ldr	r3, [r5, #52]
  6a:	ebc9 0303 	rsb	r3, r9, r3
  6e:	4443      	add	r3, r8
  70:	636b      	str	r3, [r5, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:476
				return(num_clusters-ncl);
  72:	ebc8 0309 	rsb	r3, r8, r9
  76:	b298      	uxth	r0, r3
  78:	e051      	b.n	11e <fat_allocClusterChain+0x11e>
  7a:	2301      	movs	r3, #1
  7c:	2602      	movs	r6, #2
  7e:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:481
			}
			cc=2;
			overflow++;
		}
		bufa=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,cc),IOM_MODE_READONLY);
  80:	4631      	mov	r1, r6
  82:	4628      	mov	r0, r5
  84:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  88:	2201      	movs	r2, #1
  8a:	4601      	mov	r1, r0
  8c:	6828      	ldr	r0, [r5, #0]
  8e:	f7ff fffe 	bl	0 <part_getSect>
  92:	4683      	mov	fp, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:482
		if(fat_getNextClusterAddressWBuf(fs,cc,bufa)==0){
  94:	4631      	mov	r1, r6
  96:	4628      	mov	r0, r5
  98:	465a      	mov	r2, fp
  9a:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  9e:	b9b0      	cbnz	r0, ce <fat_allocClusterChain+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:483
			bufb=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,lc),IOM_MODE_READWRITE);
  a0:	4639      	mov	r1, r7
  a2:	4628      	mov	r0, r5
  a4:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  a8:	2202      	movs	r2, #2
  aa:	4601      	mov	r1, r0
  ac:	6828      	ldr	r0, [r5, #0]
  ae:	f7ff fffe 	bl	0 <part_getSect>
  b2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:484
			fat_setNextClusterAddressWBuf(fs,lc,cc,bufb);
  b4:	4639      	mov	r1, r7
  b6:	4628      	mov	r0, r5
  b8:	4632      	mov	r2, r6
  ba:	4623      	mov	r3, r4
  bc:	f7ff fffe 	bl	0 <fat_allocClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:485
			part_relSect(fs->part,bufb);
  c0:	6828      	ldr	r0, [r5, #0]
  c2:	4621      	mov	r1, r4
  c4:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:486
			ncl--;
  c8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
  cc:	4637      	mov	r7, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:489
			lc=cc;
		}
		part_relSect(fs->part,bufa);
  ce:	6828      	ldr	r0, [r5, #0]
  d0:	4659      	mov	r1, fp
  d2:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:490
		if(ncl==0){
  d6:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
  da:	d1a5      	bne.n	28 <fat_allocClusterChain+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:491
			bufa=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,lc),IOM_MODE_READWRITE);
  dc:	4639      	mov	r1, r7
  de:	4628      	mov	r0, r5
  e0:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  e4:	2202      	movs	r2, #2
  e6:	4601      	mov	r1, r0
  e8:	6828      	ldr	r0, [r5, #0]
  ea:	f7ff fffe 	bl	0 <part_getSect>
  ee:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:492
			fat_setNextClusterAddressWBuf(fs,lc,fat_giveEocMarker(fs),bufa);
  f0:	4628      	mov	r0, r5
  f2:	f7ff fffe 	bl	0 <fat_allocClusterChain>
  f6:	4639      	mov	r1, r7
  f8:	4602      	mov	r2, r0
  fa:	4623      	mov	r3, r4
  fc:	4628      	mov	r0, r5
  fe:	f7ff fffe 	bl	0 <fat_allocClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:493
			Cache->LastCluster=lc;
 102:	f8ca 7010 	str.w	r7, [sl, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:494
			part_relSect(fs->part,bufa);
 106:	6828      	ldr	r0, [r5, #0]
 108:	4621      	mov	r1, r4
 10a:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:497
		}
	}
	if(Cache->ClusterCount)Cache->ClusterCount+=num_clusters;
 10e:	f8da 0014 	ldr.w	r0, [sl, #20]
 112:	b120      	cbz	r0, 11e <part_relSect+0x11e>
 114:	eb09 0300 	add.w	r3, r9, r0
 118:	f8ca 3014 	str.w	r3, [sl, #20]
 11c:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:499
	return(0);
}
 11e:	b200      	sxth	r0, r0
 120:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
Disassembly of section .text.fat_getNextClusterChain:

00000000 <fat_getNextClusterChain>:
fat_getNextClusterChain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:368
 * With lineair is meant that logical cluster n+1 should be 1 more than logical cluster n
 * at the disc level.
 * Return value: 0 on success, or -1 when EoC.
*/
esint16 fat_getNextClusterChain(FileSystem *fs, ClusterChain *Cache)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:373
	euint32 sect,lr,nlr,dc;
	esint16 lin=0;
	euint8 *buf;

	if(Cache->DiscCluster==0)
   6:	6889      	ldr	r1, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:368
 * With lineair is meant that logical cluster n+1 should be 1 more than logical cluster n
 * at the disc level.
 * Return value: 0 on success, or -1 when EoC.
*/
esint16 fat_getNextClusterChain(FileSystem *fs, ClusterChain *Cache)
{
   8:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:373
	euint32 sect,lr,nlr,dc;
	esint16 lin=0;
	euint8 *buf;

	if(Cache->DiscCluster==0)
   a:	b1d1      	cbz	r1, 42 <fat_getNextClusterChain+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:378
	{
		return(-1);
	}

	sect=fat_getSectorAddressFatEntry(fs,Cache->DiscCluster);
   c:	f7ff fffe 	bl	0 <fat_getNextClusterChain>
  10:	4681      	mov	r9, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:379
	buf=part_getSect(fs->part,sect,IOM_MODE_READONLY);
  12:	4649      	mov	r1, r9
  14:	2201      	movs	r2, #1
  16:	6838      	ldr	r0, [r7, #0]
  18:	f7ff fffe 	bl	0 <part_getSect>
  1c:	4680      	mov	r8, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:380
	dc=fat_getNextClusterAddressWBuf(fs,Cache->DiscCluster,buf);
  1e:	68b1      	ldr	r1, [r6, #8]
  20:	4642      	mov	r2, r8
  22:	4638      	mov	r0, r7
  24:	f7ff fffe 	bl	0 <fat_getNextClusterChain>
  28:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:381
	if(fat_isEocMarker(fs,dc))
  2a:	4621      	mov	r1, r4
  2c:	4638      	mov	r0, r7
  2e:	f7ff fffe 	bl	0 <fat_getNextClusterChain>
  32:	b280      	uxth	r0, r0
  34:	b140      	cbz	r0, 48 <fat_getNextClusterChain+0x48>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:383
	{
		Cache->LastCluster=Cache->DiscCluster;
  36:	68b3      	ldr	r3, [r6, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:384
		part_relSect(fs->part,buf);
  38:	6838      	ldr	r0, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:383
	sect=fat_getSectorAddressFatEntry(fs,Cache->DiscCluster);
	buf=part_getSect(fs->part,sect,IOM_MODE_READONLY);
	dc=fat_getNextClusterAddressWBuf(fs,Cache->DiscCluster,buf);
	if(fat_isEocMarker(fs,dc))
	{
		Cache->LastCluster=Cache->DiscCluster;
  3a:	6133      	str	r3, [r6, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:384
		part_relSect(fs->part,buf);
  3c:	4641      	mov	r1, r8
  3e:	f7ff fffe 	bl	0 <part_relSect>
  42:	f64f 70ff 	movw	r0, #65535	; 0xffff
  46:	e023      	b.n	90 <fat_getNextClusterChain+0x90>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:389
		return(-1);
	}
	
	Cache->DiscCluster=dc;
	Cache->LogicCluster++;
  48:	6873      	ldr	r3, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:388
		Cache->LastCluster=Cache->DiscCluster;
		part_relSect(fs->part,buf);
		return(-1);
	}
	
	Cache->DiscCluster=dc;
  4a:	60b4      	str	r4, [r6, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:389
	Cache->LogicCluster++;
  4c:	3301      	adds	r3, #1
  4e:	6073      	str	r3, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:391
		
	lr=Cache->DiscCluster-1;
  50:	1e62      	subs	r2, r4, #1
  52:	4605      	mov	r5, r0
  54:	e008      	b.n	68 <fat_getNextClusterChain+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:397
	nlr=lr+1;
	
	while(nlr-1==lr && fat_getSectorAddressFatEntry(fs,nlr)==sect)
	{
		lr=nlr;
		nlr=fat_getNextClusterAddressWBuf(fs,lr,buf);
  56:	4621      	mov	r1, r4
  58:	4642      	mov	r2, r8
  5a:	4638      	mov	r0, r7
  5c:	f7ff fffe 	bl	0 <fat_getNextClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:398
		lin++;	
  60:	1c6b      	adds	r3, r5, #1
  62:	4622      	mov	r2, r4
  64:	b29d      	uxth	r5, r3
  66:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:394
	Cache->LogicCluster++;
		
	lr=Cache->DiscCluster-1;
	nlr=lr+1;
	
	while(nlr-1==lr && fat_getSectorAddressFatEntry(fs,nlr)==sect)
  68:	1e63      	subs	r3, r4, #1
  6a:	4293      	cmp	r3, r2
  6c:	d105      	bne.n	7a <fat_getNextClusterChain+0x7a>
  6e:	4638      	mov	r0, r7
  70:	4621      	mov	r1, r4
  72:	f7ff fffe 	bl	0 <fat_getNextClusterChain>
  76:	4548      	cmp	r0, r9
  78:	d0ed      	beq.n	56 <fat_getNextClusterChain+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:401
		lr=nlr;
		nlr=fat_getNextClusterAddressWBuf(fs,lr,buf);
		lin++;	
	}
	
	Cache->Linear=lin-1<0?0:lin-1;
  7a:	b90d      	cbnz	r5, 80 <fat_getNextClusterChain+0x80>
  7c:	4628      	mov	r0, r5
  7e:	e001      	b.n	84 <fat_getNextClusterChain+0x84>
  80:	1e6b      	subs	r3, r5, #1
  82:	b2d8      	uxtb	r0, r3
  84:	7030      	strb	r0, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:403
	
	part_relSect(fs->part,buf);
  86:	6838      	ldr	r0, [r7, #0]
  88:	4641      	mov	r1, r8
  8a:	f7ff fffe 	bl	0 <part_relSect>
  8e:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:405
	return(0);
}
  90:	b200      	sxth	r0, r0
  92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  96:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_LogicToDiscCluster:

00000000 <fat_LogicToDiscCluster>:
fat_LogicToDiscCluster():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:420
 * scanning the entire chain every time.
 * Return value: 0 on success and -1 on failure (meaning out of bounds).
*/
esint16 fat_LogicToDiscCluster(FileSystem *fs, ClusterChain *Cache,euint32 logiccluster)
{
	if(logiccluster<Cache->LogicCluster || Cache->DiscCluster==0){
   0:	684b      	ldr	r3, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:419
 * It is NOT recommended to go backwards in clusterchains, since this will require
 * scanning the entire chain every time.
 * Return value: 0 on success and -1 on failure (meaning out of bounds).
*/
esint16 fat_LogicToDiscCluster(FileSystem *fs, ClusterChain *Cache,euint32 logiccluster)
{
   2:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:420
	if(logiccluster<Cache->LogicCluster || Cache->DiscCluster==0){
   4:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:419
 * It is NOT recommended to go backwards in clusterchains, since this will require
 * scanning the entire chain every time.
 * Return value: 0 on success and -1 on failure (meaning out of bounds).
*/
esint16 fat_LogicToDiscCluster(FileSystem *fs, ClusterChain *Cache,euint32 logiccluster)
{
   6:	4606      	mov	r6, r0
   8:	460c      	mov	r4, r1
   a:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:420
	if(logiccluster<Cache->LogicCluster || Cache->DiscCluster==0){
   c:	d301      	bcc.n	12 <fat_LogicToDiscCluster+0x12>
   e:	688b      	ldr	r3, [r1, #8]
  10:	b923      	cbnz	r3, 1c <fat_LogicToDiscCluster+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:422
		Cache->LogicCluster=0;
		Cache->DiscCluster=Cache->FirstCluster;
  12:	68e3      	ldr	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:421
 * Return value: 0 on success and -1 on failure (meaning out of bounds).
*/
esint16 fat_LogicToDiscCluster(FileSystem *fs, ClusterChain *Cache,euint32 logiccluster)
{
	if(logiccluster<Cache->LogicCluster || Cache->DiscCluster==0){
		Cache->LogicCluster=0;
  14:	2200      	movs	r2, #0
  16:	6062      	str	r2, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:422
		Cache->DiscCluster=Cache->FirstCluster;
  18:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:423
		Cache->Linear=0;
  1a:	7022      	strb	r2, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:426
	}
	
	if(Cache->LogicCluster==logiccluster){
  1c:	6863      	ldr	r3, [r4, #4]
  1e:	42ab      	cmp	r3, r5
  20:	d113      	bne.n	4a <fat_LogicToDiscCluster+0x4a>
  22:	e015      	b.n	50 <fat_LogicToDiscCluster+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:432
		return(0);
	}
	
	while(Cache->LogicCluster!=logiccluster)
	{
		if(Cache->Linear!=0)
  24:	7823      	ldrb	r3, [r4, #0]
  26:	b13b      	cbz	r3, 38 <fat_LogicToDiscCluster+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:434
		{
			Cache->Linear--;
  28:	3b01      	subs	r3, #1
  2a:	7023      	strb	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:435
			Cache->LogicCluster++;
  2c:	1c53      	adds	r3, r2, #1
  2e:	6063      	str	r3, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:436
			Cache->DiscCluster++;
  30:	68a3      	ldr	r3, [r4, #8]
  32:	3301      	adds	r3, #1
  34:	60a3      	str	r3, [r4, #8]
  36:	e008      	b.n	4a <fat_LogicToDiscCluster+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:440
		}
		else
		{
			if((fat_getNextClusterChain(fs,Cache))!=0){
  38:	4630      	mov	r0, r6
  3a:	4621      	mov	r1, r4
  3c:	f7ff fffe 	bl	0 <fat_LogicToDiscCluster>
  40:	b280      	uxth	r0, r0
  42:	b110      	cbz	r0, 4a <fat_LogicToDiscCluster+0x4a>
  44:	f64f 70ff 	movw	r0, #65535	; 0xffff
  48:	e003      	b.n	52 <fat_LogicToDiscCluster+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:430
	
	if(Cache->LogicCluster==logiccluster){
		return(0);
	}
	
	while(Cache->LogicCluster!=logiccluster)
  4a:	6862      	ldr	r2, [r4, #4]
  4c:	42aa      	cmp	r2, r5
  4e:	d1e9      	bne.n	24 <fat_LogicToDiscCluster+0x24>
  50:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:446
				return(-1);
			}
		}
	}
	return(0);
}
  52:	b200      	sxth	r0, r0
  54:	bd70      	pop	{r4, r5, r6, pc}
  56:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_DiscToLogicCluster:

00000000 <fat_DiscToLogicCluster>:
fat_DiscToLogicCluster():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:543
	
	return(c-1);
}

euint32 fat_DiscToLogicCluster(FileSystem *fs,euint32 firstcluster,euint32 disccluster)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:547
	ClusterChain cache;
	euint32 c=0,r=0;
	
	cache.DiscCluster = cache.LogicCluster = cache.LastCluster = cache.Linear = 0;
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:543
	
	return(c-1);
}

euint32 fat_DiscToLogicCluster(FileSystem *fs,euint32 firstcluster,euint32 disccluster)
{
   4:	b087      	sub	sp, #28
   6:	4616      	mov	r6, r2
   8:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:547
	ClusterChain cache;
	euint32 c=0,r=0;
	
	cache.DiscCluster = cache.LogicCluster = cache.LastCluster = cache.Linear = 0;
   a:	f88d 3000 	strb.w	r3, [sp]
   e:	9304      	str	r3, [sp, #16]
  10:	9301      	str	r3, [sp, #4]
  12:	9302      	str	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:548
	cache.FirstCluster = firstcluster;
  14:	9103      	str	r1, [sp, #12]
  16:	461a      	mov	r2, r3
  18:	461c      	mov	r4, r3
  1a:	e004      	b.n	26 <fat_DiscToLogicCluster+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:551
	
	while(!(fat_LogicToDiscCluster(fs,&cache,c++)) && !r){
		if(cache.DiscCluster == disccluster){
  1c:	9b02      	ldr	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:552
			r = cache.LogicCluster;
  1e:	462a      	mov	r2, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:551
	
	cache.DiscCluster = cache.LogicCluster = cache.LastCluster = cache.Linear = 0;
	cache.FirstCluster = firstcluster;
	
	while(!(fat_LogicToDiscCluster(fs,&cache,c++)) && !r){
		if(cache.DiscCluster == disccluster){
  20:	42b3      	cmp	r3, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:552
			r = cache.LogicCluster;
  22:	bf08      	it	eq
  24:	9c01      	ldreq	r4, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:550
	euint32 c=0,r=0;
	
	cache.DiscCluster = cache.LogicCluster = cache.LastCluster = cache.Linear = 0;
	cache.FirstCluster = firstcluster;
	
	while(!(fat_LogicToDiscCluster(fs,&cache,c++)) && !r){
  26:	4638      	mov	r0, r7
  28:	4669      	mov	r1, sp
  2a:	1c55      	adds	r5, r2, #1
  2c:	f7ff fffe 	bl	0 <fat_DiscToLogicCluster>
  30:	b280      	uxth	r0, r0
  32:	b908      	cbnz	r0, 38 <fat_DiscToLogicCluster+0x38>
  34:	2c00      	cmp	r4, #0
  36:	d0f1      	beq.n	1c <fat_DiscToLogicCluster+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:556
		if(cache.DiscCluster == disccluster){
			r = cache.LogicCluster;
		}
	}
	return(r);
}
  38:	4620      	mov	r0, r4
  3a:	b007      	add	sp, #28
  3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  3e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_countClustersInChain:

00000000 <fat_countClustersInChain>:
fat_countClustersInChain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:528
	fs->FreeClusterCount+=c;	
 	return(0);
}

euint32 fat_countClustersInChain(FileSystem *fs,euint32 firstcluster)
{
   0:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:532
	ClusterChain cache;
	euint32 c=0;
	
	if(firstcluster<=1)return(0);
   2:	2901      	cmp	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:528
	fs->FreeClusterCount+=c;	
 	return(0);
}

euint32 fat_countClustersInChain(FileSystem *fs,euint32 firstcluster)
{
   4:	b087      	sub	sp, #28
   6:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:532
	ClusterChain cache;
	euint32 c=0;
	
	if(firstcluster<=1)return(0);
   8:	d801      	bhi.n	e <fat_countClustersInChain+0xe>
   a:	2000      	movs	r0, #0
   c:	e011      	b.n	32 <fat_countClustersInChain+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:534
	
	cache.DiscCluster = cache.LogicCluster = cache.LastCluster = cache.Linear = 0;
   e:	2300      	movs	r3, #0
  10:	f88d 3000 	strb.w	r3, [sp]
  14:	9304      	str	r3, [sp, #16]
  16:	9301      	str	r3, [sp, #4]
  18:	9302      	str	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:535
	cache.FirstCluster = firstcluster;
  1a:	9103      	str	r1, [sp, #12]
  1c:	461a      	mov	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:537
	
	while(!(fat_LogicToDiscCluster(fs,&cache,c++)));
  1e:	4628      	mov	r0, r5
  20:	4669      	mov	r1, sp
  22:	1c54      	adds	r4, r2, #1
  24:	f7ff fffe 	bl	0 <fat_countClustersInChain>
  28:	b280      	uxth	r0, r0
  2a:	4622      	mov	r2, r4
  2c:	2800      	cmp	r0, #0
  2e:	d0f6      	beq.n	1e <fat_countClustersInChain+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:539
	
	return(c-1);
  30:	1e60      	subs	r0, r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:540
}
  32:	b007      	add	sp, #28
  34:	bd30      	pop	{r4, r5, pc}
  36:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_setNextClusterAddress:

00000000 <fat_setNextClusterAddress>:
fat_setNextClusterAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:143
 * void fat_setNextClusterAddress(FileSystem *fs,unsigned long cluster_addr,unsigned long next_cluster_addr)
 * Description: This function makes an entry in the fattable for cluster_addr. The value it puts there
 * is next_cluster_addr. 
*/
void fat_setNextClusterAddress(FileSystem *fs,euint32 cluster_addr,euint32 next_cluster_addr)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
   6:	4688      	mov	r8, r1
   8:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:148
	euint8 *buf,*buf2; 
	euint16 offset;
	euint32 sector;
	
	sector=fat_getSectorAddressFatEntry(fs,cluster_addr);
   a:	f7ff fffe 	bl	0 <fat_setNextClusterAddress>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:150
	
	if(( fs->FatSectorCount <= (sector - fs->volumeId.ReservedSectorCount )||(sector==0))){
   e:	8933      	ldrh	r3, [r6, #8]
  10:	6a72      	ldr	r2, [r6, #36]
  12:	1ac3      	subs	r3, r0, r3
  14:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:148
{
	euint8 *buf,*buf2; 
	euint16 offset;
	euint32 sector;
	
	sector=fat_getSectorAddressFatEntry(fs,cluster_addr);
  16:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:150
	
	if(( fs->FatSectorCount <= (sector - fs->volumeId.ReservedSectorCount )||(sector==0))){
  18:	d95d      	bls.n	d6 <fat_setNextClusterAddress+0xd6>
  1a:	2800      	cmp	r0, #0
  1c:	d05b      	beq.n	d6 <fat_setNextClusterAddress+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:155
	    //DBG((TXT("HARDERROR:::fat_getNextClusterAddress READ PAST FAT BOUNDARY\n")));
	    return;
	}
	
	buf=part_getSect(fs->part,sector,IOM_MODE_READWRITE);
  1e:	2202      	movs	r2, #2
  20:	6830      	ldr	r0, [r6, #0]
  22:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:157
		
	switch(fs->type){
  26:	f896 303c 	ldrb.w	r3, [r6, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:155
	if(( fs->FatSectorCount <= (sector - fs->volumeId.ReservedSectorCount )||(sector==0))){
	    //DBG((TXT("HARDERROR:::fat_getNextClusterAddress READ PAST FAT BOUNDARY\n")));
	    return;
	}
	
	buf=part_getSect(fs->part,sector,IOM_MODE_READWRITE);
  2a:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:157
		
	switch(fs->type){
  2c:	2b02      	cmp	r3, #2
  2e:	d045      	beq.n	bc <fat_setNextClusterAddress+0xbc>
  30:	2b03      	cmp	r3, #3
  32:	d048      	beq.n	c6 <fat_setNextClusterAddress+0xc6>
  34:	2b01      	cmp	r3, #1
  36:	d14e      	bne.n	d6 <fat_setNextClusterAddress+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:159
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
  38:	2303      	movs	r3, #3
  3a:	fb08 f303 	mul.w	r3, r8, r3
  3e:	f3c3 0148 	ubfx	r1, r3, #1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:160
			if(offset == 511){
  42:	f240 13ff 	movw	r3, #511	; 0x1ff
  46:	4299      	cmp	r1, r3
  48:	f008 0701 	and.w	r7, r8, #1	; 0x1
  4c:	d121      	bne.n	92 <fat_setNextClusterAddress+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:161
				if(cluster_addr%2==0){
  4e:	b917      	cbnz	r7, 56 <fat_setNextClusterAddress+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:162
					buf[offset]=next_cluster_addr&0xFF;
  50:	f880 51ff 	strb.w	r5, [r0, #511]
  54:	e005      	b.n	62 <fat_setNextClusterAddress+0x62>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:164
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
  56:	5c43      	ldrb	r3, [r0, r1]
  58:	f003 030f 	and.w	r3, r3, #15	; 0xf
  5c:	eb03 1305 	add.w	r3, r3, r5, lsl #4
  60:	5443      	strb	r3, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:166
				}
				buf2=part_getSect(fs->part,fat_getSectorAddressFatEntry(fs,cluster_addr)+1,IOM_MODE_READWRITE);
  62:	4641      	mov	r1, r8
  64:	4630      	mov	r0, r6
  66:	f7ff fffe 	bl	0 <fat_setNextClusterAddress>
  6a:	2202      	movs	r2, #2
  6c:	1c41      	adds	r1, r0, #1
  6e:	6830      	ldr	r0, [r6, #0]
  70:	f7ff fffe 	bl	0 <part_getSect>
  74:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:167
				if(cluster_addr%2==0){
  76:	b937      	cbnz	r7, 86 <fat_setNextClusterAddress+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:168
					buf2[0]=(buf2[0]&0xF0)+((next_cluster_addr>>8)&0xF);
  78:	7803      	ldrb	r3, [r0, #0]
  7a:	f3c5 2203 	ubfx	r2, r5, #8, #4
  7e:	f023 030f 	bic.w	r3, r3, #15	; 0xf
  82:	189b      	adds	r3, r3, r2
  84:	e000      	b.n	88 <fat_setNextClusterAddress+0x88>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:170
				}else{
					buf2[0]=(next_cluster_addr>>4)&0xFF;
  86:	092b      	lsrs	r3, r5, #4
  88:	700b      	strb	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:172
				}
				part_relSect(fs->part,buf2);
  8a:	6830      	ldr	r0, [r6, #0]
  8c:	f7ff fffe 	bl	0 <part_relSect>
  90:	e01d      	b.n	ce <fat_setNextClusterAddress+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:174
			}else{
				if(cluster_addr%2==0){
  92:	b94f      	cbnz	r7, a8 <fat_setNextClusterAddress+0xa8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:175
					buf[offset]=next_cluster_addr&0xFF;
  94:	5445      	strb	r5, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:176
					buf[offset+1]=(buf[offset+1]&0xF0)+((next_cluster_addr>>8)&0xF);
  96:	1c4b      	adds	r3, r1, #1
  98:	5cc2      	ldrb	r2, [r0, r3]
  9a:	f3c5 2103 	ubfx	r1, r5, #8, #4
  9e:	f022 020f 	bic.w	r2, r2, #15	; 0xf
  a2:	1852      	adds	r2, r2, r1
  a4:	54c2      	strb	r2, [r0, r3]
  a6:	e012      	b.n	ce <fat_setNextClusterAddress+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:178
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
  a8:	5c42      	ldrb	r2, [r0, r1]
  aa:	1843      	adds	r3, r0, r1
  ac:	f002 020f 	and.w	r2, r2, #15	; 0xf
  b0:	eb02 1205 	add.w	r2, r2, r5, lsl #4
  b4:	5442      	strb	r2, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:179
					buf[offset+1]=(next_cluster_addr>>4)&0xFF;
  b6:	092a      	lsrs	r2, r5, #4
  b8:	705a      	strb	r2, [r3, #1]
  ba:	e008      	b.n	ce <fat_setNextClusterAddress+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:186
			}
			part_relSect(fs->part,buf);
			break;
		case FAT16:
			offset=cluster_addr%256;
			*((euint16*)buf+offset)=next_cluster_addr;
  bc:	fa5f f388 	uxtb.w	r3, r8
  c0:	f820 5013 	strh.w	r5, [r0, r3, lsl #1]
  c4:	e003      	b.n	ce <fat_setNextClusterAddress+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:191
			part_relSect(fs->part,buf);
			break;
		case FAT32:
			offset=cluster_addr%128;
			*((euint32*)buf+offset)=next_cluster_addr;
  c6:	f008 037f 	and.w	r3, r8, #127	; 0x7f
  ca:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:192
			part_relSect(fs->part,buf);
  ce:	6830      	ldr	r0, [r6, #0]
  d0:	4621      	mov	r1, r4
  d2:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:196
			break;
	}
	
}
  d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  da:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_unlinkClusterChain:

00000000 <fat_unlinkClusterChain>:
fat_unlinkClusterChain():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:512
eint16 fat_unlinkClusterChain(FileSystem *fs,ClusterChain *Cache)
{
	euint32 c,tbd=0;
	
	Cache->LogicCluster=0;
	Cache->DiscCluster=Cache->FirstCluster;
   0:	68cb      	ldr	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:511
*/
eint16 fat_unlinkClusterChain(FileSystem *fs,ClusterChain *Cache)
{
	euint32 c,tbd=0;
	
	Cache->LogicCluster=0;
   2:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:508
 * Description: This function removes a clusterchain. Starting at FirstCluster
 * it follows the chain until the end, resetting all values to 0.
 * Return value: 0 on success.
*/
eint16 fat_unlinkClusterChain(FileSystem *fs,ClusterChain *Cache)
{
   4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:511
	euint32 c,tbd=0;
	
	Cache->LogicCluster=0;
   8:	604a      	str	r2, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:508
 * Description: This function removes a clusterchain. Starting at FirstCluster
 * it follows the chain until the end, resetting all values to 0.
 * Return value: 0 on success.
*/
eint16 fat_unlinkClusterChain(FileSystem *fs,ClusterChain *Cache)
{
   a:	4606      	mov	r6, r0
   c:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:512
	euint32 c,tbd=0;
	
	Cache->LogicCluster=0;
	Cache->DiscCluster=Cache->FirstCluster;
   e:	608b      	str	r3, [r1, #8]
  10:	4615      	mov	r5, r2
  12:	e006      	b.n	22 <fat_unlinkClusterChain+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:517
	
	c=0;
	
	while(!fat_LogicToDiscCluster(fs,Cache,c++)){
		if(tbd!=0){
  14:	b11d      	cbz	r5, 1e <fat_unlinkClusterChain+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:518
			fat_setNextClusterAddress(fs,tbd,0);
  16:	4630      	mov	r0, r6
  18:	4629      	mov	r1, r5
  1a:	f7ff fffe 	bl	0 <fat_unlinkClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:520
		}
		tbd=Cache->DiscCluster;
  1e:	68a5      	ldr	r5, [r4, #8]
  20:	463a      	mov	r2, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:516
	Cache->LogicCluster=0;
	Cache->DiscCluster=Cache->FirstCluster;
	
	c=0;
	
	while(!fat_LogicToDiscCluster(fs,Cache,c++)){
  22:	4630      	mov	r0, r6
  24:	4621      	mov	r1, r4
  26:	1c57      	adds	r7, r2, #1
  28:	f7ff fffe 	bl	0 <fat_unlinkClusterChain>
  2c:	b282      	uxth	r2, r0
  2e:	2a00      	cmp	r2, #0
  30:	d0f0      	beq.n	14 <fat_unlinkClusterChain+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:522
		if(tbd!=0){
			fat_setNextClusterAddress(fs,tbd,0);
		}
		tbd=Cache->DiscCluster;
	}
	fat_setNextClusterAddress(fs,Cache->DiscCluster,0);
  32:	4630      	mov	r0, r6
  34:	68a1      	ldr	r1, [r4, #8]
  36:	2200      	movs	r2, #0
  38:	f7ff fffe 	bl	0 <fat_unlinkClusterChain>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:523
	fs->FreeClusterCount+=c;	
  3c:	6b73      	ldr	r3, [r6, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:525
 	return(0);
}
  3e:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:523
			fat_setNextClusterAddress(fs,tbd,0);
		}
		tbd=Cache->DiscCluster;
	}
	fat_setNextClusterAddress(fs,Cache->DiscCluster,0);
	fs->FreeClusterCount+=c;	
  40:	19db      	adds	r3, r3, r7
  42:	6373      	str	r3, [r6, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:525
 	return(0);
}
  44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.fat_getNextClusterAddress:

00000000 <fat_getNextClusterAddress>:
fat_getNextClusterAddress():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:87
 * for cluster_addr. It then fetches and (if required) calculates it's value.
 * This value is the EoC marker -or- the number of the next cluster in the chain.
 * Return value: Clusternumber or EoC
*/
euint32 fat_getNextClusterAddress(FileSystem *fs,euint32 cluster_addr,euint16 *linear)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
   6:	460f      	mov	r7, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:94
	euint8 hb,lb;
	euint16 offset;
	euint32 sector;
	euint32 nextcluster=0;
	
	sector=fat_getSectorAddressFatEntry(fs,cluster_addr);
   8:	f7ff fffe 	bl	0 <fat_getNextClusterAddress>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:95
	if( (fs->FatSectorCount <= (sector-fs->volumeId.ReservedSectorCount)) || sector==0 )
   c:	892b      	ldrh	r3, [r5, #8]
   e:	6a6a      	ldr	r2, [r5, #36]
  10:	1ac3      	subs	r3, r0, r3
  12:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:94
	euint8 hb,lb;
	euint16 offset;
	euint32 sector;
	euint32 nextcluster=0;
	
	sector=fat_getSectorAddressFatEntry(fs,cluster_addr);
  14:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:95
	if( (fs->FatSectorCount <= (sector-fs->volumeId.ReservedSectorCount)) || sector==0 )
  16:	d940      	bls.n	9a <fat_getNextClusterAddress+0x9a>
  18:	2800      	cmp	r0, #0
  1a:	d03e      	beq.n	9a <fat_getNextClusterAddress+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:100
	{
		return(0);
	}
	
	buf=part_getSect(fs->part,sector,IOM_MODE_READONLY);
  1c:	4631      	mov	r1, r6
  1e:	2201      	movs	r2, #1
  20:	6828      	ldr	r0, [r5, #0]
  22:	f7ff fffe 	bl	0 <part_getSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:102
		
	switch(fs->type)
  26:	f895 403c 	ldrb.w	r4, [r5, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:100
	if( (fs->FatSectorCount <= (sector-fs->volumeId.ReservedSectorCount)) || sector==0 )
	{
		return(0);
	}
	
	buf=part_getSect(fs->part,sector,IOM_MODE_READONLY);
  2a:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:102
		
	switch(fs->type)
  2c:	2c02      	cmp	r4, #2
  2e:	d028      	beq.n	82 <fat_getNextClusterAddress+0x82>
  30:	2c03      	cmp	r4, #3
  32:	d02a      	beq.n	8a <fat_getNextClusterAddress+0x8a>
  34:	2c01      	cmp	r4, #1
  36:	d001      	beq.n	3c <fat_getNextClusterAddress+0x3c>
  38:	2400      	movs	r4, #0
  3a:	e02a      	b.n	92 <fat_getNextClusterAddress+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:105
	{
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
  3c:	2303      	movs	r3, #3
  3e:	437b      	muls	r3, r7
  40:	f3c3 0248 	ubfx	r2, r3, #1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:107
			hb = buf[offset];
			if(offset == 511){
  44:	f240 13ff 	movw	r3, #511	; 0x1ff
  48:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:106
		
	switch(fs->type)
	{
		case FAT12:
			offset = ((cluster_addr%1024)*3/2)%512;
			hb = buf[offset];
  4a:	f810 8002 	ldrb.w	r8, [r0, r2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:107
			if(offset == 511){
  4e:	d10a      	bne.n	66 <fat_getNextClusterAddress+0x66>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:108
				part_relSect(fs->part,buf);
  50:	6828      	ldr	r0, [r5, #0]
  52:	f7ff fffe 	bl	0 <part_relSect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:109
				buf=part_getSect(fs->part,sector+1,IOM_MODE_READONLY);
  56:	1c71      	adds	r1, r6, #1
  58:	6828      	ldr	r0, [r5, #0]
  5a:	4622      	mov	r2, r4
  5c:	f7ff fffe 	bl	0 <part_getSect>
  60:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:110
				lb = buf[0];
  62:	7800      	ldrb	r0, [r0, #0]
  64:	e001      	b.n	6a <fat_getNextClusterAddress+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:112
			}else{
				lb = buf[offset + 1];
  66:	1883      	adds	r3, r0, r2
  68:	7858      	ldrb	r0, [r3, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:114
			}
			if(cluster_addr%2==0){
  6a:	f017 0f01 	tst.w	r7, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:115
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
  6e:	bf0b      	itete	eq
  70:	f000 030f 	andeq.w	r3, r0, #15	; 0xf
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:117
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
  74:	ea4f 1318 	movne.w	r3, r8, lsr #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:115
				lb = buf[0];
			}else{
				lb = buf[offset + 1];
			}
			if(cluster_addr%2==0){
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
  78:	eb08 2403 	addeq.w	r4, r8, r3, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:117
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
  7c:	eb03 1400 	addne.w	r4, r3, r0, lsl #4
  80:	e007      	b.n	92 <fat_getNextClusterAddress+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:122
			}
			break;
		case FAT16:
			offset=cluster_addr%256;
			nextcluster = *((euint16 *)buf + offset);
  82:	b2fb      	uxtb	r3, r7
  84:	f830 4013 	ldrh.w	r4, [r0, r3, lsl #1]
  88:	e003      	b.n	92 <fat_getNextClusterAddress+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:126
			break;
		case FAT32:
			offset=cluster_addr%128;
			nextcluster = *((euint32 *)buf + offset);
  8a:	f007 037f 	and.w	r3, r7, #127	; 0x7f
  8e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:130
			break;
	}
	
	part_relSect(fs->part,buf);
  92:	6828      	ldr	r0, [r5, #0]
  94:	f7ff fffe 	bl	0 <part_relSect>
  98:	e000      	b.n	9c <part_relSect+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:132
	
	return(nextcluster);
  9a:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:133
}
  9c:	4620      	mov	r0, r4
  9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  a2:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.fat_countFreeClusters:

00000000 <fat_countFreeClusters>:
fat_countFreeClusters():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:559
	}
	return(r);
}

euint32 fat_countFreeClusters(FileSystem *fs)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
   4:	2402      	movs	r4, #2
   6:	2500      	movs	r5, #0
   8:	e007      	b.n	1a <fat_countFreeClusters+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:563
	euint32 c=2,fc=0;
	
	while(c<=fs->DataClusterCount+1){
		if(fat_getNextClusterAddress(fs,c,0)==0)fc++;
   a:	4630      	mov	r0, r6
   c:	4621      	mov	r1, r4
   e:	2200      	movs	r2, #0
  10:	f7ff fffe 	bl	0 <fat_countFreeClusters>
  14:	b900      	cbnz	r0, 18 <fat_countFreeClusters+0x18>
  16:	3501      	adds	r5, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:564
		c++;
  18:	3401      	adds	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:562

euint32 fat_countFreeClusters(FileSystem *fs)
{
	euint32 c=2,fc=0;
	
	while(c<=fs->DataClusterCount+1){
  1a:	6a33      	ldr	r3, [r6, #32]
  1c:	3301      	adds	r3, #1
  1e:	429c      	cmp	r4, r3
  20:	d9f3      	bls.n	a <fat_countFreeClusters+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source/fat.c:567
		if(fat_getNextClusterAddress(fs,c,0)==0)fc++;
		c++;
	}
	return(fc);
}
  22:	4628      	mov	r0, r5
  24:	bd70      	pop	{r4, r5, r6, pc}
  26:	46c0      	nop			(mov r8, r8)
