
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\netif.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\netif.o

Disassembly of section .text.netif_find:

00000000 <netif_find>:
netif_find():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:234
netif_find(char *name)
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
   0:	4601      	mov	r1, r0
   2:	b900      	cbnz	r0, 6 <netif_find+0x6>
   4:	e019      	b.n	3a <netif_find+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:238
    return NULL;
  }

  num = name[2] - '0';
   6:	7883      	ldrb	r3, [r0, #2]
   8:	3b30      	subs	r3, #48
   a:	fa5f fc83 	uxtb.w	ip, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:240

  for(netif = netif_list; netif != NULL; netif = netif->next) {
   e:	4b0b      	ldr	r3, [pc, #44]	(3c <netif_find+0x3c>)
  10:	6818      	ldr	r0, [r3, #0]
  12:	e010      	b.n	36 <netif_find+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:241
    if (num == netif->num &&
  14:	f890 3031 	ldrb.w	r3, [r0, #49]
  18:	4563      	cmp	r3, ip
  1a:	d10b      	bne.n	34 <netif_find+0x34>
  1c:	f991 2000 	ldrsb.w	r2, [r1]
  20:	f990 302f 	ldrsb.w	r3, [r0, #47]
  24:	429a      	cmp	r2, r3
  26:	d105      	bne.n	34 <netif_find+0x34>
  28:	f991 2001 	ldrsb.w	r2, [r1, #1]
  2c:	f990 3030 	ldrsb.w	r3, [r0, #48]
  30:	429a      	cmp	r2, r3
  32:	d002      	beq.n	3a <netif_find+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:240
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  34:	6800      	ldr	r0, [r0, #0]
  36:	2800      	cmp	r0, #0
  38:	d1ec      	bne.n	14 <netif_find+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:250
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  3a:	4770      	bx	lr
  3c:	00000000 	.word	0x00000000
Disassembly of section .text.netif_set_gw:

00000000 <netif_set_gw>:
netif_set_gw():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:324
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:325
  ip_addr_set(&(netif->gw), gw);
   4:	b901      	cbnz	r1, c <netif_set_gw+0xc>
   6:	e009      	b.n	20 <netifnum.1896+0x20>
   8:	784a      	ldrb	r2, [r1, #1]
   a:	780b      	ldrb	r3, [r1, #0]
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	788a      	ldrb	r2, [r1, #2]
  12:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  16:	78ca      	ldrb	r2, [r1, #3]
  18:	ea43 6102 	orr.w	r1, r3, r2, lsl #24
  1c:	60e1      	str	r1, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:332
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.netif_set_netmask:

00000000 <netif_set_netmask>:
netif_set_netmask():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:345
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:348
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
   4:	b901      	cbnz	r1, c <netif_set_netmask+0xc>
   6:	e009      	b.n	20 <netifnum.1896+0x20>
   8:	784a      	ldrb	r2, [r1, #1]
   a:	780b      	ldrb	r3, [r1, #0]
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	788a      	ldrb	r2, [r1, #2]
  12:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  16:	78ca      	ldrb	r2, [r1, #3]
  18:	ea43 6102 	orr.w	r1, r3, r2, lsl #24
  1c:	60a1      	str	r1, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:356
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.netif_set_default:

00000000 <netif_set_default>:
netif_set_default():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:377
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
   0:	4b01      	ldr	r3, [pc, #4]	(8 <netif_set_default+0x8>)
   2:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:380
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	00000000 	.word	0x00000000
Disassembly of section .text.netif_remove:

00000000 <netif_remove>:
netif_remove():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:185
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:186
  if ( netif == NULL ) return;
   2:	4601      	mov	r1, r0
   4:	b1b8      	cbz	r0, 36 <netif_remove+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:198
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
   6:	480c      	ldr	r0, [pc, #48]	(38 <netif_remove+0x38>)
   8:	6802      	ldr	r2, [r0, #0]
   a:	428a      	cmp	r2, r1
   c:	d109      	bne.n	22 <netif_remove+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:199
    netif_list = netif->next;
   e:	680b      	ldr	r3, [r1, #0]
  10:	6003      	str	r3, [r0, #0]
  12:	e009      	b.n	28 <netif_remove+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:206
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  14:	6813      	ldr	r3, [r2, #0]
  16:	428b      	cmp	r3, r1
  18:	d102      	bne.n	20 <netif_remove+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:207
        tmpNetif->next = netif->next;
  1a:	680b      	ldr	r3, [r1, #0]
  1c:	6013      	str	r3, [r2, #0]
  1e:	e003      	b.n	28 <netif_remove+0x28>
  20:	461a      	mov	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:205
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  22:	2a00      	cmp	r2, #0
  24:	d1f6      	bne.n	14 <netif_remove+0x14>
  26:	e006      	b.n	36 <netif_remove+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:216
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  28:	4b04      	ldr	r3, [pc, #16]	(3c <netif_remove+0x3c>)
  2a:	681b      	ldr	r3, [r3, #0]
  2c:	428b      	cmp	r3, r1
  2e:	d102      	bne.n	36 <netif_remove+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:218
    /* reset default netif */
    netif_set_default(NULL);
  30:	2000      	movs	r0, #0
  32:	f7ff fffe 	bl	0 <netif_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:220
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  36:	bd10      	pop	{r4, pc}
	...
Disassembly of section .text.netif_set_down:

00000000 <netif_set_down>:
netif_set_down():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:423
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if ( netif->flags & NETIF_FLAG_UP )
   0:	f890 302e 	ldrb.w	r3, [r0, #46]
   4:	f013 0f01 	tst.w	r3, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:425
    {
      netif->flags &= ~NETIF_FLAG_UP;
   8:	bf1c      	itt	ne
   a:	f023 0301 	bicne.w	r3, r3, #1	; 0x1
   e:	f880 302e 	strbne.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:433
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  12:	4770      	bx	lr
Disassembly of section .text.netif_is_up:

00000000 <netif_is_up>:
netif_is_up():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:439

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
   0:	f890 002e 	ldrb.w	r0, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:441
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
   4:	f000 0001 	and.w	r0, r0, #1	; 0x1
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.netif_set_up:

00000000 <netif_set_up>:
netif_set_up():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:392
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:393
  if ( !(netif->flags & NETIF_FLAG_UP )) {
   2:	f890 302e 	ldrb.w	r3, [r0, #46]
   6:	f013 0f01 	tst.w	r3, #1	; 0x1
   a:	d109      	bne.n	20 <netif_set_up+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:394
    netif->flags |= NETIF_FLAG_UP;
   c:	f043 0301 	orr.w	r3, r3, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:405
    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  10:	f013 0f20 	tst.w	r3, #32	; 0x20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:394
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if ( !(netif->flags & NETIF_FLAG_UP )) {
    netif->flags |= NETIF_FLAG_UP;
  14:	f880 302e 	strb.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:405
    NETIF_LINK_CALLBACK(netif);
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  18:	d002      	beq.n	20 <netif_set_up+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:406
      etharp_gratuitous(netif);
  1a:	1d01      	adds	r1, r0, #4
  1c:	f7ff fffe 	bl	0 <etharp_request>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:411
    }
#endif /* LWIP_ARP */
    
  }
}
  20:	bd10      	pop	{r4, pc}
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.netif_set_ipaddr:

00000000 <netif_set_ipaddr>:
netif_set_ipaddr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:263
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:271
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
   2:	784a      	ldrb	r2, [r1, #1]
   4:	780b      	ldrb	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:263
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
   6:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:271
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
   8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   c:	788a      	ldrb	r2, [r1, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:263
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
   e:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:271
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  10:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  14:	78ca      	ldrb	r2, [r1, #3]
  16:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  1a:	6842      	ldr	r2, [r0, #4]
  1c:	4293      	cmp	r3, r2
  1e:	d023      	beq.n	68 <netif_set_ipaddr+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:275
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  20:	4b17      	ldr	r3, [pc, #92]	(80 <netif_set_ipaddr+0x80>)
  22:	6818      	ldr	r0, [r3, #0]
  24:	e008      	b.n	38 <netif_set_ipaddr+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:278
    while (pcb != NULL) {
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  26:	6802      	ldr	r2, [r0, #0]
  28:	6873      	ldr	r3, [r6, #4]
  2a:	68c5      	ldr	r5, [r0, #12]
  2c:	429a      	cmp	r2, r3
  2e:	d102      	bne.n	36 <netif_set_ipaddr+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:282
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  30:	2101      	movs	r1, #1
  32:	f7ff fffe 	bl	0 <tcp_abandon>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:285
        pcb = next;
      } else {
        pcb = pcb->next;
  36:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:276
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  38:	2800      	cmp	r0, #0
  3a:	d1f4      	bne.n	26 <netif_set_ipaddr+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:288
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  3c:	4b11      	ldr	r3, [pc, #68]	(84 <netif_set_ipaddr+0x84>)
  3e:	6819      	ldr	r1, [r3, #0]
  40:	e010      	b.n	64 <netif_set_ipaddr+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:290
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  42:	680a      	ldr	r2, [r1, #0]
  44:	b16a      	cbz	r2, 62 <netif_set_ipaddr+0x62>
  46:	6873      	ldr	r3, [r6, #4]
  48:	429a      	cmp	r2, r3
  4a:	d10a      	bne.n	62 <netif_set_ipaddr+0x62>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:294
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  4c:	7862      	ldrb	r2, [r4, #1]
  4e:	7823      	ldrb	r3, [r4, #0]
  50:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  54:	78a2      	ldrb	r2, [r4, #2]
  56:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  5a:	78e2      	ldrb	r2, [r4, #3]
  5c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  60:	600b      	str	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:288
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  62:	68c9      	ldr	r1, [r1, #12]
  64:	2900      	cmp	r1, #0
  66:	d1ec      	bne.n	42 <netif_set_ipaddr+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:302
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  68:	7862      	ldrb	r2, [r4, #1]
  6a:	7823      	ldrb	r3, [r4, #0]
  6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  70:	78a2      	ldrb	r2, [r4, #2]
  72:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  76:	78e2      	ldrb	r2, [r4, #3]
  78:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  7c:	6073      	str	r3, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:312
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  7e:	bd70      	pop	{r4, r5, r6, pc}
	...
Disassembly of section .text.netif_set_addr:

00000000 <netif_set_addr>:
netif_set_addr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:173
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
   6:	461e      	mov	r6, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:174
  netif_set_ipaddr(netif, ipaddr);
   8:	f7ff fffe 	bl	0 <netif_set_addr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:175
  netif_set_netmask(netif, netmask);
   c:	4620      	mov	r0, r4
   e:	4629      	mov	r1, r5
  10:	f7ff fffe 	bl	0 <netif_set_addr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:176
  netif_set_gw(netif, gw);
  14:	4620      	mov	r0, r4
  16:	4631      	mov	r1, r6
  18:	f7ff fffe 	bl	0 <netif_set_addr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:177
}
  1c:	bd70      	pop	{r4, r5, r6, pc}
  1e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.netif_add:

00000000 <netif_add>:
netif_add():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:90
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:94
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
   4:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:97
  netif->netmask.addr = 0;
  netif->gw.addr = 0;
  netif->flags = 0;
   6:	f880 702e 	strb.w	r7, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:121
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
   a:	9c06      	ldr	r4, [sp, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:122
  netif->num = netifnum++;
   c:	4d0f      	ldr	r5, [pc, #60]	(4c <netif_add+0x4c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:94
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
   e:	6047      	str	r7, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:95
  netif->netmask.addr = 0;
  10:	6087      	str	r7, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:96
  netif->gw.addr = 0;
  12:	60c7      	str	r7, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:100
  netif->flags = 0;
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  14:	6207      	str	r7, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:121
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  16:	61c4      	str	r4, [r0, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:122
  netif->num = netifnum++;
  18:	782c      	ldrb	r4, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:90
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  1a:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:122
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netifnum++;
  1c:	f880 4031 	strb.w	r4, [r0, #49]
  20:	3401      	adds	r4, #1
  22:	702c      	strb	r4, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:123
  netif->input = input;
  24:	9c08      	ldr	r4, [sp, #32]
  26:	6104      	str	r4, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:131
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  28:	f7ff fffe 	bl	0 <netif_add>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:134

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  2c:	4630      	mov	r0, r6
  2e:	9b07      	ldr	r3, [sp, #28]
  30:	4798      	blx	r3
  32:	f010 0fff 	tst.w	r0, #255	; 0xff
  36:	d001      	beq.n	3c <netif_add+0x3c>
  38:	463e      	mov	r6, r7
  3a:	e003      	b.n	44 <netif_add+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:139
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  3c:	4a04      	ldr	r2, [pc, #16]	(50 <netif_add+0x50>)
  3e:	6813      	ldr	r3, [r2, #0]
  40:	6033      	str	r3, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:140
  netif_list = netif;
  42:	6016      	str	r6, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/netif.c:159
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  44:	4630      	mov	r0, r6
  46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4a:	46c0      	nop			(mov r8, r8)
	...
