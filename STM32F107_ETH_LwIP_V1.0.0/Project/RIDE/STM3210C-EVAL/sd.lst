
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\sd.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\sd.o

Disassembly of section .text.sd_Resp8bError:

00000000 <sd_Resp8bError>:
sd_Resp8bError():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:155
			break;
		default:
			//DBG((TXT("Unknown error 0x%x (see SanDisk docs p5-13).\n"),value));
			break;
	}
}
   0:	4770      	bx	lr
   2:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.sd_Resp8b:

00000000 <sd_Resp8b>:
sd_Resp8b():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:100
	if_spiSend(iface,0xff); /* eat empty command - response */
}
/*****************************************************************************/

euint8 sd_Resp8b(hwInterface *iface)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:106
	euint8 i;
	euint8 resp;
	
	/* Respone will come after 1 - 8 pings */
	for(i=0;i<8;i++){
		resp = if_spiSend(iface,0xff);
   6:	21ff      	movs	r1, #255
   8:	4628      	mov	r0, r5
   a:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:107
		if(resp != 0xff)
   e:	28ff      	cmp	r0, #255
  10:	d103      	bne.n	1a <if_spiSend+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:105
{
	euint8 i;
	euint8 resp;
	
	/* Respone will come after 1 - 8 pings */
	for(i=0;i<8;i++){
  12:	1c63      	adds	r3, r4, #1
  14:	b2dc      	uxtb	r4, r3
  16:	2c08      	cmp	r4, #8
  18:	d1f5      	bne.n	6 <if_spiSend+0x6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:112
		if(resp != 0xff)
			return(resp);
	}
		
	return(resp);
}
  1a:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.sd_Resp16b:

00000000 <sd_Resp16b>:
sd_Resp16b():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:116
/*****************************************************************************/

euint16 sd_Resp16b(hwInterface *iface)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:119
	euint16 resp;
	
	resp = ( sd_Resp8b(iface) << 8 ) & 0xff00;
   4:	f7ff fffe 	bl	0 <sd_Resp16b>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:120
	resp |= if_spiSend(iface,0xff);
   8:	21ff      	movs	r1, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:119

euint16 sd_Resp16b(hwInterface *iface)
{
	euint16 resp;
	
	resp = ( sd_Resp8b(iface) << 8 ) & 0xff00;
   a:	0204      	lsls	r4, r0, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:120
	resp |= if_spiSend(iface,0xff);
   c:	4628      	mov	r0, r5
   e:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:119

euint16 sd_Resp16b(hwInterface *iface)
{
	euint16 resp;
	
	resp = ( sd_Resp8b(iface) << 8 ) & 0xff00;
  12:	b2a4      	uxth	r4, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:120
	resp |= if_spiSend(iface,0xff);
  14:	4304      	orrs	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:123
	
	return(resp);
}
  16:	b2a0      	uxth	r0, r4
  18:	bd70      	pop	{r4, r5, r6, pc}
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.sd_Command:

00000000 <sd_Command>:
sd_Command():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:84
	return(0);
}
/*****************************************************************************/

void sd_Command(hwInterface *iface,euint8 cmd, euint16 paramx, euint16 paramy)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   6:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:85
	if_spiSend(iface,0xff);
   8:	21ff      	movs	r1, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:84
	return(0);
}
/*****************************************************************************/

void sd_Command(hwInterface *iface,euint8 cmd, euint16 paramx, euint16 paramy)
{
   a:	4616      	mov	r6, r2
   c:	4698      	mov	r8, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:85
	if_spiSend(iface,0xff);
   e:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:87

	if_spiSend(iface,0x40 | cmd);
  12:	f045 0140 	orr.w	r1, r5, #64	; 0x40
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:88
	if_spiSend(iface,(euint8) (paramx >> 8)); /* MSB of parameter x */
  1c:	0a31      	lsrs	r1, r6, #8
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:89
	if_spiSend(iface,(euint8) (paramx)); /* LSB of parameter x */
  24:	b2f1      	uxtb	r1, r6
  26:	4620      	mov	r0, r4
  28:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:90
	if_spiSend(iface,(euint8) (paramy >> 8)); /* MSB of parameter y */
  2c:	ea4f 2118 	mov.w	r1, r8, lsr #8
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:91
	if_spiSend(iface,(euint8) (paramy)); /* LSB of parameter y */
  36:	fa5f f188 	uxtb.w	r1, r8
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:93
															               
	if_spiSend(iface,0x95); /* Checksum (should be only valid for first command (0) */
  40:	2195      	movs	r1, #149
  42:	4620      	mov	r0, r4
  44:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:95

	if_spiSend(iface,0xff); /* eat empty command - response */
  48:	4620      	mov	r0, r4
  4a:	21ff      	movs	r1, #255
  4c:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:96
}
  50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
Disassembly of section .text.sd_State:

00000000 <sd_State>:
sd_State():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:162

esint8 sd_State(hwInterface *iface)
{
	eint16 value;
	
	sd_Command(iface,13, 0, 0);
   0:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:159
	}
}
/*****************************************************************************/

esint8 sd_State(hwInterface *iface)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:162
	eint16 value;
	
	sd_Command(iface,13, 0, 0);
   4:	210d      	movs	r1, #13
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:159
	}
}
/*****************************************************************************/

esint8 sd_State(hwInterface *iface)
{
   6:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:162
	eint16 value;
	
	sd_Command(iface,13, 0, 0);
   8:	4613      	mov	r3, r2
   a:	f7ff fffe 	bl	0 <sd_State>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:163
	value=sd_Resp16b(iface);
   e:	4620      	mov	r0, r4
  10:	f7ff fffe 	bl	0 <sd_State>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:165

	switch(value)
  14:	b200      	sxth	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:202
			else
				//DBG((TXT("Unknown error: 0x%x (see SanDisk docs p5-14).\n"),value));
			break;
	}
	return(-1);
}
  16:	2800      	cmp	r0, #0
  18:	bf14      	ite	ne
  1a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  1e:	2001      	moveq	r0, #1
  20:	bd10      	pop	{r4, pc}
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.sd_Init:

00000000 <sd_Init>:
sd_Init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:40
/*****************************************************************************/
#include "interface/sd.h"
/*****************************************************************************/

esint8 sd_Init(hwInterface *iface)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	2464      	movs	r4, #100
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:47
	euint8 resp;
	
	/* Try to send reset command up to 100 times */
	i=100;
	do{
		sd_Command(iface,0, 0, 0);
   6:	2100      	movs	r1, #0
   8:	4628      	mov	r0, r5
   a:	460a      	mov	r2, r1
   c:	460b      	mov	r3, r1
   e:	f7ff fffe 	bl	0 <sd_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:48
		resp=sd_Resp8b(iface);
  12:	4628      	mov	r0, r5
  14:	f7ff fffe 	bl	0 <sd_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:50
	}
	while(resp!=1 && i--);
  18:	2801      	cmp	r0, #1
  1a:	d008      	beq.n	2e <sd_Init+0x2e>
  1c:	b114      	cbz	r4, 24 <sd_Init+0x24>
  1e:	1e63      	subs	r3, r4, #1
  20:	b29c      	uxth	r4, r3
  22:	e7f0      	b.n	6 <sd_Init+0x6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:53
	
	if(resp!=1){
		if(resp==0xff){
  24:	28ff      	cmp	r0, #255
  26:	bf0c      	ite	eq
  28:	20ff      	moveq	r0, #255
  2a:	20fe      	movne	r0, #254
  2c:	e012      	b.n	54 <sd_Init+0x54>
  2e:	f44f 44fa 	mov.w	r4, #32000	; 0x7d00
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:66

	/* Wait till card is ready initialising (returns 0 on CMD1) */
	/* Try up to 32000 times. */
	i=32000;
	do{
		sd_Command(iface,1, 0, 0);
  32:	2200      	movs	r2, #0
  34:	2101      	movs	r1, #1
  36:	4628      	mov	r0, r5
  38:	4613      	mov	r3, r2
  3a:	f7ff fffe 	bl	0 <sd_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:68
		
		resp=sd_Resp8b(iface);
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <sd_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:72
		if(resp!=0)
			sd_Resp8bError(iface,resp);
	}
	while(resp==1 && i--);
  44:	2801      	cmp	r0, #1
  46:	d103      	bne.n	50 <sd_Init+0x50>
  48:	b11c      	cbz	r4, 52 <sd_Init+0x52>
  4a:	1e63      	subs	r3, r4, #1
  4c:	b29c      	uxth	r4, r3
  4e:	e7f0      	b.n	32 <sd_Init+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:74
	
	if(resp!=0){
  50:	b100      	cbz	r0, 54 <sd_Init+0x54>
  52:	20fd      	movs	r0, #253
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:80
		sd_Resp8bError(iface,resp);
		return(-3);
	}
	
	return(0);
}
  54:	b240      	sxtb	r0, r0
  56:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.sd_getDriveSize:

00000000 <sd_getDriveSize>:
sd_getDriveSize():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:304
/* ****************************************************************************
 calculates size of card from CSD 
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
esint8 sd_getDriveSize(hwInterface *iface, euint32* drive_size )
{
   0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:309
	euint8 cardresp, i, by;
	euint8 iob[16];
	euint16 c_size, c_size_mult, read_bl_len;
	
	sd_Command(iface, CMDREADCSD, 0, 0);
   2:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:304
/* ****************************************************************************
 calculates size of card from CSD 
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
esint8 sd_getDriveSize(hwInterface *iface, euint32* drive_size )
{
   4:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:309
	euint8 cardresp, i, by;
	euint8 iob[16];
	euint16 c_size, c_size_mult, read_bl_len;
	
	sd_Command(iface, CMDREADCSD, 0, 0);
   6:	4613      	mov	r3, r2
   8:	2109      	movs	r1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:304
/* ****************************************************************************
 calculates size of card from CSD 
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
esint8 sd_getDriveSize(hwInterface *iface, euint32* drive_size )
{
   a:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:309
	euint8 cardresp, i, by;
	euint8 iob[16];
	euint16 c_size, c_size_mult, read_bl_len;
	
	sd_Command(iface, CMDREADCSD, 0, 0);
   c:	f7ff fffe 	bl	0 <sd_getDriveSize>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:312
	
	do {
		cardresp = sd_Resp8b(iface);
  10:	4628      	mov	r0, r5
  12:	f7ff fffe 	bl	0 <sd_getDriveSize>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:313
	} while ( cardresp != 0xFE );
  16:	28fe      	cmp	r0, #254
  18:	d1fa      	bne.n	10 <sd_getDriveSize+0x10>
  1a:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:317

	//DBG((TXT("CSD:")));
	for( i=0; i<16; i++) {
		iob[i] = sd_Resp8b(iface);
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <sd_getDriveSize>
  22:	f80d 0004 	strb.w	r0, [sp, r4]
  26:	3401      	adds	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:316
	do {
		cardresp = sd_Resp8b(iface);
	} while ( cardresp != 0xFE );

	//DBG((TXT("CSD:")));
	for( i=0; i<16; i++) {
  28:	2c10      	cmp	r4, #16
  2a:	d1f7      	bne.n	1c <sd_getDriveSize+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:322
		iob[i] = sd_Resp8b(iface);
		//DBG((TXT(" %02x"), iob[i]));
	}
	//DBG((TXT("\n")));

	if_spiSend(iface,0xff);
  2c:	21ff      	movs	r1, #255
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:323
	if_spiSend(iface,0xff);
  34:	21ff      	movs	r1, #255
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:327
	
	c_size = iob[6] & 0x03; // bits 1..0
	c_size <<= 10;
	c_size += (euint16)iob[7]<<2;
  3c:	f89d 3007 	ldrb.w	r3, [sp, #7]
  40:	f89d 1008 	ldrb.w	r1, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:325
	//DBG((TXT("\n")));

	if_spiSend(iface,0xff);
	if_spiSend(iface,0xff);
	
	c_size = iob[6] & 0x03; // bits 1..0
  44:	f89d 2006 	ldrb.w	r2, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:327
	c_size <<= 10;
	c_size += (euint16)iob[7]<<2;
  48:	009b      	lsls	r3, r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:325
	//DBG((TXT("\n")));

	if_spiSend(iface,0xff);
	if_spiSend(iface,0xff);
	
	c_size = iob[6] & 0x03; // bits 1..0
  4a:	f002 0203 	and.w	r2, r2, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:327
	c_size <<= 10;
	c_size += (euint16)iob[7]<<2;
  4e:	eb03 1391 	add.w	r3, r3, r1, lsr #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:341
	by += iob[10] >> 7;
	
	c_size_mult = 1;
	c_size_mult <<= (2+by);
	
	*drive_size = (euint32)(c_size+1) * (euint32)c_size_mult * (euint32)read_bl_len;
  52:	eb03 2382 	add.w	r3, r3, r2, lsl #10
  56:	f89d 2005 	ldrb.w	r2, [sp, #5]
  5a:	2101      	movs	r1, #1
  5c:	f002 020f 	and.w	r2, r2, #15	; 0xf
  60:	fa11 f202 	lsls.w	r2, r1, r2
  64:	3301      	adds	r3, #1
  66:	b292      	uxth	r2, r2
  68:	435a      	muls	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:334

	by= iob[5] & 0x0F;
	read_bl_len = 1;
	read_bl_len <<= by;

	by=iob[9] & 0x03;
  6a:	f89d 0009 	ldrb.w	r0, [sp, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:341
	by += iob[10] >> 7;
	
	c_size_mult = 1;
	c_size_mult <<= (2+by);
	
	*drive_size = (euint32)(c_size+1) * (euint32)c_size_mult * (euint32)read_bl_len;
  6e:	f89d 300a 	ldrb.w	r3, [sp, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:334

	by= iob[5] & 0x0F;
	read_bl_len = 1;
	read_bl_len <<= by;

	by=iob[9] & 0x03;
  72:	f000 0003 	and.w	r0, r0, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:341
	by += iob[10] >> 7;
	
	c_size_mult = 1;
	c_size_mult <<= (2+by);
	
	*drive_size = (euint32)(c_size+1) * (euint32)c_size_mult * (euint32)read_bl_len;
  76:	09db      	lsrs	r3, r3, #7
  78:	eb03 0340 	add.w	r3, r3, r0, lsl #1
  7c:	3302      	adds	r3, #2
  7e:	4099      	lsls	r1, r3
  80:	b289      	uxth	r1, r1
  82:	4351      	muls	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:344
	
	return 0;
}
  84:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:341
	by += iob[10] >> 7;
	
	c_size_mult = 1;
	c_size_mult <<= (2+by);
	
	*drive_size = (euint32)(c_size+1) * (euint32)c_size_mult * (euint32)read_bl_len;
  86:	6031      	str	r1, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:344
	
	return 0;
}
  88:	b004      	add	sp, #16
  8a:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.sd_readSector:

00000000 <sd_readSector>:
sd_readSector():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:261
 * 		DATA
 * 		CHKS (2B)
 */

esint8 sd_readSector(hwInterface *iface,euint32 address, euint8* buf, euint16 len)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	461f      	mov	r7, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:270
	euint16 fb_timeout=0xffff;
	euint32 i;
	euint32 place;

	/*DBG((TXT("sd_readSector::Trying to read sector %u and store it at %p.\n"),address,&buf[0]));*/
	place=512*address;
   6:	024b      	lsls	r3, r1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:261
 * 		DATA
 * 		CHKS (2B)
 */

esint8 sd_readSector(hwInterface *iface,euint32 address, euint8* buf, euint16 len)
{
   8:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:271
	euint32 i;
	euint32 place;

	/*DBG((TXT("sd_readSector::Trying to read sector %u and store it at %p.\n"),address,&buf[0]));*/
	place=512*address;
	sd_Command(iface,CMDREAD, (euint16) (place >> 16), (euint16) place);
   a:	2111      	movs	r1, #17
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:261
 * 		DATA
 * 		CHKS (2B)
 */

esint8 sd_readSector(hwInterface *iface,euint32 address, euint8* buf, euint16 len)
{
   c:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:271
	euint32 i;
	euint32 place;

	/*DBG((TXT("sd_readSector::Trying to read sector %u and store it at %p.\n"),address,&buf[0]));*/
	place=512*address;
	sd_Command(iface,CMDREAD, (euint16) (place >> 16), (euint16) place);
   e:	0c1a      	lsrs	r2, r3, #16
  10:	f403 437e 	and.w	r3, r3, #65024	; 0xfe00
  14:	f7ff fffe 	bl	0 <sd_readSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:273
	
	cardresp=sd_Resp8b(iface); /* Card response */ 
  18:	4628      	mov	r0, r5
  1a:	f7ff fffe 	bl	0 <sd_readSector>
  1e:	f64f 74ff 	movw	r4, #65535	; 0xffff
  22:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:277

	/* Wait for startblock */
	do
		firstblock=sd_Resp8b(iface); 
  24:	4628      	mov	r0, r5
  26:	f7ff fffe 	bl	0 <sd_readSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:278
	while(firstblock==0xff && fb_timeout--);
  2a:	28ff      	cmp	r0, #255
  2c:	d103      	bne.n	36 <sd_readSector+0x36>
  2e:	b114      	cbz	r4, 36 <sd_readSector+0x36>
  30:	1e63      	subs	r3, r4, #1
  32:	b29c      	uxth	r4, r3
  34:	e7f6      	b.n	24 <sd_readSector+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:280

	if(cardresp!=0x00 || firstblock!=0xfe){
  36:	b9c6      	cbnz	r6, 6a <sd_readSector+0x6a>
  38:	28fe      	cmp	r0, #254
  3a:	d116      	bne.n	6a <sd_readSector+0x6a>
  3c:	4634      	mov	r4, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:286
		sd_Resp8bError(iface,firstblock);
		return(-1);
	}
	
	for(i=0;i<512;i++){
		c = if_spiSend(iface,0xff);
  3e:	21ff      	movs	r1, #255
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:287
		if(i<len)
  46:	42bc      	cmp	r4, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:288
			buf[i] = c;
  48:	bf38      	it	cc
  4a:	f808 0004 	strbcc.w	r0, [r8, r4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:285
	if(cardresp!=0x00 || firstblock!=0xfe){
		sd_Resp8bError(iface,firstblock);
		return(-1);
	}
	
	for(i=0;i<512;i++){
  4e:	3401      	adds	r4, #1
  50:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  54:	d1f3      	bne.n	3e <sd_readSector+0x3e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:292
		if(i<len)
			buf[i] = c;
	}

	/* Checksum (2 byte) - ignore for now */
	if_spiSend(iface,0xff);
  56:	21ff      	movs	r1, #255
  58:	4628      	mov	r0, r5
  5a:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:293
	if_spiSend(iface,0xff);
  5e:	4628      	mov	r0, r5
  60:	21ff      	movs	r1, #255
  62:	f7ff fffe 	bl	0 <if_spiSend>
  66:	2000      	movs	r0, #0
  68:	e000      	b.n	6c <if_spiSend+0x6c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:295

	return(0);
  6a:	20ff      	movs	r0, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:296
}
  6c:	b240      	sxtb	r0, r0
  6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  72:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.sd_writeSector:

00000000 <sd_writeSector>:
sd_writeSector():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:225
	euint32 place;
	euint16 i;
	euint16 t=0;
	
	/*DBG((TXT("Trying to write %u to sector %u.\n"),(void *)&buf,address));*/
	place=512*address;
   0:	024b      	lsls	r3, r1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:219
 *      CHKS (2B)
 * BUSY...
 */

esint8 sd_writeSector(hwInterface *iface,euint32 address, euint8* buf)
{
   2:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:226
	euint16 i;
	euint16 t=0;
	
	/*DBG((TXT("Trying to write %u to sector %u.\n"),(void *)&buf,address));*/
	place=512*address;
	sd_Command(iface,CMDWRITE, (euint16) (place >> 16), (euint16) place);
   4:	2118      	movs	r1, #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:219
 *      CHKS (2B)
 * BUSY...
 */

esint8 sd_writeSector(hwInterface *iface,euint32 address, euint8* buf)
{
   6:	4605      	mov	r5, r0
   8:	4616      	mov	r6, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:226
	euint16 i;
	euint16 t=0;
	
	/*DBG((TXT("Trying to write %u to sector %u.\n"),(void *)&buf,address));*/
	place=512*address;
	sd_Command(iface,CMDWRITE, (euint16) (place >> 16), (euint16) place);
   a:	0c1a      	lsrs	r2, r3, #16
   c:	f403 437e 	and.w	r3, r3, #65024	; 0xfe00
  10:	f7ff fffe 	bl	0 <sd_writeSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:228

	sd_Resp8b(iface); /* Card response */
  14:	4628      	mov	r0, r5
  16:	f7ff fffe 	bl	0 <sd_writeSector>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:230

	if_spiSend(iface,0xfe); /* Start block */
  1a:	4628      	mov	r0, r5
  1c:	21fe      	movs	r1, #254
  1e:	f7ff fffe 	bl	0 <if_spiSend>
  22:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:232
	for(i=0;i<512;i++) 
		if_spiSend(iface,buf[i]); /* Send data */
  24:	5d31      	ldrb	r1, [r6, r4]
  26:	4628      	mov	r0, r5
  28:	3401      	adds	r4, #1
  2a:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:231
	sd_Command(iface,CMDWRITE, (euint16) (place >> 16), (euint16) place);

	sd_Resp8b(iface); /* Card response */

	if_spiSend(iface,0xfe); /* Start block */
	for(i=0;i<512;i++) 
  2e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  32:	d1f7      	bne.n	24 <sd_writeSector+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:233
		if_spiSend(iface,buf[i]); /* Send data */
	if_spiSend(iface,0xff); /* Checksum part 1 */
  34:	21ff      	movs	r1, #255
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:234
	if_spiSend(iface,0xff); /* Checksum part 2 */
  3c:	21ff      	movs	r1, #255
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:236

	if_spiSend(iface,0xff);
  44:	4628      	mov	r0, r5
  46:	21ff      	movs	r1, #255
  48:	f7ff fffe 	bl	0 <if_spiSend>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:238

	while(if_spiSend(iface,0xff)!=0xff){
  4c:	21ff      	movs	r1, #255
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <if_spiSend>
  54:	28ff      	cmp	r0, #255
  56:	d1f9      	bne.n	4c <if_spiSend+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\efsl\source\interface/sd.c:245
		/* Removed NOP */
	}
	/*DBG((TXT("Nopp'ed %u times.\n"),t));*/

	return(0);
}
  58:	2000      	movs	r0, #0
  5a:	bd70      	pop	{r4, r5, r6, pc}
