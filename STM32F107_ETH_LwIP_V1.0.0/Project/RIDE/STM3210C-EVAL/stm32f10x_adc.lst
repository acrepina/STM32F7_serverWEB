
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32f10x_adc.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32f10x_adc.o

Disassembly of section .text.ADC_Init:

00000000 <ADC_Init>:
ADC_Init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:232
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:238
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
   2:	680a      	ldr	r2, [r1, #0]
   4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
   8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   c:	4313      	orrs	r3, r2
   e:	790a      	ldrb	r2, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:218
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *   the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
  10:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:238
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
  12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:240
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
  16:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  18:	68cb      	ldr	r3, [r1, #12]
  1a:	688a      	ldr	r2, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:244
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  1c:	6884      	ldr	r4, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:251
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  1e:	431a      	orrs	r2, r3
  20:	4b08      	ldr	r3, [pc, #32]	(44 <ADC_Init+0x44>)
  22:	ea04 0303 	and.w	r3, r4, r3
  26:	431a      	orrs	r2, r3
  28:	794b      	ldrb	r3, [r1, #5]
  2a:	ea42 0243 	orr.w	r2, r2, r3, lsl #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:254
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  2e:	6082      	str	r2, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:264
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
  30:	7c0b      	ldrb	r3, [r1, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:258
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  32:	6ac2      	ldr	r2, [r0, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:264
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
  34:	3b01      	subs	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:260

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  36:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:264
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
  3a:	b2db      	uxtb	r3, r3
  3c:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:266
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
  40:	62c2      	str	r2, [r0, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:267
}
  42:	bd10      	pop	{r4, pc}
  44:	fff1f7fd 	.word	0xfff1f7fd
Disassembly of section .text.ADC_StructInit:

00000000 <ADC_StructInit>:
ADC_StructInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:278
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
   0:	2300      	movs	r3, #0
   2:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:280
  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   4:	7103      	strb	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:282
  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   6:	7143      	strb	r3, [r0, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:284
  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   8:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:286
  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   a:	60c3      	str	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:288
  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
   c:	3301      	adds	r3, #1
   e:	7403      	strb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:289
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_Cmd:

00000000 <ADC_Cmd>:
ADC_Cmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:303
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_Cmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:306
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f043 0301 	orr.w	r3, r3, #1	; 0x1
   8:	e002      	b.n	10 <ADC_Cmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:311
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f023 0301 	bic.w	r3, r3, #1	; 0x1
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:313
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_DMACmd:

00000000 <ADC_DMACmd>:
ADC_DMACmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:328
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DMACmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:331
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   8:	e002      	b.n	10 <ADC_DMACmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:336
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:338
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_ITConfig:

00000000 <ADC_ITConfig>:
ADC_ITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:360
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
   0:	b2c9      	uxtb	r1, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:361
  if (NewState != DISABLE)
   2:	b11a      	cbz	r2, c <ADC_ITConfig+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:364
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
   4:	6843      	ldr	r3, [r0, #4]
   6:	ea41 0303 	orr.w	r3, r1, r3
   a:	e002      	b.n	12 <ADC_ITConfig+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:369
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
   c:	6843      	ldr	r3, [r0, #4]
   e:	ea23 0301 	bic.w	r3, r3, r1
  12:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:371
  }
}
  14:	4770      	bx	lr
  16:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_ResetCalibration:

00000000 <ADC_ResetCalibration>:
ADC_ResetCalibration():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:383
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0308 	orr.w	r3, r3, #8	; 0x8
   6:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:384
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_GetResetCalibrationStatus:

00000000 <ADC_GetResetCalibrationStatus>:
ADC_GetResetCalibrationStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:397
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:409
    /* RSTCAL bit is reset */
    bitstatus = RESET;
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
}
   2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   6:	4770      	bx	lr
Disassembly of section .text.ADC_StartCalibration:

00000000 <ADC_StartCalibration>:
ADC_StartCalibration():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:421
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0304 	orr.w	r3, r3, #4	; 0x4
   6:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:422
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_GetCalibrationStatus:

00000000 <ADC_GetCalibrationStatus>:
ADC_GetCalibrationStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:435
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:447
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
   2:	f3c0 0080 	ubfx	r0, r0, #2, #1
   6:	4770      	bx	lr
Disassembly of section .text.ADC_SoftwareStartConvCmd:

00000000 <ADC_SoftwareStartConvCmd>:
ADC_SoftwareStartConvCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:461
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartConvCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:465
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
   8:	e002      	b.n	10 <ADC_SoftwareStartConvCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:471
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:473
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_GetSoftwareStartConvStatus:

00000000 <ADC_GetSoftwareStartConvStatus>:
ADC_GetSoftwareStartConvStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:486
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:498
    /* SWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the SWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5080 	ubfx	r0, r0, #22, #1
   6:	4770      	bx	lr
Disassembly of section .text.ADC_DiscModeChannelCountConfig:

00000000 <ADC_DiscModeChannelCountConfig>:
ADC_DiscModeChannelCountConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:516
  uint32_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:521
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
   2:	3901      	subs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:518
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
   4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:521
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
   8:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:523
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
   c:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:524
}
   e:	4770      	bx	lr
Disassembly of section .text.ADC_DiscModeCmd:

00000000 <ADC_DiscModeCmd>:
ADC_DiscModeCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:540
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DiscModeCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:543
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= CR1_DISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   8:	e002      	b.n	10 <ADC_DiscModeCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:548
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= CR1_DISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  10:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:550
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_RegularChannelConfig:

00000000 <ADC_RegularChannelConfig>:
ADC_RegularChannelConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:598
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:590
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
   2:	b530      	push	{r4, r5, lr}
   4:	4694      	mov	ip, r2
   6:	460c      	mov	r4, r1
   8:	461d      	mov	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:598
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   a:	d90c      	bls.n	26 <ADC_RegularChannelConfig+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:603
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
   c:	2203      	movs	r2, #3
   e:	4362      	muls	r2, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:605
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  10:	2307      	movs	r3, #7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:603
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
  12:	3a1e      	subs	r2, #30
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:605
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  14:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:609
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  16:	fa15 f202 	lsls.w	r2, r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:601
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  1a:	68c1      	ldr	r1, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:605
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  1c:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:609
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  20:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:611
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  22:	60c1      	str	r1, [r0, #12]
  24:	e00a      	b.n	3c <ADC_RegularChannelConfig+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:618
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  26:	2203      	movs	r2, #3
  28:	4362      	muls	r2, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:620
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  2a:	2307      	movs	r3, #7
  2c:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:624
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  2e:	fa15 f202 	lsls.w	r2, r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:616
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  32:	6901      	ldr	r1, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:620
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  34:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:624
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  38:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:626
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  3a:	6101      	str	r1, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:629
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  3c:	f1bc 0f06 	cmp.w	ip, #6	; 0x6
  40:	d80d      	bhi.n	5e <ADC_RegularChannelConfig+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:634
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
  42:	2205      	movs	r2, #5
  44:	fb02 f20c 	mul.w	r2, r2, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:636
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  48:	231f      	movs	r3, #31
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:634
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
  4a:	3a05      	subs	r2, #5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:636
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  4c:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:640
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  4e:	fa14 f202 	lsls.w	r2, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:632
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
  52:	6b41      	ldr	r1, [r0, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:636
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  54:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:640
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  58:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:642
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  5a:	6341      	str	r1, [r0, #52]
  5c:	e01d      	b.n	9a <ADC_RegularChannelConfig+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:645
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  5e:	f1bc 0f0c 	cmp.w	ip, #12	; 0xc
  62:	d80d      	bhi.n	80 <ADC_RegularChannelConfig+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:650
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
  64:	2205      	movs	r2, #5
  66:	fb02 f20c 	mul.w	r2, r2, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:652
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  6a:	231f      	movs	r3, #31
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:650
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
  6c:	3a23      	subs	r2, #35
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:652
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  6e:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:656
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  70:	fa14 f202 	lsls.w	r2, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:648
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
  74:	6b01      	ldr	r1, [r0, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:652
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  76:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:656
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  7a:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:658
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
  7c:	6301      	str	r1, [r0, #48]
  7e:	e00c      	b.n	9a <ADC_RegularChannelConfig+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:666
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
  80:	2205      	movs	r2, #5
  82:	fb02 f20c 	mul.w	r2, r2, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:668
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  86:	231f      	movs	r3, #31
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:666
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
  88:	3a41      	subs	r2, #65
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:668
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  8a:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:672
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  8c:	fa14 f202 	lsls.w	r2, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:664
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
  90:	6ac1      	ldr	r1, [r0, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:668
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  92:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:672
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  96:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:674
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  98:	62c1      	str	r1, [r0, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:676
  }
}
  9a:	bd30      	pop	{r4, r5, pc}
Disassembly of section .text.ADC_ExternalTrigConvCmd:

00000000 <ADC_ExternalTrigConvCmd>:
ADC_ExternalTrigConvCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:690
void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigConvCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:693
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8:	e002      	b.n	10 <ADC_ExternalTrigConvCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:698
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:700
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_GetConversionValue:

00000000 <ADC_GetConversionValue>:
ADC_GetConversionValue():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:712
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
   0:	6cc0      	ldr	r0, [r0, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:713
}
   2:	b280      	uxth	r0, r0
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_GetDualModeConversionValue:

00000000 <ADC_GetDualModeConversionValue>:
ADC_GetDualModeConversionValue():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:722
  * @retval The Data conversion value.
  */
uint32_t ADC_GetDualModeConversionValue(void)
{
  /* Return the dual mode conversion value */
  return (*(__IO uint32_t *) DR_ADDRESS);
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ADC_GetDualModeConversionValue+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:723
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	4001244c 	.word	0x4001244c
Disassembly of section .text.ADC_AutoInjectedConvCmd:

00000000 <ADC_AutoInjectedConvCmd>:
ADC_AutoInjectedConvCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:738
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_AutoInjectedConvCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:741
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= CR1_JAUTO_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   8:	e002      	b.n	10 <ADC_AutoInjectedConvCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:746
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= CR1_JAUTO_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  10:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:748
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_InjectedDiscModeCmd:

00000000 <ADC_InjectedDiscModeCmd>:
ADC_InjectedDiscModeCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:764
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_InjectedDiscModeCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:767
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= CR1_JDISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   8:	e002      	b.n	10 <ADC_InjectedDiscModeCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:772
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= CR1_JDISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  10:	6043      	str	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:774
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_ExternalTrigInjectedConvConfig:

00000000 <ADC_ExternalTrigInjectedConvConfig>:
ADC_ExternalTrigInjectedConvConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:805
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
   0:	6883      	ldr	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:807
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_Reset;
   2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:809
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
   6:	4319      	orrs	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:811
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
   8:	6081      	str	r1, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:812
}
   a:	4770      	bx	lr
Disassembly of section .text.ADC_ExternalTrigInjectedConvCmd:

00000000 <ADC_ExternalTrigInjectedConvCmd>:
ADC_ExternalTrigInjectedConvCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:828
void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigInjectedConvCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:831
  {
    /* Enable the selected ADC external event selection for injected group */
    ADCx->CR2 |= CR2_JEXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8:	e002      	b.n	10 <ADC_ExternalTrigInjectedConvCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:836
  }
  else
  {
    /* Disable the selected ADC external event selection for injected group */
    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:838
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_SoftwareStartInjectedConvCmd:

00000000 <ADC_SoftwareStartInjectedConvCmd>:
ADC_SoftwareStartInjectedConvCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:853
void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartInjectedConvCmd+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:857
  {
    /* Enable the selected ADC conversion for injected group on external event and start the selected
       ADC injected conversion */
    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1302 	orr.w	r3, r3, #2129920	; 0x208000
   8:	e002      	b.n	10 <ADC_SoftwareStartInjectedConvCmd+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:863
  }
  else
  {
    /* Disable the selected ADC conversion on external event for injected group and stop the selected
       ADC injected conversion */
    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1302 	bic.w	r3, r3, #2129920	; 0x208000
  10:	6083      	str	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:865
  }
}
  12:	4770      	bx	lr
Disassembly of section .text.ADC_GetSoftwareStartInjectedConvCmdStatus:

00000000 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
ADC_GetSoftwareStartInjectedConvCmdStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:878
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
   0:	6880      	ldr	r0, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:890
    /* JSWSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5040 	ubfx	r0, r0, #21, #1
   6:	4770      	bx	lr
Disassembly of section .text.ADC_InjectedChannelConfig:

00000000 <ADC_InjectedChannelConfig>:
ADC_InjectedChannelConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:938
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:930
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
   2:	b530      	push	{r4, r5, lr}
   4:	468c      	mov	ip, r1
   6:	4615      	mov	r5, r2
   8:	461c      	mov	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:938
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   a:	d90d      	bls.n	28 <ADC_InjectedChannelConfig+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:943
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   c:	2203      	movs	r2, #3
   e:	fb02 f20c 	mul.w	r2, r2, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:945
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  12:	2307      	movs	r3, #7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:943
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
  14:	3a1e      	subs	r2, #30
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:945
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  16:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:949
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  18:	fa14 f202 	lsls.w	r2, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:941
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  1c:	68c1      	ldr	r1, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:945
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  1e:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:949
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  22:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:951
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  24:	60c1      	str	r1, [r0, #12]
  26:	e00b      	b.n	40 <ADC_InjectedChannelConfig+0x40>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:958
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  28:	2203      	movs	r2, #3
  2a:	fb02 f20c 	mul.w	r2, r2, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:960
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  2e:	2307      	movs	r3, #7
  30:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:964
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  32:	fa14 f202 	lsls.w	r2, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:956
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  36:	6901      	ldr	r1, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:960
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
  38:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:964
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
  3c:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:966
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  3e:	6101      	str	r1, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:970
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  40:	6b81      	ldr	r1, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:974
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  42:	2205      	movs	r2, #5
  44:	f3c1 5301 	ubfx	r3, r1, #20, #2
  48:	1aeb      	subs	r3, r5, r3
  4a:	3302      	adds	r3, #2
  4c:	b2db      	uxtb	r3, r3
  4e:	435a      	muls	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:976
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  50:	231f      	movs	r3, #31
  52:	4093      	lsls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:980
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
  54:	fa0c f202 	lsl.w	r2, ip, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:976
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  58:	ea21 0103 	bic.w	r1, r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:980
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
  5c:	4311      	orrs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:982
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
  5e:	6381      	str	r1, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:983
}
  60:	bd30      	pop	{r4, r5, pc}
  62:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_InjectedSequencerLengthConfig:

00000000 <ADC_InjectedSequencerLengthConfig>:
ADC_InjectedSequencerLengthConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1001
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
   0:	6b83      	ldr	r3, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1006
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
   2:	3901      	subs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1003
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
   4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1006
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
   8:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1008
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
   c:	6383      	str	r3, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1009
}
   e:	4770      	bx	lr
Disassembly of section .text.ADC_SetInjectedOffset:

00000000 <ADC_SetInjectedOffset>:
ADC_SetInjectedOffset():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1025
  * @param  Offset: the offset value for the selected ADC injected channel
  *   This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
   0:	b082      	sub	sp, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1026
  __IO uint32_t tmp = 0;
   2:	2300      	movs	r3, #0
   4:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1033
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));  
  
  tmp = (uint32_t)ADCx;
   6:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1034
  tmp += ADC_InjectedChannel;
   8:	9b01      	ldr	r3, [sp, #4]
   a:	18c9      	adds	r1, r1, r3
   c:	9101      	str	r1, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1037
  
  /* Set the selected injected channel data offset */
  *(__IO uint32_t *) tmp = (uint32_t)Offset;
   e:	9b01      	ldr	r3, [sp, #4]
  10:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1038
}
  12:	b002      	add	sp, #8
  14:	4770      	bx	lr
  16:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_GetInjectedConversionValue:

00000000 <ADC_GetInjectedConversionValue>:
ADC_GetInjectedConversionValue():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1052
  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
   0:	b082      	sub	sp, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1053
  __IO uint32_t tmp = 0;
   2:	2300      	movs	r3, #0
   4:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1059
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
   6:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1060
  tmp += ADC_InjectedChannel + JDR_Offset;
   8:	9b01      	ldr	r3, [sp, #4]
   a:	3328      	adds	r3, #40
   c:	185b      	adds	r3, r3, r1
   e:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1063
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp);   
  10:	9b01      	ldr	r3, [sp, #4]
  12:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1064
}
  14:	b280      	uxth	r0, r0
  16:	b002      	add	sp, #8
  18:	4770      	bx	lr
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_AnalogWatchdogCmd:

00000000 <ADC_AnalogWatchdogCmd>:
ADC_AnalogWatchdogCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1082
  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
  * @retval None	  
  */
void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1090
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  /* Get the old register value */
  tmpreg = ADCx->CR1;
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= CR1_AWDMode_Reset;
   2:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
   6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1092
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
   a:	4319      	orrs	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1094
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   c:	6041      	str	r1, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1095
}
   e:	4770      	bx	lr
Disassembly of section .text.ADC_AnalogWatchdogThresholdsConfig:

00000000 <ADC_AnalogWatchdogThresholdsConfig>:
ADC_AnalogWatchdogThresholdsConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1114
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
   0:	6241      	str	r1, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1116
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
   2:	6282      	str	r2, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1117
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_AnalogWatchdogSingleChannelConfig:

00000000 <ADC_AnalogWatchdogSingleChannelConfig>:
ADC_AnalogWatchdogSingleChannelConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1145
  *     @arg ADC_Channel_16: ADC Channel16 selected
  *     @arg ADC_Channel_17: ADC Channel17 selected
  * @retval None
  */
void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
{
   0:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1153
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->CR1;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_Reset;
   2:	f023 031f 	bic.w	r3, r3, #31	; 0x1f
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1155
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
   6:	4319      	orrs	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1157
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   8:	6041      	str	r1, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1158
}
   a:	4770      	bx	lr
Disassembly of section .text.ADC_TempSensorVrefintCmd:

00000000 <ADC_TempSensorVrefintCmd>:
ADC_TempSensorVrefintCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1167
  * @param  NewState: new state of the temperature sensor.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)
{
   0:	b120      	cbz	r0, c <ADC_TempSensorVrefintCmd+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1173
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC1->CR2 |= CR2_TSVREFE_Set;
   2:	4a05      	ldr	r2, [pc, #20]	(18 <ADC_TempSensorVrefintCmd+0x18>)
   4:	6893      	ldr	r3, [r2, #8]
   6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   a:	e003      	b.n	14 <ADC_TempSensorVrefintCmd+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1178
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC1->CR2 &= CR2_TSVREFE_Reset;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <ADC_TempSensorVrefintCmd+0x18>)
   e:	6893      	ldr	r3, [r2, #8]
  10:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
  14:	6093      	str	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1180
  }
}
  16:	4770      	bx	lr
  18:	40012400 	.word	0x40012400
Disassembly of section .text.ADC_GetFlagStatus:

00000000 <ADC_GetFlagStatus>:
ADC_GetFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1201
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   0:	6803      	ldr	r3, [r0, #0]
   2:	4219      	tst	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1213
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr
Disassembly of section .text.ADC_ClearFlag:

00000000 <ADC_ClearFlag>:
ADC_ClearFlag():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1228
  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
  * @retval None
  */
void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
{
   0:	43c9      	mvns	r1, r1
   2:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1234
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_GetITStatus:

00000000 <ADC_GetITStatus>:
ADC_GetITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1247
  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  * @retval The new state of ADC_IT (SET or RESET).
  */
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
   0:	6842      	ldr	r2, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1258
  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;
  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   2:	6803      	ldr	r3, [r0, #0]
   4:	ea13 2011 	ands.w	r0, r3, r1, lsr #8
   8:	d004      	beq.n	14 <ADC_GetITStatus+0x14>
   a:	b2cb      	uxtb	r3, r1
   c:	4213      	tst	r3, r2
   e:	bf0c      	ite	eq
  10:	2000      	moveq	r0, #0
  12:	2001      	movne	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1270
    /* ADC_IT is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
  14:	4770      	bx	lr
  16:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ADC_ClearITPendingBit:

00000000 <ADC_ClearITPendingBit>:
ADC_ClearITPendingBit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1283
  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  * @retval None
  */
void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
   0:	ea6f 2111 	mvn.w	r1, r1, lsr #8
   4:	6001      	str	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:1292
  assert_param(IS_ADC_IT(ADC_IT));
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
}
   6:	4770      	bx	lr
Disassembly of section .text.ADC_DeInit:

00000000 <ADC_DeInit>:
ADC_DeInit():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:179
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
   0:	4b12      	ldr	r3, [pc, #72]	(4c <ADC_DeInit+0x4c>)
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:183
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  if (ADCx == ADC1)
   4:	4298      	cmp	r0, r3
   6:	d107      	bne.n	18 <ADC_DeInit+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:186
  {
    /* Enable ADC1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
   8:	f44f 7000 	mov.w	r0, #512	; 0x200
   c:	2101      	movs	r1, #1
   e:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:188
    /* Release ADC1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  12:	f44f 7000 	mov.w	r0, #512	; 0x200
  16:	e014      	b.n	42 <ADC_DeInit+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:190
  }
  else if (ADCx == ADC2)
  18:	4b0d      	ldr	r3, [pc, #52]	(50 <ADC_DeInit+0x50>)
  1a:	4298      	cmp	r0, r3
  1c:	d107      	bne.n	2e <ADC_DeInit+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:193
  {
    /* Enable ADC2 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
  1e:	f44f 6080 	mov.w	r0, #1024	; 0x400
  22:	2101      	movs	r1, #1
  24:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:195
    /* Release ADC2 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
  28:	f44f 6080 	mov.w	r0, #1024	; 0x400
  2c:	e009      	b.n	42 <ADC_DeInit+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:199
  }
  else
  {
    if (ADCx == ADC3)
  2e:	4b09      	ldr	r3, [pc, #36]	(54 <ADC_DeInit+0x54>)
  30:	4298      	cmp	r0, r3
  32:	d109      	bne.n	48 <ADC_DeInit+0x48>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:202
    {
      /* Enable ADC3 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
  34:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  38:	2101      	movs	r1, #1
  3a:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:204
      /* Release ADC3 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
  3e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  42:	2100      	movs	r1, #0
  44:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_adc.c:207
    }
  }
}
  48:	bd10      	pop	{r4, pc}
  4a:	46c0      	nop			(mov r8, r8)
  4c:	40012400 	.word	0x40012400
  50:	40012800 	.word	0x40012800
  54:	40013c00 	.word	0x40013c00
