
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\tcp.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\tcp.o

Disassembly of section .text.tcp_accept_null:

00000000 <tcp_accept_null>:
tcp_accept_null():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:333
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
   0:	f06f 0004 	mvn.w	r0, #4	; 0x4
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_update_rcv_ann_wnd:

00000000 <tcp_update_rcv_ann_wnd>:
tcp_update_rcv_ann_wnd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:394
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:395
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
   2:	6a41      	ldr	r1, [r0, #36]
   4:	8d04      	ldrh	r4, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:397

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + pcb->mss)) {
   6:	8f03      	ldrh	r3, [r0, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:395
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
   8:	eb04 0c01 	add.w	ip, r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:397

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + pcb->mss)) {
   c:	6ac2      	ldr	r2, [r0, #44]
   e:	ebc3 030c 	rsb	r3, r3, ip
  12:	1a9b      	subs	r3, r3, r2
  14:	2b00      	cmp	r3, #0
  16:	db03      	blt.n	20 <tcp_update_rcv_ann_wnd+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:399
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
  18:	8544      	strh	r4, [r0, #42]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:400
    return new_right_edge - pcb->rcv_ann_right_edge;
  1a:	ebc2 000c 	rsb	r0, r2, ip
  1e:	e006      	b.n	2e <tcp_update_rcv_ann_wnd+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:402
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
  20:	1a8b      	subs	r3, r1, r2
  22:	2b00      	cmp	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:405
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
  24:	bfcc      	ite	gt
  26:	2300      	movgt	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:408
    } else {
      /* keep the right edge of window constant */
      pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
  28:	1a53      	suble	r3, r2, r1
  2a:	8543      	strh	r3, [r0, #42]
  2c:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:412
    }
    return 0;
  }
}
  2e:	bd10      	pop	{r4, pc}
Disassembly of section .text.tcp_new_port:

00000000 <tcp_new_port>:
tcp_new_port():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:468
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   0:	4b15      	ldr	r3, [pc, #84]	(58 <tcp_new_port+0x58>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:455
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
   2:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:468
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   4:	681d      	ldr	r5, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:473
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   6:	4b15      	ldr	r3, [pc, #84]	(5c <tcp_new_port+0x5c>)
   8:	681c      	ldr	r4, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:478
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
   a:	4b15      	ldr	r3, [pc, #84]	(60 <tcp_new_port+0x60>)
   c:	6819      	ldr	r1, [r3, #0]
   e:	4b15      	ldr	r3, [pc, #84]	(64 <tcp_new_port+0x64>)
  10:	8818      	ldrh	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:464
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  12:	1c43      	adds	r3, r0, #1
  14:	b298      	uxth	r0, r3
  16:	f410 4f00 	tst.w	r0, #32768	; 0x8000
  1a:	bf18      	it	ne
  1c:	f44f 5080 	movne.w	r0, #4096	; 0x1000
  20:	462a      	mov	r2, r5
  22:	e003      	b.n	2c <tcp_new_port+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:469
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  24:	8b13      	ldrh	r3, [r2, #24]
  26:	4283      	cmp	r3, r0
  28:	d0f3      	beq.n	12 <tcp_new_port+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:468
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  2a:	68d2      	ldr	r2, [r2, #12]
  2c:	2a00      	cmp	r2, #0
  2e:	d1f9      	bne.n	24 <tcp_new_port+0x24>
  30:	4622      	mov	r2, r4
  32:	e003      	b.n	3c <tcp_new_port+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:474
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  34:	8b13      	ldrh	r3, [r2, #24]
  36:	4283      	cmp	r3, r0
  38:	d0eb      	beq.n	12 <tcp_new_port+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:473
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  3a:	68d2      	ldr	r2, [r2, #12]
  3c:	2a00      	cmp	r2, #0
  3e:	d1f9      	bne.n	34 <tcp_new_port+0x34>
  40:	460a      	mov	r2, r1
  42:	e003      	b.n	4c <tcp_new_port+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:479
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  44:	8b13      	ldrh	r3, [r2, #24]
  46:	4283      	cmp	r3, r0
  48:	d0e3      	beq.n	12 <tcp_new_port+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:478
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  4a:	68d2      	ldr	r2, [r2, #12]
  4c:	2a00      	cmp	r2, #0
  4e:	d1f9      	bne.n	44 <tcp_new_port+0x44>
  50:	4b04      	ldr	r3, [pc, #16]	(64 <tcp_new_port+0x64>)
  52:	8018      	strh	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:484
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  54:	bd30      	pop	{r4, r5, pc}
  56:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.tcp_bind:

00000000 <tcp_bind>:
tcp_bind():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:265
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
   0:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:262
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   6:	4606      	mov	r6, r0
   8:	460c      	mov	r4, r1
   a:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:265
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
   c:	b10b      	cbz	r3, 12 <tcp_bind+0x12>
   e:	20f3      	movs	r0, #243
  10:	e083      	b.n	11a <tcp_bind+0x11a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:267

  if (port == 0) {
  12:	b912      	cbnz	r2, 1a <tcp_bind+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:268
    port = tcp_new_port();
  14:	f7ff fffe 	bl	0 <tcp_bind>
  18:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:272
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  1a:	4b41      	ldr	r3, [pc, #260]	(120 <tcp_bind+0x120>)
  1c:	6819      	ldr	r1, [r3, #0]
  1e:	e015      	b.n	4c <tcp_bind+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:274
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  20:	8b0b      	ldrh	r3, [r1, #24]
  22:	42ab      	cmp	r3, r5
  24:	d111      	bne.n	4a <tcp_bind+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:275
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  26:	6808      	ldr	r0, [r1, #0]
  28:	2800      	cmp	r0, #0
  2a:	d075      	beq.n	118 <tcp_bind+0x118>
  2c:	2c00      	cmp	r4, #0
  2e:	d073      	beq.n	118 <tcp_bind+0x118>
  30:	7863      	ldrb	r3, [r4, #1]
  32:	7822      	ldrb	r2, [r4, #0]
  34:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  38:	78a3      	ldrb	r3, [r4, #2]
  3a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  3e:	78e3      	ldrb	r3, [r4, #3]
  40:	ea52 6303 	orrs.w	r3, r2, r3, lsl #24
  44:	d068      	beq.n	118 <tcp_bind+0x118>
  46:	4298      	cmp	r0, r3
  48:	d066      	beq.n	118 <tcp_bind+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:273
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  4a:	68c9      	ldr	r1, [r1, #12]
  4c:	2900      	cmp	r1, #0
  4e:	d1e7      	bne.n	20 <tcp_bind+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:283
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  50:	4b34      	ldr	r3, [pc, #208]	(124 <tcp_bind+0x124>)
  52:	6819      	ldr	r1, [r3, #0]
  54:	e015      	b.n	82 <tcp_bind+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:285
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  56:	8b0b      	ldrh	r3, [r1, #24]
  58:	42ab      	cmp	r3, r5
  5a:	d111      	bne.n	80 <tcp_bind+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:286
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  5c:	6808      	ldr	r0, [r1, #0]
  5e:	2800      	cmp	r0, #0
  60:	d05a      	beq.n	118 <tcp_bind+0x118>
  62:	2c00      	cmp	r4, #0
  64:	d058      	beq.n	118 <tcp_bind+0x118>
  66:	7863      	ldrb	r3, [r4, #1]
  68:	7822      	ldrb	r2, [r4, #0]
  6a:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  6e:	78a3      	ldrb	r3, [r4, #2]
  70:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  74:	78e3      	ldrb	r3, [r4, #3]
  76:	ea52 6303 	orrs.w	r3, r2, r3, lsl #24
  7a:	d04d      	beq.n	118 <tcp_bind+0x118>
  7c:	4298      	cmp	r0, r3
  7e:	d04b      	beq.n	118 <tcp_bind+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:284
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80:	68c9      	ldr	r1, [r1, #12]
  82:	2900      	cmp	r1, #0
  84:	d1e7      	bne.n	56 <tcp_bind+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:294
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  86:	4b28      	ldr	r3, [pc, #160]	(128 <tcp_bind+0x128>)
  88:	681f      	ldr	r7, [r3, #0]
  8a:	4639      	mov	r1, r7
  8c:	e015      	b.n	ba <tcp_bind+0xba>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:295
    if (cpcb->local_port == port) {
  8e:	8b0b      	ldrh	r3, [r1, #24]
  90:	42ab      	cmp	r3, r5
  92:	d111      	bne.n	b8 <tcp_bind+0xb8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:296
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  94:	6808      	ldr	r0, [r1, #0]
  96:	2800      	cmp	r0, #0
  98:	d03e      	beq.n	118 <tcp_bind+0x118>
  9a:	2c00      	cmp	r4, #0
  9c:	d03c      	beq.n	118 <tcp_bind+0x118>
  9e:	7863      	ldrb	r3, [r4, #1]
  a0:	7822      	ldrb	r2, [r4, #0]
  a2:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  a6:	78a3      	ldrb	r3, [r4, #2]
  a8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  ac:	78e3      	ldrb	r3, [r4, #3]
  ae:	ea52 6303 	orrs.w	r3, r2, r3, lsl #24
  b2:	d031      	beq.n	118 <tcp_bind+0x118>
  b4:	4298      	cmp	r0, r3
  b6:	d02f      	beq.n	118 <tcp_bind+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:294
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  b8:	68c9      	ldr	r1, [r1, #12]
  ba:	2900      	cmp	r1, #0
  bc:	d1e7      	bne.n	8e <tcp_bind+0x8e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:305
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  be:	4b1b      	ldr	r3, [pc, #108]	(12c <tcp_bind+0x12c>)
  c0:	6819      	ldr	r1, [r3, #0]
  c2:	e010      	b.n	e6 <tcp_bind+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:306
    if (cpcb->local_port == port) {
  c4:	8b0b      	ldrh	r3, [r1, #24]
  c6:	42ab      	cmp	r3, r5
  c8:	d10c      	bne.n	e4 <tcp_bind+0xe4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:307
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  ca:	7862      	ldrb	r2, [r4, #1]
  cc:	7823      	ldrb	r3, [r4, #0]
  ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  d2:	78a2      	ldrb	r2, [r4, #2]
  d4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  d8:	78e2      	ldrb	r2, [r4, #3]
  da:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  de:	680a      	ldr	r2, [r1, #0]
  e0:	429a      	cmp	r2, r3
  e2:	d019      	beq.n	118 <tcp_bind+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:305
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  e4:	68c9      	ldr	r1, [r1, #12]
  e6:	2900      	cmp	r1, #0
  e8:	d1ec      	bne.n	c4 <tcp_bind+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:313
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  ea:	b17c      	cbz	r4, 10c <tcp_bind+0x10c>
  ec:	7862      	ldrb	r2, [r4, #1]
  ee:	7823      	ldrb	r3, [r4, #0]
  f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  f4:	78a2      	ldrb	r2, [r4, #2]
  f6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  fa:	78e2      	ldrb	r2, [r4, #3]
  fc:	ea53 6202 	orrs.w	r2, r3, r2, lsl #24
 100:	d004      	beq.n	10c <tcp_bind+0x10c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:314
    pcb->local_ip = *ipaddr;
 102:	4630      	mov	r0, r6
 104:	4621      	mov	r1, r4
 106:	2204      	movs	r2, #4
 108:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:317
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
 10c:	4b06      	ldr	r3, [pc, #24]	(128 <tcp_bind+0x128>)
 10e:	60f7      	str	r7, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:316
  }

  if (!ip_addr_isany(ipaddr)) {
    pcb->local_ip = *ipaddr;
  }
  pcb->local_port = port;
 110:	8335      	strh	r5, [r6, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:317
  TCP_REG(&tcp_bound_pcbs, pcb);
 112:	601e      	str	r6, [r3, #0]
 114:	2000      	movs	r0, #0
 116:	e000      	b.n	11a <tcp_bind+0x11a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:319
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 118:	20f5      	movs	r0, #245
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:320
}
 11a:	b240      	sxtb	r0, r0
 11c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...
Disassembly of section .text.tcp_setprio:

00000000 <tcp_setprio>:
tcp_setprio():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:871
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  pcb->prio = prio;
   0:	7441      	strb	r1, [r0, #17]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:872
}
   2:	4770      	bx	lr
Disassembly of section .text.tcp_arg:

00000000 <tcp_arg>:
tcp_arg():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1072
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  pcb->callback_arg = arg;
   0:	6141      	str	r1, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1073
}
   2:	4770      	bx	lr
Disassembly of section .text.tcp_recv:

00000000 <tcp_recv>:
tcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1087
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  pcb->recv = recv;
   0:	f8c0 1084 	str.w	r1, [r0, #132]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1088
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_sent:

00000000 <tcp_sent>:
tcp_sent():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1101
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  pcb->sent = sent;
   0:	f8c0 1080 	str.w	r1, [r0, #128]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1102
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_err:

00000000 <tcp_err>:
tcp_err():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1116
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  pcb->errf = errf;
   0:	f8c0 1090 	str.w	r1, [r0, #144]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1117
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_accept:

00000000 <tcp_accept>:
tcp_accept():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1131
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  pcb->accept = accept;
   0:	61c1      	str	r1, [r0, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1132
}
   2:	4770      	bx	lr
Disassembly of section .text.tcp_poll:

00000000 <tcp_poll>:
tcp_poll():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1147
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
#if LWIP_CALLBACK_API
  pcb->poll = poll;
   0:	f8c0 108c 	str.w	r1, [r0, #140]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1149
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
   4:	f880 2035 	strb.w	r2, [r0, #53]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1150
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_next_iss:

00000000 <tcp_next_iss>:
tcp_next_iss():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1261
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
   0:	4a03      	ldr	r2, [pc, #12]	(10 <tcp_next_iss+0x10>)
   2:	4b04      	ldr	r3, [pc, #16]	(14 <tcp_next_iss+0x14>)
   4:	6818      	ldr	r0, [r3, #0]
   6:	6853      	ldr	r3, [r2, #4]
   8:	18c0      	adds	r0, r0, r3
   a:	6050      	str	r0, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1263
  return iss;
}
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.tcp_eff_send_mss:

00000000 <tcp_eff_send_mss>:
tcp_eff_send_mss():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1273
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1277
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
   4:	4608      	mov	r0, r1
   6:	f7ff fffe 	bl	0 <ip_route>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1278
  if ((outif != NULL) && (outif->mtu != 0)) {
   a:	b138      	cbz	r0, 1c <ip_route+0x1c>
   c:	8d80      	ldrh	r0, [r0, #44]
   e:	b128      	cbz	r0, 1c <ip_route+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1285
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_enqueue(), and don't support
     * IP options
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
  10:	f1a0 0328 	sub.w	r3, r0, #40	; 0x28
  14:	b29b      	uxth	r3, r3
  16:	429c      	cmp	r4, r3
  18:	bf28      	it	cs
  1a:	461c      	movcs	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1288
  }
  return sendmss;
}
  1c:	4620      	mov	r0, r4
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.tcp_recved:

00000000 <tcp_recved>:
tcp_recved():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:430
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
   0:	8d03      	ldrh	r3, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:424
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:430
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
   4:	18c9      	adds	r1, r1, r3
   6:	b289      	uxth	r1, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:431
  if (pcb->rcv_wnd > TCP_WND)
   8:	f640 3368 	movw	r3, #2920	; 0xb68
   c:	4299      	cmp	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:430
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
   e:	8501      	strh	r1, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:432
  if (pcb->rcv_wnd > TCP_WND)
    pcb->rcv_wnd = TCP_WND;
  10:	bf88      	it	hi
  12:	8503      	strhhi	r3, [r0, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:424
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  14:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:434

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND)
    pcb->rcv_wnd = TCP_WND;

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
  16:	f7ff fffe 	bl	0 <tcp_recved>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:440

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/2), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
  1a:	f240 23d9 	movw	r3, #729	; 0x2d9
  1e:	4298      	cmp	r0, r3
  20:	dd08      	ble.n	34 <tcp_recved+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:441
    tcp_ack_now(pcb);
  22:	f894 3022 	ldrb.w	r3, [r4, #34]
  26:	4620      	mov	r0, r4
  28:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  2c:	f884 3022 	strb.w	r3, [r4, #34]
  30:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:445

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  34:	bd10      	pop	{r4, pc}
  36:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_fasttmr:

00000000 <tcp_fasttmr>:
tcp_fasttmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:799
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   0:	4b15      	ldr	r3, [pc, #84]	(58 <tcp_fasttmr+0x58>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:796
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
   2:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:799
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   4:	681c      	ldr	r4, [r3, #0]
   6:	e024      	b.n	52 <tcp_fasttmr+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:801
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
   8:	6fe2      	ldr	r2, [r4, #124]
   a:	b17a      	cbz	r2, 2c <tcp_fasttmr+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:805
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
   c:	f8d4 5084 	ldr.w	r5, [r4, #132]
  10:	b13d      	cbz	r5, 22 <tcp_fasttmr+0x22>
  12:	2300      	movs	r3, #0
  14:	6960      	ldr	r0, [r4, #20]
  16:	4621      	mov	r1, r4
  18:	47a8      	blx	r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:806
      if (err == ERR_OK) {
  1a:	f010 0fff 	tst.w	r0, #255	; 0xff
  1e:	d105      	bne.n	2c <tcp_fasttmr+0x2c>
  20:	e002      	b.n	28 <tcp_fasttmr+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:805
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  22:	4610      	mov	r0, r2
  24:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:807
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  28:	2300      	movs	r3, #0
  2a:	67e3      	str	r3, [r4, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:812
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  2c:	f894 3022 	ldrb.w	r3, [r4, #34]
  30:	f013 0f01 	tst.w	r3, #1	; 0x1
  34:	d00c      	beq.n	50 <tcp_fasttmr+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:814
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  36:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  3a:	f884 3022 	strb.w	r3, [r4, #34]
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:815
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  44:	f894 3022 	ldrb.w	r3, [r4, #34]
  48:	f023 0303 	bic.w	r3, r3, #3	; 0x3
  4c:	f884 3022 	strb.w	r3, [r4, #34]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:799
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  50:	68e4      	ldr	r4, [r4, #12]
  52:	2c00      	cmp	r4, #0
  54:	d1d8      	bne.n	8 <tcp_fasttmr+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:818
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  56:	bd70      	pop	{r4, r5, r6, pc}
  58:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_seg_free:

00000000 <tcp_seg_free>:
tcp_seg_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:847
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:850
  u8_t count = 0;
  
  if (seg != NULL) {
   2:	4605      	mov	r5, r0
   4:	b908      	cbnz	r0, a <tcp_seg_free+0xa>
   6:	4604      	mov	r4, r0
   8:	e008      	b.n	1c <tcp_seg_free+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:851
    if (seg->p != NULL) {
   a:	6840      	ldr	r0, [r0, #4]
   c:	b108      	cbz	r0, 12 <tcp_seg_free+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:852
      count = pbuf_free(seg->p);
   e:	f7ff fffe 	bl	0 <pbuf_free>
  12:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:857
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  14:	4629      	mov	r1, r5
  16:	2004      	movs	r0, #4
  18:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:860
  }
  return count;
}
  1c:	4620      	mov	r0, r4
  1e:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.tcp_segs_free:

00000000 <tcp_segs_free>:
tcp_segs_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:828
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	2500      	movs	r5, #0
   4:	e005      	b.n	12 <tcp_segs_free+0x12>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:832
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
    next = seg->next;
   6:	6804      	ldr	r4, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:833
    count += tcp_seg_free(seg);
   8:	f7ff fffe 	bl	0 <tcp_segs_free>
   c:	1940      	adds	r0, r0, r5
   e:	b2c5      	uxtb	r5, r0
  10:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:831
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  12:	2800      	cmp	r0, #0
  14:	d1f7      	bne.n	6 <tcp_segs_free+0x6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:837
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  16:	4628      	mov	r0, r5
  18:	bd70      	pop	{r4, r5, r6, pc}
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_pcb_purge:

00000000 <tcp_pcb_purge>:
tcp_pcb_purge():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1161
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
   0:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1160
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
   2:	b510      	push	{r4, lr}
   4:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1161
  if (pcb->state != CLOSED &&
   6:	b193      	cbz	r3, 2e <tcp_pcb_purge+0x2e>
   8:	2b0a      	cmp	r3, #10
   a:	d010      	beq.n	2e <tcp_pcb_purge+0x2e>
   c:	2b01      	cmp	r3, #1
   e:	d00e      	beq.n	2e <tcp_pcb_purge+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1188
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
  10:	6fc0      	ldr	r0, [r0, #124]
  12:	b118      	cbz	r0, 1c <tcp_pcb_purge+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1190
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  14:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1191
      pcb->refused_data = NULL;
  18:	2300      	movs	r3, #0
  1a:	67e3      	str	r3, [r4, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1211
    pcb->rtime = -1;

    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  1c:	6f60      	ldr	r0, [r4, #116]
  1e:	f7ff fffe 	bl	0 <tcp_pcb_purge>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1212
    tcp_segs_free(pcb->unacked);
  22:	6fa0      	ldr	r0, [r4, #120]
  24:	f7ff fffe 	bl	0 <tcp_pcb_purge>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1213
    pcb->unacked = pcb->unsent = NULL;
  28:	2300      	movs	r3, #0
  2a:	6763      	str	r3, [r4, #116]
  2c:	67a3      	str	r3, [r4, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1215
  }
}
  2e:	bd10      	pop	{r4, pc}
Disassembly of section .text.tcp_pcb_remove:

00000000 <tcp_pcb_remove>:
tcp_pcb_remove():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1226
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
   0:	6802      	ldr	r2, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1225
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1226
  TCP_RMV(pcblist, pcb);
   4:	428a      	cmp	r2, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1225
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
   6:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1226
  TCP_RMV(pcblist, pcb);
   8:	d102      	bne.n	10 <tcp_pcb_remove+0x10>
   a:	68cb      	ldr	r3, [r1, #12]
   c:	6003      	str	r3, [r0, #0]
   e:	e010      	b.n	32 <tcp_pcb_remove+0x32>
  10:	4b14      	ldr	r3, [pc, #80]	(64 <tcp_pcb_remove+0x64>)
  12:	601a      	str	r2, [r3, #0]
  14:	e009      	b.n	2a <tcp_pcb_remove+0x2a>
  16:	68d3      	ldr	r3, [r2, #12]
  18:	b133      	cbz	r3, 28 <tcp_pcb_remove+0x28>
  1a:	42a3      	cmp	r3, r4
  1c:	d104      	bne.n	28 <tcp_pcb_remove+0x28>
  1e:	4b11      	ldr	r3, [pc, #68]	(64 <tcp_pcb_remove+0x64>)
  20:	601a      	str	r2, [r3, #0]
  22:	68e3      	ldr	r3, [r4, #12]
  24:	60d3      	str	r3, [r2, #12]
  26:	e004      	b.n	32 <tcp_pcb_remove+0x32>
  28:	461a      	mov	r2, r3
  2a:	2a00      	cmp	r2, #0
  2c:	d1f3      	bne.n	16 <tcp_pcb_remove+0x16>
  2e:	4b0d      	ldr	r3, [pc, #52]	(64 <tcp_pcb_remove+0x64>)
  30:	601a      	str	r2, [r3, #0]
  32:	2300      	movs	r3, #0
  34:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1228

  tcp_pcb_purge(pcb);
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <tcp_pcb_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1231
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  3c:	7c23      	ldrb	r3, [r4, #16]
  3e:	2b0a      	cmp	r3, #10
  40:	d00d      	beq.n	5e <tcp_pcb_remove+0x5e>
  42:	2b01      	cmp	r3, #1
  44:	d00b      	beq.n	5e <tcp_pcb_remove+0x5e>
  46:	f894 3022 	ldrb.w	r3, [r4, #34]
  4a:	f013 0f01 	tst.w	r3, #1	; 0x1
  4e:	d006      	beq.n	5e <tcp_pcb_remove+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1234
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  50:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  54:	f884 3022 	strb.w	r3, [r4, #34]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1235
    tcp_output(pcb);
  58:	4620      	mov	r0, r4
  5a:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1246
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  5e:	2300      	movs	r3, #0
  60:	7423      	strb	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1249

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  62:	bd10      	pop	{r4, pc}
  64:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_listen_with_backlog:

00000000 <tcp_listen_with_backlog>:
tcp_listen_with_backlog():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:356
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
   0:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:352
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:356
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
   6:	2b00      	cmp	r3, #0
   8:	d13b      	bne.n	82 <tcp_listen_with_backlog+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:362

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
   a:	2003      	movs	r0, #3
   c:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:363
  if (lpcb == NULL) {
  10:	4605      	mov	r5, r0
  12:	2800      	cmp	r0, #0
  14:	d035      	beq.n	82 <tcp_listen_with_backlog+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:366
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  16:	6963      	ldr	r3, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:374
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  18:	491b      	ldr	r1, [pc, #108]	(88 <tcp_listen_with_backlog+0x88>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:366
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  1a:	6143      	str	r3, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:367
  lpcb->local_port = pcb->local_port;
  1c:	8b23      	ldrh	r3, [r4, #24]
  1e:	8303      	strh	r3, [r0, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:368
  lpcb->state = LISTEN;
  20:	2301      	movs	r3, #1
  22:	7403      	strb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:370
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  24:	8923      	ldrh	r3, [r4, #8]
  26:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  2a:	8103      	strh	r3, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:371
  lpcb->ttl = pcb->ttl;
  2c:	7ae3      	ldrb	r3, [r4, #11]
  2e:	72c3      	strb	r3, [r0, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:372
  lpcb->tos = pcb->tos;
  30:	7aa3      	ldrb	r3, [r4, #10]
  32:	7283      	strb	r3, [r0, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:374
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  34:	680a      	ldr	r2, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:373
  lpcb->state = LISTEN;
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  36:	6823      	ldr	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:374
  TCP_RMV(&tcp_bound_pcbs, pcb);
  38:	42a2      	cmp	r2, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:373
  lpcb->state = LISTEN;
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  3a:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:374
  TCP_RMV(&tcp_bound_pcbs, pcb);
  3c:	d102      	bne.n	44 <tcp_listen_with_backlog+0x44>
  3e:	68e3      	ldr	r3, [r4, #12]
  40:	600b      	str	r3, [r1, #0]
  42:	e010      	b.n	66 <tcp_listen_with_backlog+0x66>
  44:	4b11      	ldr	r3, [pc, #68]	(8c <tcp_listen_with_backlog+0x8c>)
  46:	601a      	str	r2, [r3, #0]
  48:	e009      	b.n	5e <tcp_listen_with_backlog+0x5e>
  4a:	68d3      	ldr	r3, [r2, #12]
  4c:	b133      	cbz	r3, 5c <tcp_listen_with_backlog+0x5c>
  4e:	42a3      	cmp	r3, r4
  50:	d104      	bne.n	5c <tcp_listen_with_backlog+0x5c>
  52:	4b0e      	ldr	r3, [pc, #56]	(8c <tcp_listen_with_backlog+0x8c>)
  54:	601a      	str	r2, [r3, #0]
  56:	68e3      	ldr	r3, [r4, #12]
  58:	60d3      	str	r3, [r2, #12]
  5a:	e004      	b.n	66 <tcp_listen_with_backlog+0x66>
  5c:	461a      	mov	r2, r3
  5e:	2a00      	cmp	r2, #0
  60:	d1f3      	bne.n	4a <tcp_listen_with_backlog+0x4a>
  62:	4b0a      	ldr	r3, [pc, #40]	(8c <tcp_listen_with_backlog+0x8c>)
  64:	601a      	str	r2, [r3, #0]
  66:	2300      	movs	r3, #0
  68:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:375
  memp_free(MEMP_TCP_PCB, pcb);
  6a:	2002      	movs	r0, #2
  6c:	4621      	mov	r1, r4
  6e:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:377
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  72:	4b07      	ldr	r3, [pc, #28]	(90 <tcp_listen_with_backlog+0x90>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:383
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  74:	4a07      	ldr	r2, [pc, #28]	(94 <tcp_listen_with_backlog+0x94>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:377
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  76:	61eb      	str	r3, [r5, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:383
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  78:	6813      	ldr	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:384
  return (struct tcp_pcb *)lpcb;
  7a:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:383
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  7c:	60eb      	str	r3, [r5, #12]
  7e:	6015      	str	r5, [r2, #0]
  80:	e000      	b.n	84 <tcp_listen_with_backlog+0x84>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:384
  return (struct tcp_pcb *)lpcb;
  82:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:385
}
  84:	bd70      	pop	{r4, r5, r6, pc}
  86:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.tcp_connect:

00000000 <tcp_connect>:
tcp_connect():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:501
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2:	461f      	mov	r7, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:505
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
   4:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:501
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
   6:	4604      	mov	r4, r0
   8:	460e      	mov	r6, r1
   a:	4615      	mov	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:505
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
   c:	b10b      	cbz	r3, 12 <tcp_connect+0x12>
   e:	25f3      	movs	r5, #243
  10:	e05c      	b.n	cc <tcp_connect+0xcc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:508

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  12:	b909      	cbnz	r1, 18 <tcp_connect+0x18>
  14:	25f7      	movs	r5, #247
  16:	e059      	b.n	cc <tcp_connect+0xcc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:509
    pcb->remote_ip = *ipaddr;
  18:	3004      	adds	r0, #4
  1a:	2204      	movs	r2, #4
  1c:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:514
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
  20:	8b23      	ldrh	r3, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:513
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  22:	8425      	strh	r5, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:514
  if (pcb->local_port == 0) {
  24:	b913      	cbnz	r3, 2c <tcp_connect+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:515
    pcb->local_port = tcp_new_port();
  26:	f7ff fffe 	bl	0 <tcp_connect>
  2a:	8320      	strh	r0, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:517
  }
  iss = tcp_next_iss();
  2c:	f7ff fffe 	bl	0 <tcp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:518
  pcb->rcv_nxt = 0;
  30:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:522
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  32:	f640 3268 	movw	r2, #2920	; 0xb68
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:518
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  }
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  36:	6263      	str	r3, [r4, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:519
  pcb->snd_nxt = iss;
  38:	65a0      	str	r0, [r4, #88]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:522
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  3a:	8522      	strh	r2, [r4, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:520
    pcb->local_port = tcp_new_port();
  }
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  3c:	3801      	subs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:523
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  pcb->rcv_ann_wnd = TCP_WND;
  3e:	8562      	strh	r2, [r4, #42]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:524
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  40:	62e3      	str	r3, [r4, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:525
  pcb->snd_wnd = TCP_WND;
  42:	b293      	uxth	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:528
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  44:	f44f 7206 	mov.w	r2, #536	; 0x218
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:520
    pcb->local_port = tcp_new_port();
  }
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  48:	64e0      	str	r0, [r4, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:521
  pcb->snd_lbb = iss - 1;
  4a:	66a0      	str	r0, [r4, #104]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:525
  pcb->rcv_wnd = TCP_WND;
  pcb->rcv_ann_wnd = TCP_WND;
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
  4c:	f8a4 305c 	strh.w	r3, [r4, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:528
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  50:	8722      	strh	r2, [r4, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:530
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  52:	4631      	mov	r1, r6
  54:	f44f 7006 	mov.w	r0, #536	; 0x218
  58:	f7ff fffe 	bl	0 <tcp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:532
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  5c:	f04f 0301 	mov.w	r3, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:533
  pcb->ssthresh = pcb->mss * 10;
  60:	b282      	uxth	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:532
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  62:	f8a4 3052 	strh.w	r3, [r4, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:533
  pcb->ssthresh = pcb->mss * 10;
  66:	230a      	movs	r3, #10
  68:	4353      	muls	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:538
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  6a:	4919      	ldr	r1, [pc, #100]	(d0 <tcp_connect+0xd0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:533
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  pcb->ssthresh = pcb->mss * 10;
  6c:	f8a4 3054 	strh.w	r3, [r4, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:538
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  70:	680a      	ldr	r2, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:534
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
  72:	2302      	movs	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:538
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  74:	42a2      	cmp	r2, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:530
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  76:	8720      	strh	r0, [r4, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:534
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
  78:	7423      	strb	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:536
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  7a:	f8c4 7088 	str.w	r7, [r4, #136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:538
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  7e:	d102      	bne.n	86 <tcp_connect+0x86>
  80:	68e3      	ldr	r3, [r4, #12]
  82:	600b      	str	r3, [r1, #0]
  84:	e010      	b.n	a8 <tcp_connect+0xa8>
  86:	4b13      	ldr	r3, [pc, #76]	(d4 <tcp_connect+0xd4>)
  88:	601a      	str	r2, [r3, #0]
  8a:	e009      	b.n	a0 <tcp_connect+0xa0>
  8c:	68d3      	ldr	r3, [r2, #12]
  8e:	b133      	cbz	r3, 9e <tcp_connect+0x9e>
  90:	42a3      	cmp	r3, r4
  92:	d104      	bne.n	9e <tcp_connect+0x9e>
  94:	4b0f      	ldr	r3, [pc, #60]	(d4 <tcp_connect+0xd4>)
  96:	601a      	str	r2, [r3, #0]
  98:	68e3      	ldr	r3, [r4, #12]
  9a:	60d3      	str	r3, [r2, #12]
  9c:	e004      	b.n	a8 <tcp_connect+0xa8>
  9e:	461a      	mov	r2, r3
  a0:	2a00      	cmp	r2, #0
  a2:	d1f3      	bne.n	8c <tcp_connect+0x8c>
  a4:	4b0b      	ldr	r3, [pc, #44]	(d4 <tcp_connect+0xd4>)
  a6:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:539
  TCP_REG(&tcp_active_pcbs, pcb);
  a8:	4a0b      	ldr	r2, [pc, #44]	(d8 <tcp_connect+0xd8>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:543

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
  aa:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:539
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  TCP_REG(&tcp_active_pcbs, pcb);
  ac:	6813      	ldr	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:543

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
  ae:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:539
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  TCP_REG(&tcp_active_pcbs, pcb);
  b0:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:543

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
  b2:	2301      	movs	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:539
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  TCP_REG(&tcp_active_pcbs, pcb);
  b4:	6014      	str	r4, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:543

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
  b6:	9301      	str	r3, [sp, #4]
  b8:	460a      	mov	r2, r1
  ba:	18db      	adds	r3, r3, r3
  bc:	9100      	str	r1, [sp, #0]
  be:	f7ff fffe 	bl	0 <tcp_enqueue>
  c2:	b2c5      	uxtb	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:548
#if LWIP_TCP_TIMESTAMPS
                    | TF_SEG_OPTS_TS
#endif
                    );
  if (ret == ERR_OK) { 
  c4:	b915      	cbnz	r5, cc <tcp_connect+0xcc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:549
    tcp_output(pcb);
  c6:	4620      	mov	r0, r4
  c8:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:552
  }
  return ret;
} 
  cc:	b268      	sxtb	r0, r5
  ce:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...
Disassembly of section .text.tcp_abandon:

00000000 <tcp_abandon>:
tcp_abandon():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:199
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:212

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
   4:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:199
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
   6:	b085      	sub	sp, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:212

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
   8:	2b0a      	cmp	r3, #10
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:199
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
   a:	4604      	mov	r4, r0
   c:	468b      	mov	fp, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:212

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
   e:	d108      	bne.n	22 <tcp_abandon+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:213
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  10:	4621      	mov	r1, r4
  12:	481d      	ldr	r0, [pc, #116]	(88 <tcp_abandon+0x88>)
  14:	f7ff fffe 	bl	0 <tcp_abandon>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:214
    memp_free(MEMP_TCP_PCB, pcb);
  18:	2002      	movs	r0, #2
  1a:	4621      	mov	r1, r4
  1c:	f7ff fffe 	bl	0 <memp_free>
  20:	e02e      	b.n	80 <tcp_abandon+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:218
  } else {
    seqno = pcb->snd_nxt;
    ackno = pcb->rcv_nxt;
    ip_addr_set(&local_ip, &(pcb->local_ip));
  22:	6803      	ldr	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:216
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
  24:	f8d0 a058 	ldr.w	sl, [r0, #88]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:217
    ackno = pcb->rcv_nxt;
  28:	f8d0 9024 	ldr.w	r9, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:218
    ip_addr_set(&local_ip, &(pcb->local_ip));
  2c:	9302      	str	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:219
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  2e:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:220
    local_port = pcb->local_port;
  30:	8b07      	ldrh	r7, [r0, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:221
    remote_port = pcb->remote_port;
  32:	f8b0 8020 	ldrh.w	r8, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:223
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  36:	f8d0 5090 	ldr.w	r5, [r0, #144]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:225
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  3a:	6946      	ldr	r6, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:226
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  3c:	4621      	mov	r1, r4
  3e:	4813      	ldr	r0, [pc, #76]	(8c <tcp_abandon+0x8c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:219
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
    ackno = pcb->rcv_nxt;
    ip_addr_set(&local_ip, &(pcb->local_ip));
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  40:	9303      	str	r3, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:226
    remote_port = pcb->remote_port;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  42:	f7ff fffe 	bl	0 <tcp_abandon>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:227
    if (pcb->unacked != NULL) {
  46:	6fa0      	ldr	r0, [r4, #120]
  48:	b108      	cbz	r0, 4e <tcp_abandon+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:228
      tcp_segs_free(pcb->unacked);
  4a:	f7ff fffe 	bl	0 <tcp_abandon>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:230
    }
    if (pcb->unsent != NULL) {
  4e:	6f60      	ldr	r0, [r4, #116]
  50:	b108      	cbz	r0, 56 <tcp_abandon+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:231
      tcp_segs_free(pcb->unsent);
  52:	f7ff fffe 	bl	0 <tcp_abandon>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:238
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  56:	2002      	movs	r0, #2
  58:	4621      	mov	r1, r4
  5a:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:239
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  5e:	b11d      	cbz	r5, 68 <tcp_abandon+0x68>
  60:	4630      	mov	r0, r6
  62:	f06f 0104 	mvn.w	r1, #4	; 0x4
  66:	47a8      	blx	r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:240
    if (reset) {
  68:	f1bb 0f00 	cmp.w	fp, #0	; 0x0
  6c:	d008      	beq.n	80 <tcp_abandon+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:242
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  6e:	4650      	mov	r0, sl
  70:	4649      	mov	r1, r9
  72:	aa02      	add	r2, sp, #8
  74:	ab03      	add	r3, sp, #12
  76:	9700      	str	r7, [sp, #0]
  78:	f8cd 8004 	str.w	r8, [sp, #4]
  7c:	f7ff fffe 	bl	0 <tcp_rst>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:245
    }
  }
}
  80:	b005      	add	sp, #20
  82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  86:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.tcp_alloc:

00000000 <tcp_alloc>:
tcp_alloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:983
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:987
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
   6:	2002      	movs	r0, #2
   8:	f7ff fffe 	bl	0 <memp_malloc>
   c:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:988
  if (pcb == NULL) {
   e:	2800      	cmp	r0, #0
  10:	d13c      	bne.n	8c <tcp_alloc+0x8c>
tcp_kill_timewait():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:962
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  12:	4b3c      	ldr	r3, [pc, #240]	(104 <tcp_alloc+0x104>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:963
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  14:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:962
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  16:	681a      	ldr	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:963
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  18:	4b3b      	ldr	r3, [pc, #236]	(108 <tcp_alloc+0x108>)
  1a:	681c      	ldr	r4, [r3, #0]
  1c:	e007      	b.n	2e <tcp_alloc+0x2e>
  1e:	6b13      	ldr	r3, [r2, #48]
  20:	1ae3      	subs	r3, r4, r3
  22:	4283      	cmp	r3, r0
  24:	bf34      	ite	cc
  26:	4603      	movcc	r3, r0
  28:	4611      	movcs	r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:962
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  2a:	68d2      	ldr	r2, [r2, #12]
  2c:	4618      	mov	r0, r3
  2e:	2a00      	cmp	r2, #0
  30:	d1f5      	bne.n	1e <tcp_alloc+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:968
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  32:	b119      	cbz	r1, 3c <tcp_alloc+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:971
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  34:	4608      	mov	r0, r1
  36:	2101      	movs	r1, #1
  38:	f7ff fffe 	bl	0 <tcp_alloc>
tcp_alloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:993
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  3c:	2002      	movs	r0, #2
  3e:	f7ff fffe 	bl	0 <memp_malloc>
  42:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:994
    if (pcb == NULL) {
  44:	bb10      	cbnz	r0, 8c <tcp_alloc+0x8c>
tcp_kill_prio():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:933
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  46:	4b31      	ldr	r3, [pc, #196]	(10c <tcp_alloc+0x10c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:934
    if (pcb->prio <= prio &&
  48:	247f      	movs	r4, #127
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:933
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  4a:	6819      	ldr	r1, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:934
    if (pcb->prio <= prio &&
  4c:	4b2e      	ldr	r3, [pc, #184]	(108 <tcp_alloc+0x108>)
  4e:	681e      	ldr	r6, [r3, #0]
  50:	e00f      	b.n	72 <tcp_alloc+0x72>
  52:	7c4a      	ldrb	r2, [r1, #17]
  54:	42ba      	cmp	r2, r7
  56:	d807      	bhi.n	68 <tcp_alloc+0x68>
  58:	42a2      	cmp	r2, r4
  5a:	d805      	bhi.n	68 <tcp_alloc+0x68>
  5c:	6b0b      	ldr	r3, [r1, #48]
  5e:	1af3      	subs	r3, r6, r3
  60:	4283      	cmp	r3, r0
  62:	d301      	bcc.n	68 <tcp_alloc+0x68>
  64:	460d      	mov	r5, r1
  66:	e001      	b.n	6c <tcp_alloc+0x6c>
  68:	4622      	mov	r2, r4
  6a:	4603      	mov	r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:933
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  6c:	68c9      	ldr	r1, [r1, #12]
  6e:	4614      	mov	r4, r2
  70:	4618      	mov	r0, r3
  72:	2900      	cmp	r1, #0
  74:	d1ed      	bne.n	52 <tcp_alloc+0x52>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:942
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  76:	b11d      	cbz	r5, 80 <tcp_alloc+0x80>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:945
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  78:	4628      	mov	r0, r5
  7a:	3101      	adds	r1, #1
  7c:	f7ff fffe 	bl	0 <tcp_alloc>
tcp_alloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:998
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80:	2002      	movs	r0, #2
  82:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1001
    }
  }
  if (pcb != NULL) {
  86:	4605      	mov	r5, r0
  88:	2800      	cmp	r0, #0
  8a:	d037      	beq.n	fc <tcp_alloc+0xfc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1002
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8c:	2100      	movs	r1, #0
  8e:	22a0      	movs	r2, #160
  90:	4628      	mov	r0, r5
  92:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1004
    pcb->prio = TCP_PRIO_NORMAL;
    pcb->snd_buf = TCP_SND_BUF;
  96:	f640 3268 	movw	r2, #2920	; 0xb68
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1003
      pcb = memp_malloc(MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = TCP_PRIO_NORMAL;
  9a:	2340      	movs	r3, #64
  9c:	746b      	strb	r3, [r5, #17]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1006
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
  9e:	b293      	uxth	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1004
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = TCP_PRIO_NORMAL;
    pcb->snd_buf = TCP_SND_BUF;
  a0:	f8a5 206e 	strh.w	r2, [r5, #110]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1006
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
  a4:	852b      	strh	r3, [r5, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1007
    pcb->rcv_ann_wnd = TCP_WND;
  a6:	856b      	strh	r3, [r5, #42]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1012
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  a8:	f44f 7206 	mov.w	r2, #536	; 0x218
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1009
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
  ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1005
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = TCP_PRIO_NORMAL;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
  b0:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1009
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
  b2:	72eb      	strb	r3, [r5, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1012
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  b4:	872a      	strh	r2, [r5, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1016
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
  b6:	86eb      	strh	r3, [r5, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1013
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  b8:	f04f 0206 	mov.w	r2, #6	; 0x6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1017
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
  bc:	f04f 0301 	mov.w	r3, #1	; 0x1
  c0:	f8a5 3052 	strh.w	r3, [r5, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1005
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = TCP_PRIO_NORMAL;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
  c4:	f8a5 4070 	strh.w	r4, [r5, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1008
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
  c8:	72ac      	strb	r4, [r5, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1013
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  ca:	f8a5 2048 	strh.w	r2, [r5, #72]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1014
    pcb->sa = 0;
  ce:	f8a5 4044 	strh.w	r4, [r5, #68]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1015
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  d2:	f8a5 2046 	strh.w	r2, [r5, #70]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1018
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
  d6:	f7ff fffe 	bl	0 <tcp_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1023
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
  da:	4b0b      	ldr	r3, [pc, #44]	(108 <tcp_alloc+0x108>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1019
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
  dc:	6668      	str	r0, [r5, #100]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1020
    pcb->snd_nxt = iss;
  de:	65a8      	str	r0, [r5, #88]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1021
    pcb->lastack = iss;
  e0:	64e8      	str	r0, [r5, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1022
    pcb->snd_lbb = iss;   
  e2:	66a8      	str	r0, [r5, #104]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1023
    pcb->tmr = tcp_ticks;
  e4:	681b      	ldr	r3, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1025

    pcb->polltmr = 0;
  e6:	f885 4034 	strb.w	r4, [r5, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1023
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
  ea:	632b      	str	r3, [r5, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1028

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  ec:	4b08      	ldr	r3, [pc, #32]	(110 <tcp_alloc+0x110>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1039
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  ee:	f885 409d 	strb.w	r4, [r5, #157]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1028
    pcb->tmr = tcp_ticks;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  f2:	f8c5 3084 	str.w	r3, [r5, #132]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1032
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  f6:	4b07      	ldr	r3, [pc, #28]	(114 <tcp_alloc+0x114>)
  f8:	f8c5 3094 	str.w	r3, [r5, #148]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1042
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  }
  return pcb;
}
  fc:	4628      	mov	r0, r5
  fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 102:	46c0      	nop			(mov r8, r8)
	...
 114:	006ddd00 	.word	0x006ddd00
Disassembly of section .text.tcp_new:

00000000 <tcp_new>:
tcp_new():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1058
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1059
  return tcp_alloc(TCP_PRIO_NORMAL);
   2:	2040      	movs	r0, #64
   4:	f7ff fffe 	bl	0 <tcp_new>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:1060
}
   8:	bd10      	pop	{r4, pc}
   a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.tcp_slowtmr:

00000000 <tcp_slowtmr>:
tcp_slowtmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:571
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
   0:	4b85      	ldr	r3, [pc, #532]	(218 <tcp_slowtmr+0x218>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:563
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:571
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
   6:	681a      	ldr	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:575

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
   8:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:571
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
   a:	3201      	adds	r2, #1
   c:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:575

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
   e:	4b83      	ldr	r3, [pc, #524]	(21c <tcp_slowtmr+0x21c>)
  10:	681d      	ldr	r5, [r3, #0]
  12:	e0db      	b.n	1cc <tcp_slowtmr+0x1cc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:587
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  14:	7c2b      	ldrb	r3, [r5, #16]
  16:	2b02      	cmp	r3, #2
  18:	d103      	bne.n	22 <tcp_slowtmr+0x22>
  1a:	f895 304a 	ldrb.w	r3, [r5, #74]
  1e:	2b06      	cmp	r3, #6
  20:	d057      	beq.n	d2 <tcp_slowtmr+0xd2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:591
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  22:	f895 304a 	ldrb.w	r3, [r5, #74]
  26:	2b0c      	cmp	r3, #12
  28:	d053      	beq.n	d2 <tcp_slowtmr+0xd2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:595
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  2a:	f895 109c 	ldrb.w	r1, [r5, #156]
  2e:	b1b1      	cbz	r1, 5e <tcp_slowtmr+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:599
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  30:	4a7b      	ldr	r2, [pc, #492]	(220 <tcp_slowtmr+0x220>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:598
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  32:	f8d5 3098 	ldr.w	r3, [r5, #152]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:599
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  36:	1852      	adds	r2, r2, r1
  38:	f812 2c01 	ldrb.w	r2, [r2, #-1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:598
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  3c:	3301      	adds	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:599
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  3e:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:598
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  40:	f8c5 3098 	str.w	r3, [r5, #152]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:599
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  44:	d347      	bcc.n	d6 <tcp_slowtmr+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:600
          pcb->persist_cnt = 0;
  46:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:601
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  48:	2906      	cmp	r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:600
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
  4a:	f8c5 3098 	str.w	r3, [r5, #152]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:601
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  4e:	d802      	bhi.n	56 <tcp_slowtmr+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:602
            pcb->persist_backoff++;
  50:	1c4b      	adds	r3, r1, #1
  52:	f885 309c 	strb.w	r3, [r5, #156]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:604
          }
          tcp_zero_window_probe(pcb);
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <tcp_zero_window_probe>
  5c:	e03b      	b.n	d6 <tcp_slowtmr+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:608
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  5e:	8eeb      	ldrh	r3, [r5, #54]
  60:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  64:	d101      	bne.n	6a <tcp_slowtmr+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:609
          ++pcb->rtime;
  66:	3301      	adds	r3, #1
  68:	86eb      	strh	r3, [r5, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:611

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  6a:	6fab      	ldr	r3, [r5, #120]
  6c:	2b00      	cmp	r3, #0
  6e:	d032      	beq.n	d6 <tcp_slowtmr+0xd6>
  70:	f9b5 2036 	ldrsh.w	r2, [r5, #54]
  74:	f9b5 3048 	ldrsh.w	r3, [r5, #72]
  78:	429a      	cmp	r2, r3
  7a:	db2c      	blt.n	d6 <tcp_slowtmr+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:619
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  7c:	7c2b      	ldrb	r3, [r5, #16]
  7e:	2b02      	cmp	r3, #2
  80:	d00d      	beq.n	9e <tcp_slowtmr+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:620
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  82:	f9b5 3044 	ldrsh.w	r3, [r5, #68]
  86:	f9b5 2046 	ldrsh.w	r2, [r5, #70]
  8a:	f895 104a 	ldrb.w	r1, [r5, #74]
  8e:	eb02 02e3 	add.w	r2, r2, r3, asr #3
  92:	4b63      	ldr	r3, [pc, #396]	(220 <tcp_slowtmr+0x220>)
  94:	185b      	adds	r3, r3, r1
  96:	79db      	ldrb	r3, [r3, #7]
  98:	409a      	lsls	r2, r3
  9a:	f8a5 2048 	strh.w	r2, [r5, #72]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:624
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  9e:	f04f 0300 	mov.w	r3, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:628

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  a2:	f8b5 205c 	ldrh.w	r2, [r5, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:624
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  a6:	86eb      	strh	r3, [r5, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:628

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  a8:	f8b5 3052 	ldrh.w	r3, [r5, #82]
  ac:	4293      	cmp	r3, r2
  ae:	bf28      	it	cs
  b0:	4613      	movcs	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:629
          if (pcb->ssthresh < pcb->mss) {
  b2:	8f2a      	ldrh	r2, [r5, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:628
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  b4:	085b      	lsrs	r3, r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:629
          if (pcb->ssthresh < pcb->mss) {
  b6:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:628
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  b8:	f8a5 3054 	strh.w	r3, [r5, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:629
          if (pcb->ssthresh < pcb->mss) {
  bc:	d202      	bcs.n	c4 <tcp_slowtmr+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:630
            pcb->ssthresh = pcb->mss * 2;
  be:	0053      	lsls	r3, r2, #1
  c0:	f8a5 3054 	strh.w	r3, [r5, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:632
          }
          pcb->cwnd = pcb->mss;
  c4:	8f2b      	ldrh	r3, [r5, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:639
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  c6:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:632
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < pcb->mss) {
            pcb->ssthresh = pcb->mss * 2;
          }
          pcb->cwnd = pcb->mss;
  c8:	f8a5 3052 	strh.w	r3, [r5, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:639
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  cc:	f7ff fffe 	bl	0 <tcp_rexmit_rto>
  d0:	e001      	b.n	d6 <tcp_slowtmr+0xd6>
  d2:	2401      	movs	r4, #1
  d4:	e000      	b.n	d8 <tcp_slowtmr+0xd8>
  d6:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:644
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  d8:	7c29      	ldrb	r1, [r5, #16]
  da:	2906      	cmp	r1, #6
  dc:	d107      	bne.n	ee <tcp_slowtmr+0xee>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:645
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  de:	4b4e      	ldr	r3, [pc, #312]	(218 <tcp_slowtmr+0x218>)
  e0:	6b2a      	ldr	r2, [r5, #48]
  e2:	681b      	ldr	r3, [r3, #0]
  e4:	1a9b      	subs	r3, r3, r2
  e6:	2b28      	cmp	r3, #40
  e8:	d901      	bls.n	ee <tcp_slowtmr+0xee>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:647
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  ea:	1c63      	adds	r3, r4, #1
  ec:	b2dc      	uxtb	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:653
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  ee:	892b      	ldrh	r3, [r5, #8]
  f0:	f013 0f08 	tst.w	r3, #8	; 0x8
  f4:	d027      	beq.n	146 <tcp_slowtmr+0x146>
  f6:	2904      	cmp	r1, #4
  f8:	d001      	beq.n	fe <tcp_slowtmr+0xfe>
  fa:	2907      	cmp	r1, #7
  fc:	d123      	bne.n	146 <tcp_slowtmr+0x146>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:661
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  fe:	4b46      	ldr	r3, [pc, #280]	(218 <tcp_slowtmr+0x218>)
 100:	f8d5 1094 	ldr.w	r1, [r5, #148]
 104:	681a      	ldr	r2, [r3, #0]
 106:	6b2b      	ldr	r3, [r5, #48]
 108:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
 10c:	1ad0      	subs	r0, r2, r3
 10e:	4b45      	ldr	r3, [pc, #276]	(224 <tcp_slowtmr+0x224>)
 110:	18cb      	adds	r3, r1, r3
 112:	fbb3 f3f6 	udiv	r3, r3, r6
 116:	4298      	cmp	r0, r3
 118:	d904      	bls.n	124 <tcp_slowtmr+0x124>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:669
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
 11a:	4628      	mov	r0, r5
 11c:	2101      	movs	r1, #1
 11e:	f7ff fffe 	bl	0 <tcp_slowtmr>
 122:	e010      	b.n	146 <tcp_slowtmr+0x146>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:676
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 124:	f895 309d 	ldrb.w	r3, [r5, #157]
 128:	4a3f      	ldr	r2, [pc, #252]	(228 <tcp_slowtmr+0x228>)
 12a:	fb02 1303 	mla	r3, r2, r3, r1
 12e:	fbb3 f3f6 	udiv	r3, r3, r6
 132:	4298      	cmp	r0, r3
 134:	d907      	bls.n	146 <tcp_slowtmr+0x146>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:681
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
 136:	4628      	mov	r0, r5
 138:	f7ff fffe 	bl	0 <tcp_keepalive>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:682
        pcb->keep_cnt_sent++;
 13c:	f895 309d 	ldrb.w	r3, [r5, #157]
 140:	3301      	adds	r3, #1
 142:	f885 309d 	strb.w	r3, [r5, #157]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:699
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 146:	7c2b      	ldrb	r3, [r5, #16]
 148:	2b03      	cmp	r3, #3
 14a:	d105      	bne.n	158 <tcp_slowtmr+0x158>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:700
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 14c:	4b32      	ldr	r3, [pc, #200]	(218 <tcp_slowtmr+0x218>)
 14e:	6b2a      	ldr	r2, [r5, #48]
 150:	681b      	ldr	r3, [r3, #0]
 152:	1a9b      	subs	r3, r3, r2
 154:	2b28      	cmp	r3, #40
 156:	e006      	b.n	166 <tcp_slowtmr+0x166>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:708
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 158:	2b09      	cmp	r3, #9
 15a:	d105      	bne.n	168 <tcp_slowtmr+0x168>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:709
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 15c:	4b2e      	ldr	r3, [pc, #184]	(218 <tcp_slowtmr+0x218>)
 15e:	6b2a      	ldr	r2, [r5, #48]
 160:	681b      	ldr	r3, [r3, #0]
 162:	1a9b      	subs	r3, r3, r2
 164:	2bf0      	cmp	r3, #240
 166:	d800      	bhi.n	16a <tcp_slowtmr+0x16a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:716
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 168:	b1b4      	cbz	r4, 198 <tcp_slowtmr+0x198>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:717
      tcp_pcb_purge(pcb);      
 16a:	4628      	mov	r0, r5
 16c:	f7ff fffe 	bl	0 <tcp_slowtmr>
 170:	68ea      	ldr	r2, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:719
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 172:	b10f      	cbz	r7, 178 <tcp_slowtmr+0x178>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:721
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 174:	60fa      	str	r2, [r7, #12]
 176:	e001      	b.n	17c <tcp_slowtmr+0x17c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:725
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 178:	4b28      	ldr	r3, [pc, #160]	(21c <tcp_slowtmr+0x21c>)
 17a:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:728
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
 17c:	f8d5 3090 	ldr.w	r3, [r5, #144]
 180:	b11b      	cbz	r3, 18a <tcp_slowtmr+0x18a>
 182:	6968      	ldr	r0, [r5, #20]
 184:	f06f 0104 	mvn.w	r1, #4	; 0x4
 188:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:730

      pcb2 = pcb->next;
 18a:	68ec      	ldr	r4, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:731
      memp_free(MEMP_TCP_PCB, pcb);
 18c:	4629      	mov	r1, r5
 18e:	2002      	movs	r0, #2
 190:	f7ff fffe 	bl	0 <memp_free>
 194:	4625      	mov	r5, r4
 196:	e019      	b.n	1cc <tcp_slowtmr+0x1cc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:736
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
 198:	f895 3034 	ldrb.w	r3, [r5, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:737
      if (pcb->polltmr >= pcb->pollinterval) {
 19c:	f895 2035 	ldrb.w	r2, [r5, #53]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:736
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
 1a0:	3301      	adds	r3, #1
 1a2:	b2db      	uxtb	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:737
      if (pcb->polltmr >= pcb->pollinterval) {
 1a4:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:736
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
 1a6:	f885 3034 	strb.w	r3, [r5, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:737
      if (pcb->polltmr >= pcb->pollinterval) {
 1aa:	d80d      	bhi.n	1c8 <tcp_slowtmr+0x1c8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:740
        pcb->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
 1ac:	f8d5 308c 	ldr.w	r3, [r5, #140]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:738
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
      if (pcb->polltmr >= pcb->pollinterval) {
        pcb->polltmr = 0;
 1b0:	f885 4034 	strb.w	r4, [r5, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:740
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
 1b4:	b12b      	cbz	r3, 1c2 <tcp_slowtmr+0x1c2>
 1b6:	6968      	ldr	r0, [r5, #20]
 1b8:	4629      	mov	r1, r5
 1ba:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:741
        if (err == ERR_OK) {
 1bc:	f010 0fff 	tst.w	r0, #255	; 0xff
 1c0:	d102      	bne.n	1c8 <tcp_slowtmr+0x1c8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:742
          tcp_output(pcb);
 1c2:	4628      	mov	r0, r5
 1c4:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:747
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
 1c8:	462f      	mov	r7, r5
 1ca:	68ed      	ldr	r5, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:579
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 1cc:	2d00      	cmp	r5, #0
 1ce:	f47f af21 	bne.w	14 <tcp_slowtmr+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:754
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
 1d2:	4b16      	ldr	r3, [pc, #88]	(22c <tcp_slowtmr+0x22c>)
 1d4:	681e      	ldr	r6, [r3, #0]
 1d6:	e012      	b.n	1fe <tcp_slowtmr+0x1fe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:760
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 1d8:	4b0f      	ldr	r3, [pc, #60]	(218 <tcp_slowtmr+0x218>)
 1da:	6b32      	ldr	r2, [r6, #48]
 1dc:	681b      	ldr	r3, [r3, #0]
 1de:	1a9b      	subs	r3, r3, r2
 1e0:	2bf0      	cmp	r3, #240
 1e2:	d80f      	bhi.n	204 <tcp_slowtmr+0x204>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:783
      pcb2 = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb);
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
 1e4:	4635      	mov	r5, r6
 1e6:	68f6      	ldr	r6, [r6, #12]
 1e8:	e009      	b.n	1fe <tcp_slowtmr+0x1fe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:772
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 1ea:	60ea      	str	r2, [r5, #12]
 1ec:	e001      	b.n	1f2 <tcp_slowtmr+0x1f2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:776
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 1ee:	4b0f      	ldr	r3, [pc, #60]	(22c <tcp_slowtmr+0x22c>)
 1f0:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:779
      }
      pcb2 = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb);
 1f2:	4631      	mov	r1, r6
 1f4:	2002      	movs	r0, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:778
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb->next;
 1f6:	68f4      	ldr	r4, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:779
      memp_free(MEMP_TCP_PCB, pcb);
 1f8:	f7ff fffe 	bl	0 <memp_free>
 1fc:	4626      	mov	r6, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:755

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 1fe:	2e00      	cmp	r6, #0
 200:	d1ea      	bne.n	1d8 <tcp_slowtmr+0x1d8>
 202:	e006      	b.n	212 <tcp_slowtmr+0x212>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:768
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
 204:	4630      	mov	r0, r6
 206:	f7ff fffe 	bl	0 <tcp_slowtmr>
 20a:	68f2      	ldr	r2, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:770
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 20c:	2d00      	cmp	r5, #0
 20e:	d1ec      	bne.n	1ea <tcp_slowtmr+0x1ea>
 210:	e7ed      	b.n	1ee <tcp_slowtmr+0x1ee>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:786
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 212:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 216:	46c0      	nop			(mov r8, r8)
	...
 224:	000a4cb8 	.word	0x000a4cb8
 228:	000124f8 	.word	0x000124f8
 22c:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_tmr:

00000000 <tcp_tmr>:
tcp_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:86
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:88
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
   2:	f7ff fffe 	bl	0 <tcp_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:90

  if (++tcp_timer & 1) {
   6:	4a05      	ldr	r2, [pc, #20]	(1c <tcp_tmr+0x1c>)
   8:	7813      	ldrb	r3, [r2, #0]
   a:	3301      	adds	r3, #1
   c:	b2db      	uxtb	r3, r3
   e:	f013 0f01 	tst.w	r3, #1	; 0x1
  12:	7013      	strb	r3, [r2, #0]
  14:	d001      	beq.n	1a <tcp_tmr+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:93
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  16:	f7ff fffe 	bl	0 <tcp_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:95
  }
}
  1a:	bd10      	pop	{r4, pc}
  1c:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_close:

00000000 <tcp_close>:
tcp_close():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:121
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
   0:	7c03      	ldrb	r3, [r0, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:113
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:121
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
   6:	2b07      	cmp	r3, #7
   8:	d832      	bhi.n	70 <tcp_close+0x70>
   a:	e8df f003 	tbb	[pc, r3]
   e:	2304      	.short	0x2304
  10:	31333329 	.word	0x31333329
  14:	3a31      	.short	0x3a31
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:131
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  16:	4922      	ldr	r1, [pc, #136]	(a0 <tcp_close+0xa0>)
  18:	680a      	ldr	r2, [r1, #0]
  1a:	4282      	cmp	r2, r0
  1c:	d102      	bne.n	24 <tcp_close+0x24>
  1e:	68c3      	ldr	r3, [r0, #12]
  20:	600b      	str	r3, [r1, #0]
  22:	e010      	b.n	46 <tcp_close+0x46>
  24:	4b1f      	ldr	r3, [pc, #124]	(a4 <tcp_close+0xa4>)
  26:	601a      	str	r2, [r3, #0]
  28:	e009      	b.n	3e <tcp_close+0x3e>
  2a:	68d3      	ldr	r3, [r2, #12]
  2c:	b133      	cbz	r3, 3c <tcp_close+0x3c>
  2e:	42ab      	cmp	r3, r5
  30:	d104      	bne.n	3c <tcp_close+0x3c>
  32:	4b1c      	ldr	r3, [pc, #112]	(a4 <tcp_close+0xa4>)
  34:	601a      	str	r2, [r3, #0]
  36:	68eb      	ldr	r3, [r5, #12]
  38:	60d3      	str	r3, [r2, #12]
  3a:	e004      	b.n	46 <tcp_close+0x46>
  3c:	461a      	mov	r2, r3
  3e:	2a00      	cmp	r2, #0
  40:	d1f3      	bne.n	2a <tcp_close+0x2a>
  42:	4b18      	ldr	r3, [pc, #96]	(a4 <tcp_close+0xa4>)
  44:	601a      	str	r2, [r3, #0]
  46:	2400      	movs	r4, #0
  48:	60ec      	str	r4, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:132
    memp_free(MEMP_TCP_PCB, pcb);
  4a:	2002      	movs	r0, #2
  4c:	4629      	mov	r1, r5
  4e:	f7ff fffe 	bl	0 <memp_free>
  52:	e022      	b.n	9a <tcp_close+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:137
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  54:	4814      	ldr	r0, [pc, #80]	(a8 <tcp_close+0xa8>)
  56:	4629      	mov	r1, r5
  58:	f7ff fffe 	bl	0 <tcp_close>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:138
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  5c:	2003      	movs	r0, #3
  5e:	e004      	b.n	6a <tcp_close+0x6a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:143
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  60:	4812      	ldr	r0, [pc, #72]	(ac <tcp_close+0xac>)
  62:	4629      	mov	r1, r5
  64:	f7ff fffe 	bl	0 <tcp_close>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:144
    memp_free(MEMP_TCP_PCB, pcb);
  68:	2002      	movs	r0, #2
  6a:	4629      	mov	r1, r5
  6c:	f7ff fffe 	bl	0 <memp_free>
  70:	2400      	movs	r4, #0
  72:	e012      	b.n	9a <tcp_close+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:156
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  74:	2101      	movs	r1, #1
  76:	f7ff fffe 	bl	0 <tcp_send_ctrl>
  7a:	b2c4      	uxtb	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:157
    if (err == ERR_OK) {
  7c:	b944      	cbnz	r4, 90 <tcp_close+0x90>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:159
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  7e:	2305      	movs	r3, #5
  80:	e005      	b.n	8e <tcp_close+0x8e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:163
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  82:	2101      	movs	r1, #1
  84:	f7ff fffe 	bl	0 <tcp_send_ctrl>
  88:	b2c4      	uxtb	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:164
    if (err == ERR_OK) {
  8a:	b90c      	cbnz	r4, 90 <tcp_close+0x90>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:166
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8c:	2309      	movs	r3, #9
  8e:	742b      	strb	r3, [r5, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:176
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  90:	b11d      	cbz	r5, 9a <tcp_close+0x9a>
  92:	b914      	cbnz	r4, 9a <tcp_close+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:184
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  94:	4628      	mov	r0, r5
  96:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:187
  }
  return err;
}
  9a:	b260      	sxtb	r0, r4
  9c:	bd70      	pop	{r4, r5, r6, pc}
  9e:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.tcp_recv_null:

00000000 <tcp_recv_null>:
tcp_recv_null():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:904
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:906
  arg = arg;
  if (p != NULL) {
   2:	4610      	mov	r0, r2
   4:	b11a      	cbz	r2, e <tcp_recv_null+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:907
    pbuf_free(p);
   6:	f7ff fffe 	bl	0 <pbuf_free>
   a:	2000      	movs	r0, #0
   c:	e004      	b.n	18 <tcp_recv_null+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:908
  } else if (err == ERR_OK) {
   e:	b91b      	cbnz	r3, 18 <tcp_recv_null+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:909
    return tcp_close(pcb);
  10:	4608      	mov	r0, r1
  12:	f7ff fffe 	bl	0 <tcp_recv_null>
  16:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp.c:912
  }
  return ERR_OK;
}
  18:	b240      	sxtb	r0, r0
  1a:	bd10      	pop	{r4, pc}
