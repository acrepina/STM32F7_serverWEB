
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\mem.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\mem.o

Disassembly of section .text.mem_init:

00000000 <mem_init>:
mem_init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:270

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
   0:	4a0c      	ldr	r2, [pc, #48]	(34 <mem_init+0x34>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:263
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:270

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
   4:	4c0c      	ldr	r4, [pc, #48]	(38 <mem_init+0x38>)
   6:	f022 0203 	bic.w	r2, r2, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:273
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
   a:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:274
  mem->prev = 0;
   e:	2300      	movs	r3, #0
  10:	8053      	strh	r3, [r2, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:270

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  12:	f8c4 2c34 	str.w	r2, [r4, #3124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:278
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
  16:	2001      	movs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:275
  ram = LWIP_MEM_ALIGN(ram_heap);
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  18:	7113      	strb	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:277
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  1a:	1853      	adds	r3, r2, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:273

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  1c:	8011      	strh	r1, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:277
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  1e:	f8c4 3c38 	str.w	r3, [r4, #3128]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:279
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  22:	8019      	strh	r1, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:278
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
  24:	7118      	strb	r0, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:280
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;
  26:	8059      	strh	r1, [r3, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:285

  mem_sem = sys_sem_new(1);

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  28:	f8c4 2c40 	str.w	r2, [r4, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:282
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  mem_sem = sys_sem_new(1);
  2c:	f884 0c3c 	strb.w	r0, [r4, #3132]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:288

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  30:	bd10      	pop	{r4, pc}
  32:	46c0      	nop			(mov r8, r8)
  34:	00000003 	.word	0x00000003
  38:	000043e0 	.word	0x000043e0
Disassembly of section .text.mem_free:

00000000 <mem_free>:
mem_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:298
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
   0:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:302
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	d045      	beq.n	94 <mem_free+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:311
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
   8:	4a23      	ldr	r2, [pc, #140]	(98 <mem_free+0x98>)
   a:	f8d2 1c34 	ldr.w	r1, [r2, #3124]
   e:	4288      	cmp	r0, r1
  10:	d340      	bcc.n	94 <mem_free+0x94>
  12:	f8d2 5c38 	ldr.w	r5, [r2, #3128]
  16:	42a8      	cmp	r0, r5
  18:	d23c      	bcs.n	94 <mem_free+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:327
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
  1a:	2300      	movs	r3, #0
  1c:	f804 3c04 	strb.w	r3, [r4, #-4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:329

  if (mem < lfree) {
  20:	f8d2 3c40 	ldr.w	r3, [r2, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:323
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  24:	f1a0 0008 	sub.w	r0, r0, #8	; 0x8
plug_holes():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:236
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
  28:	f834 cc08 	ldrh.w	ip, [r4, #-8]
mem_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:329
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
  2c:	4298      	cmp	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:331
    /* the newly freed struct is now the lowest */
    lfree = mem;
  2e:	bf38      	it	cc
  30:	f8c2 0c40 	strcc.w	r0, [r2, #3136]
plug_holes():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:236
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
  34:	eb01 020c 	add.w	r2, r1, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:237
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  38:	4290      	cmp	r0, r2
  3a:	d013      	beq.n	64 <mem_free+0x64>
  3c:	7913      	ldrb	r3, [r2, #4]
  3e:	b98b      	cbnz	r3, 64 <mem_free+0x64>
  40:	42aa      	cmp	r2, r5
  42:	d00f      	beq.n	64 <mem_free+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:239
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  44:	4d14      	ldr	r5, [pc, #80]	(98 <mem_free+0x98>)
  46:	f8d5 3c40 	ldr.w	r3, [r5, #3136]
  4a:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:242
      lfree = mem;
    }
    mem->next = nmem->next;
  4c:	f831 300c 	ldrh.w	r3, [r1, ip]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:240

  nmem = (struct mem *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
  50:	bf08      	it	eq
  52:	f8c5 0c40 	streq.w	r0, [r5, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:242
    }
    mem->next = nmem->next;
  56:	f824 3c08 	strh.w	r3, [r4, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:243
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  5a:	f831 300c 	ldrh.w	r3, [r1, ip]
  5e:	1a42      	subs	r2, r0, r1
  60:	18cb      	adds	r3, r1, r3
  62:	805a      	strh	r2, [r3, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:247
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  64:	f834 cc06 	ldrh.w	ip, [r4, #-6]
  68:	eb01 020c 	add.w	r2, r1, ip
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:248
  if (pmem != mem && pmem->used == 0) {
  6c:	4282      	cmp	r2, r0
  6e:	d011      	beq.n	94 <mem_free+0x94>
  70:	7913      	ldrb	r3, [r2, #4]
  72:	b97b      	cbnz	r3, 94 <mem_free+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:250
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  74:	4d08      	ldr	r5, [pc, #32]	(98 <mem_free+0x98>)
  76:	f8d5 3c40 	ldr.w	r3, [r5, #3136]
  7a:	4283      	cmp	r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:253
      lfree = pmem;
    }
    pmem->next = mem->next;
  7c:	f834 3c08 	ldrh.w	r3, [r4, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:251
  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  if (pmem != mem && pmem->used == 0) {
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
  80:	bf08      	it	eq
  82:	f8c5 2c40 	streq.w	r2, [r5, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:253
    }
    pmem->next = mem->next;
  86:	f821 300c 	strh.w	r3, [r1, ip]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:254
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8a:	f834 3c08 	ldrh.w	r3, [r4, #-8]
  8e:	1a52      	subs	r2, r2, r1
  90:	18cb      	adds	r3, r1, r3
  92:	805a      	strh	r2, [r3, #2]
mem_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:342
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
  94:	bd30      	pop	{r4, r5, pc}
  96:	46c0      	nop			(mov r8, r8)
  98:	000043e0 	.word	0x000043e0
Disassembly of section .text.mem_realloc:

00000000 <mem_realloc>:
mem_realloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:367
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
   0:	3103      	adds	r1, #3
   2:	f64f 72fc 	movw	r2, #65532	; 0xfffc
   6:	ea01 0202 	and.w	r2, r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:369

  if(newsize < MIN_SIZE_ALIGNED) {
   a:	2a0b      	cmp	r2, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:358
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
   c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  10:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:369

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
  12:	d801      	bhi.n	18 <mem_realloc+0x18>
  14:	220c      	movs	r2, #12
  16:	e002      	b.n	1e <mem_realloc+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:374
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  18:	f5b2 4fa0 	cmp.w	r2, #20480	; 0x5000
  1c:	d849      	bhi.n	b2 <mem_realloc+0xb2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:381
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  1e:	f8df 809c 	ldr.w	r8, [pc, #156]	; bc <mem_realloc+0xbc>
  22:	f8d8 0c34 	ldr.w	r0, [r8, #3124]
  26:	4287      	cmp	r7, r0
  28:	d344      	bcc.n	b4 <mem_realloc+0xb4>
  2a:	f8d8 3c38 	ldr.w	r3, [r8, #3128]
  2e:	429f      	cmp	r7, r3
  30:	d240      	bcs.n	b4 <mem_realloc+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:391
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  32:	f1a7 0608 	sub.w	r6, r7, #8	; 0x8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:395
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  36:	f837 1c08 	ldrh.w	r1, [r7, #-8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:393
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  3a:	1a33      	subs	r3, r6, r0
  3c:	b29d      	uxth	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:395

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  3e:	f1a1 0308 	sub.w	r3, r1, #8	; 0x8
  42:	1b5b      	subs	r3, r3, r5
  44:	fa1f fc83 	uxth.w	ip, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:397
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
  48:	4562      	cmp	r2, ip
  4a:	d832      	bhi.n	b2 <mem_realloc+0xb2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:401
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  4c:	d032      	beq.n	b4 <mem_realloc+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:411
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  4e:	1844      	adds	r4, r0, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:412
  if(mem2->used == 0) {
  50:	7923      	ldrb	r3, [r4, #4]
  52:	b993      	cbnz	r3, 7a <mem_realloc+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:418
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  54:	f105 0308 	add.w	r3, r5, #8	; 0x8
  58:	18d3      	adds	r3, r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:416
  mem2 = (struct mem *)&ram[mem->next];
  if(mem2->used == 0) {
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  5a:	f830 c001 	ldrh.w	ip, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:418
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  5e:	b299      	uxth	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:419
    if (lfree == mem2) {
  60:	f8d8 3c40 	ldr.w	r3, [r8, #3136]
  64:	42a3      	cmp	r3, r4
  66:	d102      	bne.n	6e <mem_realloc+0x6e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:420
      lfree = (struct mem *)&ram[ptr2];
  68:	1843      	adds	r3, r0, r1
  6a:	f8c8 3c40 	str.w	r3, [r8, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:422
    }
    mem2 = (struct mem *)&ram[ptr2];
  6e:	1842      	adds	r2, r0, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:423
    mem2->used = 0;
  70:	2300      	movs	r3, #0
  72:	7113      	strb	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:425
    /* restore the next pointer */
    mem2->next = next;
  74:	f820 c001 	strh.w	ip, [r0, r1]
  78:	e012      	b.n	a0 <mem_realloc+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:437
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  7a:	f102 0314 	add.w	r3, r2, #20	; 0x14
  7e:	4563      	cmp	r3, ip
  80:	d818      	bhi.n	b4 <mem_realloc+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:445
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  82:	f105 0308 	add.w	r3, r5, #8	; 0x8
  86:	18d3      	adds	r3, r2, r3
  88:	b299      	uxth	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:447
    mem2 = (struct mem *)&ram[ptr2];
    if (mem2 < lfree) {
  8a:	f8d8 3c40 	ldr.w	r3, [r8, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:446
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)&ram[ptr2];
  8e:	1842      	adds	r2, r0, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:447
    if (mem2 < lfree) {
  90:	429a      	cmp	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:448
      lfree = mem2;
  92:	bf38      	it	cc
  94:	f8c8 2c40 	strcc.w	r2, [r8, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:450
    }
    mem2->used = 0;
  98:	2300      	movs	r3, #0
  9a:	7113      	strb	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:451
    mem2->next = mem->next;
  9c:	8833      	ldrh	r3, [r6, #0]
  9e:	5243      	strh	r3, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:453
    mem2->prev = ptr;
    mem->next = ptr2;
  a0:	8031      	strh	r1, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:452
    if (mem2 < lfree) {
      lfree = mem2;
    }
    mem2->used = 0;
    mem2->next = mem->next;
    mem2->prev = ptr;
  a2:	8055      	strh	r5, [r2, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:454
    mem->next = ptr2;
    if (mem2->next != MEM_SIZE_ALIGNED) {
  a4:	5a42      	ldrh	r2, [r0, r1]
  a6:	f5b2 4fa0 	cmp.w	r2, #20480	; 0x5000
  aa:	d003      	beq.n	b4 <mem_realloc+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:455
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  ac:	1883      	adds	r3, r0, r2
  ae:	8059      	strh	r1, [r3, #2]
  b0:	e000      	b.n	b4 <mem_realloc+0xb4>
  b2:	2700      	movs	r7, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:470
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  b4:	4638      	mov	r0, r7
  b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  ba:	46c0      	nop			(mov r8, r8)
  bc:	000043e0 	.word	0x000043e0
Disassembly of section .text.mem_malloc:

00000000 <mem_malloc>:
mem_malloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:483
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:491
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
   2:	2800      	cmp	r0, #0
   4:	d04d      	beq.n	a2 <mem_malloc+0xa2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:497
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
   6:	1cc3      	adds	r3, r0, #3
   8:	f64f 71fc 	movw	r1, #65532	; 0xfffc
   c:	ea03 0101 	and.w	r1, r3, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:499

  if(size < MIN_SIZE_ALIGNED) {
  10:	290b      	cmp	r1, #11
  12:	d801      	bhi.n	18 <mem_malloc+0x18>
  14:	210c      	movs	r1, #12
  16:	e002      	b.n	1e <mem_malloc+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:504
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  18:	f5b1 4fa0 	cmp.w	r1, #20480	; 0x5000
  1c:	d841      	bhi.n	a2 <mem_malloc+0xa2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:520
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  1e:	4b22      	ldr	r3, [pc, #136]	(a8 <mem_malloc+0xa8>)
  20:	f8d3 7c40 	ldr.w	r7, [r3, #3136]
  24:	f8d3 4c34 	ldr.w	r4, [r3, #3124]
  28:	1b3b      	subs	r3, r7, r4
  2a:	b29a      	uxth	r2, r3
  2c:	e035      	b.n	9a <mem_malloc+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:522
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  2e:	18a0      	adds	r0, r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:534
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  30:	7906      	ldrb	r6, [r0, #4]
  32:	2e00      	cmp	r6, #0
  34:	d130      	bne.n	98 <mem_malloc+0x98>
  36:	5aa5      	ldrh	r5, [r4, r2]
  38:	f1a5 0308 	sub.w	r3, r5, #8	; 0x8
  3c:	ebc2 0c03 	rsb	ip, r2, r3
  40:	458c      	cmp	ip, r1
  42:	d329      	bcc.n	98 <mem_malloc+0x98>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:539
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  44:	f101 0314 	add.w	r3, r1, #20	; 0x14
  48:	459c      	cmp	ip, r3
  4a:	d311      	bcc.n	70 <mem_malloc+0x70>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:550
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  4c:	f101 0308 	add.w	r3, r1, #8	; 0x8
  50:	18d3      	adds	r3, r2, r3
  52:	b299      	uxth	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:552
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  54:	1863      	adds	r3, r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:553
          mem2->used = 0;
  56:	711e      	strb	r6, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:554
          mem2->next = mem->next;
  58:	5265      	strh	r5, [r4, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:555
          mem2->prev = ptr;
  5a:	805a      	strh	r2, [r3, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:557
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  5c:	8001      	strh	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:558
          mem->used = 1;
  5e:	2301      	movs	r3, #1
  60:	7103      	strb	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:560

          if (mem2->next != MEM_SIZE_ALIGNED) {
  62:	5a63      	ldrh	r3, [r4, r1]
  64:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
  68:	d004      	beq.n	74 <mem_malloc+0x74>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:561
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  6a:	18e3      	adds	r3, r4, r3
  6c:	8059      	strh	r1, [r3, #2]
  6e:	e001      	b.n	74 <mem_malloc+0x74>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:572
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  70:	2301      	movs	r3, #1
  72:	7103      	strb	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:576
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  74:	42b8      	cmp	r0, r7
  76:	d10d      	bne.n	94 <mem_malloc+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:578
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  78:	4b0b      	ldr	r3, [pc, #44]	(a8 <mem_malloc+0xa8>)
  7a:	4602      	mov	r2, r0
  7c:	f8d3 1c38 	ldr.w	r1, [r3, #3128]
  80:	e001      	b.n	86 <mem_malloc+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:582
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  82:	8813      	ldrh	r3, [r2, #0]
  84:	18e2      	adds	r2, r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:578
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  86:	7913      	ldrb	r3, [r2, #4]
  88:	b10b      	cbz	r3, 8e <mem_malloc+0x8e>
  8a:	428a      	cmp	r2, r1
  8c:	d1f9      	bne.n	82 <mem_malloc+0x82>
  8e:	4b06      	ldr	r3, [pc, #24]	(a8 <mem_malloc+0xa8>)
  90:	f8c3 2c40 	str.w	r2, [r3, #3136]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:595
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  94:	3008      	adds	r0, #8
  96:	e005      	b.n	a4 <mem_malloc+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:521

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  98:	8802      	ldrh	r2, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:520
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  9a:	f5c1 43a0 	rsb	r3, r1, #20480	; 0x5000
  9e:	429a      	cmp	r2, r3
  a0:	dbc5      	blt.n	2e <mem_malloc+0x2e>
  a2:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:607
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  a6:	46c0      	nop			(mov r8, r8)
  a8:	000043e0 	.word	0x000043e0
Disassembly of section .text.mem_calloc:

00000000 <mem_calloc>:
mem_calloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:621
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:625
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
   2:	fb00 f401 	mul.w	r4, r0, r1
   6:	b2a0      	uxth	r0, r4
   8:	f7ff fffe 	bl	0 <mem_calloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:626
  if (p) {
   c:	4605      	mov	r5, r0
   e:	b118      	cbz	r0, 18 <mem_calloc+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:628
    /* zero the memory */
    memset(p, 0, count * size);
  10:	2100      	movs	r1, #0
  12:	4622      	mov	r2, r4
  14:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/mem.c:631
  }
  return p;
}
  18:	4628      	mov	r0, r5
  1a:	bd70      	pop	{r4, r5, r6, pc}
