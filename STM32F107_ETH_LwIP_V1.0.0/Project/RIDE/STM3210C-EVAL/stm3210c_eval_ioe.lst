
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm3210c_eval_ioe.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm3210c_eval_ioe.o

Disassembly of section .text.delay:

00000000 <delay>:
delay():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1472
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void delay(__IO uint32_t nCount)
{
   0:	b084      	sub	sp, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1473
  __IO uint32_t index = 0; 
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1472
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void delay(__IO uint32_t nCount)
{
   4:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1473
  __IO uint32_t index = 0; 
   6:	9303      	str	r3, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1474
  for(index = (100000 * nCount); index != 0; index--)
   8:	9a01      	ldr	r2, [sp, #4]
   a:	4b05      	ldr	r3, [pc, #20]	(20 <delay+0x20>)
   c:	4353      	muls	r3, r2
   e:	e001      	b.n	14 <delay+0x14>
  10:	9b03      	ldr	r3, [sp, #12]
  12:	3b01      	subs	r3, #1
  14:	9303      	str	r3, [sp, #12]
  16:	9b03      	ldr	r3, [sp, #12]
  18:	2b00      	cmp	r3, #0
  1a:	d1f9      	bne.n	10 <delay+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1477
  {
  }
}
  1c:	b004      	add	sp, #16
  1e:	4770      	bx	lr
  20:	000186a0 	.word	0x000186a0
Disassembly of section .text.IOE_I2C_Config:

00000000 <IOE_I2C_Config>:
IOE_I2C_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1413
  * @brief  Configure the I2C Peripheral used to communicate with IO_Expanders.
  * @param  None
  * @retval None
  */
static void IOE_I2C_Config(void)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1417
  I2C_InitTypeDef I2C_InitStructure;
  
  /* IOE_I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   2:	2300      	movs	r3, #0
   4:	f8ad 3004 	strh.w	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1419
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
   8:	f8ad 3008 	strh.w	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1420
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  10:	f8ad 300a 	strh.w	r3, [sp, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1422
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = IOE_I2C_SPEED;
  14:	4b08      	ldr	r3, [pc, #32]	(38 <IOE_I2C_Config+0x38>)
  16:	a904      	add	r1, sp, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1418
{
  I2C_InitTypeDef I2C_InitStructure;
  
  /* IOE_I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  18:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  1c:	f8ad 2006 	strh.w	r2, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1422
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  I2C_InitStructure.I2C_ClockSpeed = IOE_I2C_SPEED;
  20:	f841 3d10 	str.w	r3, [r1, #-16]!
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1421
  /* IOE_I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  24:	f44f 4280 	mov.w	r2, #16384	; 0x4000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1424
  I2C_InitStructure.I2C_ClockSpeed = IOE_I2C_SPEED;
  
  I2C_Init(IOE_I2C, &I2C_InitStructure);
  28:	4804      	ldr	r0, [pc, #16]	(3c <IOE_I2C_Config+0x3c>)
  2a:	4669      	mov	r1, sp
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1421
  /* IOE_I2C configuration */
  I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  I2C_InitStructure.I2C_OwnAddress1 = 0x00;
  I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  2c:	f8ad 200c 	strh.w	r2, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1424
  I2C_InitStructure.I2C_ClockSpeed = IOE_I2C_SPEED;
  
  I2C_Init(IOE_I2C, &I2C_InitStructure);
  30:	f7ff fffe 	bl	0 <I2C_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1425
}
  34:	b005      	add	sp, #20
  36:	bd00      	pop	{pc}
  38:	00061a80 	.word	0x00061a80
  3c:	40005400 	.word	0x40005400
Disassembly of section .text.I2C_ReadDataBuffer:

00000000 <I2C_ReadDataBuffer>:
I2C_ReadDataBuffer():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1201
  *         or IOE_2_ADDR. 
  * @param  RegisterAddr: The target register adress (between 00x and 0x24)
  * @retval : The value of the read register (0xAA if Timout occured)   
  */
uint32_t I2C_ReadDataBuffer(uint8_t DeviceAddr, uint32_t RegisterAddr)
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1211
  Buffer[1] = 0; 
  Buffer[2] = 0; 
  Buffer[3] = 0;   
  
  /* Disable the I2C1 peripheral  */
  I2C_Cmd(I2C1, DISABLE);
   6:	484d      	ldr	r0, [pc, #308]	(13c <I2C_ReadDataBuffer+0x13c>)
   8:	2100      	movs	r1, #0
   a:	f7ff fffe 	bl	0 <I2C_Cmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1214

  /* Reset all I2C2 registers */
  I2C_SoftwareResetCmd(I2C1, ENABLE);
   e:	484b      	ldr	r0, [pc, #300]	(13c <I2C_ReadDataBuffer+0x13c>)
  10:	2101      	movs	r1, #1
  12:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1215
  I2C_SoftwareResetCmd(I2C1, DISABLE);
  16:	4849      	ldr	r0, [pc, #292]	(13c <I2C_ReadDataBuffer+0x13c>)
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1218

  /* Configure the I2C peripheral */
  IOE_I2C_Config();
  1e:	f7ff fffe 	bl	0 <I2C_ReadDataBuffer>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1221
  
  /* Enable the I2C peripheral */
  I2C_GenerateSTART(I2C1, ENABLE);
  22:	4846      	ldr	r0, [pc, #280]	(13c <I2C_ReadDataBuffer+0x13c>)
  24:	2101      	movs	r1, #1
  26:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1223
 
  TimeOut = TIMEOUT_MAX;
  2a:	4b45      	ldr	r3, [pc, #276]	(140 <I2C_ReadDataBuffer+0x140>)
  2c:	f640 72ff 	movw	r2, #4095	; 0xfff
  30:	601a      	str	r2, [r3, #0]
  32:	e005      	b.n	40 <I2C_ReadDataBuffer+0x40>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1228
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) 
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  34:	4b42      	ldr	r3, [pc, #264]	(140 <I2C_ReadDataBuffer+0x140>)
  36:	6819      	ldr	r1, [r3, #0]
  38:	1e4a      	subs	r2, r1, #1
  3a:	601a      	str	r2, [r3, #0]
  3c:	2900      	cmp	r1, #0
  3e:	d070      	beq.n	122 <I2C_ReadDataBuffer+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1226
  I2C_GenerateSTART(I2C1, ENABLE);
 
  TimeOut = TIMEOUT_MAX;
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) 
  40:	483e      	ldr	r0, [pc, #248]	(13c <I2C_ReadDataBuffer+0x13c>)
  42:	4940      	ldr	r1, [pc, #256]	(144 <I2C_ReadDataBuffer+0x144>)
  44:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  48:	2800      	cmp	r0, #0
  4a:	d0f3      	beq.n	34 <I2C_ReadDataBuffer+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1232
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
   
  /* Send device address for write */
  I2C_Send7bitAddress(I2C1, DeviceAddr, I2C_Direction_Transmitter);
  4c:	483b      	ldr	r0, [pc, #236]	(13c <I2C_ReadDataBuffer+0x13c>)
  4e:	4629      	mov	r1, r5
  50:	2200      	movs	r2, #0
  52:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
  56:	e005      	b.n	64 <I2C_ReadDataBuffer+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1237
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  58:	4b39      	ldr	r3, [pc, #228]	(140 <I2C_ReadDataBuffer+0x140>)
  5a:	6819      	ldr	r1, [r3, #0]
  5c:	1e4a      	subs	r2, r1, #1
  5e:	601a      	str	r2, [r3, #0]
  60:	2900      	cmp	r1, #0
  62:	d05e      	beq.n	122 <I2C_ReadDataBuffer+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1235
   
  /* Send device address for write */
  I2C_Send7bitAddress(I2C1, DeviceAddr, I2C_Direction_Transmitter);
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))  
  64:	4835      	ldr	r0, [pc, #212]	(13c <I2C_ReadDataBuffer+0x13c>)
  66:	4938      	ldr	r1, [pc, #224]	(148 <I2C_ReadDataBuffer+0x148>)
  68:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  6c:	2800      	cmp	r0, #0
  6e:	d0f3      	beq.n	58 <I2C_ReadDataBuffer+0x58>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1241
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Clear EV6 by setting again the PE bit */
  I2C_Cmd(I2C1, ENABLE);
  70:	2101      	movs	r1, #1
  72:	4832      	ldr	r0, [pc, #200]	(13c <I2C_ReadDataBuffer+0x13c>)
  74:	f7ff fffe 	bl	0 <I2C_Cmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1244
  
  /* Send the device's internal address to write to */
  I2C_SendData(I2C1, RegisterAddr);  
  78:	4830      	ldr	r0, [pc, #192]	(13c <I2C_ReadDataBuffer+0x13c>)
  7a:	b2e1      	uxtb	r1, r4
  7c:	f7ff fffe 	bl	0 <I2C_SendData>
  80:	e005      	b.n	8e <I2C_ReadDataBuffer+0x8e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1249
  
  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) 
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  82:	4b2f      	ldr	r3, [pc, #188]	(140 <I2C_ReadDataBuffer+0x140>)
  84:	6819      	ldr	r1, [r3, #0]
  86:	1e4a      	subs	r2, r1, #1
  88:	601a      	str	r2, [r3, #0]
  8a:	2900      	cmp	r1, #0
  8c:	d049      	beq.n	122 <I2C_ReadDataBuffer+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1247
  
  /* Send the device's internal address to write to */
  I2C_SendData(I2C1, RegisterAddr);  
  
  /* Test on EV8 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) 
  8e:	482b      	ldr	r0, [pc, #172]	(13c <I2C_ReadDataBuffer+0x13c>)
  90:	492e      	ldr	r1, [pc, #184]	(14c <I2C_ReadDataBuffer+0x14c>)
  92:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  96:	2800      	cmp	r0, #0
  98:	d0f3      	beq.n	82 <I2C_ReadDataBuffer+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1253
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Send STRAT condition a second time */  
  I2C_GenerateSTART(I2C1, ENABLE);
  9a:	4828      	ldr	r0, [pc, #160]	(13c <I2C_ReadDataBuffer+0x13c>)
  9c:	2101      	movs	r1, #1
  9e:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
  a2:	e005      	b.n	b0 <I2C_ReadDataBuffer+0xb0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1258
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) 
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  a4:	4b26      	ldr	r3, [pc, #152]	(140 <I2C_ReadDataBuffer+0x140>)
  a6:	6819      	ldr	r1, [r3, #0]
  a8:	1e4a      	subs	r2, r1, #1
  aa:	601a      	str	r2, [r3, #0]
  ac:	2900      	cmp	r1, #0
  ae:	d038      	beq.n	122 <I2C_ReadDataBuffer+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1256
  
  /* Send STRAT condition a second time */  
  I2C_GenerateSTART(I2C1, ENABLE);
  
  /* Test on EV5 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) 
  b0:	4822      	ldr	r0, [pc, #136]	(13c <I2C_ReadDataBuffer+0x13c>)
  b2:	4924      	ldr	r1, [pc, #144]	(144 <I2C_ReadDataBuffer+0x144>)
  b4:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  b8:	2800      	cmp	r0, #0
  ba:	d0f3      	beq.n	a4 <I2C_ReadDataBuffer+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1262
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Send EEPROM address for read */
  I2C_Send7bitAddress(I2C1, DeviceAddr, I2C_Direction_Receiver);
  bc:	481f      	ldr	r0, [pc, #124]	(13c <I2C_ReadDataBuffer+0x13c>)
  be:	4629      	mov	r1, r5
  c0:	2201      	movs	r2, #1
  c2:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
  c6:	e004      	b.n	d2 <I2C_ReadDataBuffer+0xd2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1267
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) 
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  c8:	4b1d      	ldr	r3, [pc, #116]	(140 <I2C_ReadDataBuffer+0x140>)
  ca:	6819      	ldr	r1, [r3, #0]
  cc:	1e4a      	subs	r2, r1, #1
  ce:	601a      	str	r2, [r3, #0]
  d0:	b339      	cbz	r1, 122 <I2C_ReadDataBuffer+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1265
  
  /* Send EEPROM address for read */
  I2C_Send7bitAddress(I2C1, DeviceAddr, I2C_Direction_Receiver);
  
  /* Test on EV6 and clear it */
  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) 
  d2:	481a      	ldr	r0, [pc, #104]	(13c <I2C_ReadDataBuffer+0x13c>)
  d4:	491e      	ldr	r1, [pc, #120]	(150 <I2C_ReadDataBuffer+0x150>)
  d6:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  da:	2800      	cmp	r0, #0
  dc:	d0f4      	beq.n	c8 <I2C_ReadDataBuffer+0xc8>
  de:	e022      	b.n	126 <I2C_ReadDataBuffer+0x126>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1273
  }
  
  /* While there is data to be read */
  while(idx)  
  {
    if(idx == 1)
  e0:	2c01      	cmp	r4, #1
  e2:	d107      	bne.n	f4 <I2C_ReadDataBuffer+0xf4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1276
    {
      /* Disable Acknowledgement */
      I2C_AcknowledgeConfig(I2C1, DISABLE);
  e4:	4815      	ldr	r0, [pc, #84]	(13c <I2C_ReadDataBuffer+0x13c>)
  e6:	2100      	movs	r1, #0
  e8:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1279
      
      /* Send STOP Condition */
      I2C_GenerateSTOP(I2C1, ENABLE);
  ec:	4813      	ldr	r0, [pc, #76]	(13c <I2C_ReadDataBuffer+0x13c>)
  ee:	4621      	mov	r1, r4
  f0:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1283
    }
    
    /* Test on EV7 and clear it */
    if(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  f4:	4811      	ldr	r0, [pc, #68]	(13c <I2C_ReadDataBuffer+0x13c>)
  f6:	4917      	ldr	r1, [pc, #92]	(154 <I2C_ReadDataBuffer+0x154>)
  f8:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  fc:	2800      	cmp	r0, #0
  fe:	d0ef      	beq.n	e0 <I2C_ReadDataBuffer+0xe0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1286
    {      
      /* Read a byte from the EEPROM */
      Buffer[idx-1] = I2C_ReceiveData(I2C1);
 100:	480e      	ldr	r0, [pc, #56]	(13c <I2C_ReadDataBuffer+0x13c>)
 102:	f7ff fffe 	bl	0 <I2C_ReceiveData>
 106:	aa02      	add	r2, sp, #8
 108:	1913      	adds	r3, r2, r4
 10a:	f803 0c05 	strb.w	r0, [r3, #-5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1289
    
      /* Decrement the read bytes counter */
      idx--;        
 10e:	1e63      	subs	r3, r4, #1
 110:	b2dc      	uxtb	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1271
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* While there is data to be read */
  while(idx)  
 112:	2c00      	cmp	r4, #0
 114:	d1e4      	bne.n	e0 <I2C_ReadDataBuffer+0xe0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1294
      idx--;        
    }   
  }
  
  /* Enable Acknowledgement to be ready for another reception */
  I2C_AcknowledgeConfig(I2C1, ENABLE);
 116:	4809      	ldr	r0, [pc, #36]	(13c <I2C_ReadDataBuffer+0x13c>)
 118:	2101      	movs	r1, #1
 11a:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1297
  
  /* return a pointer to the buffer */
  return *(uint32_t *)Buffer;
 11e:	9801      	ldr	r0, [sp, #4]
 120:	e000      	b.n	124 <I2C_ReadDataBuffer+0x124>
 122:	2002      	movs	r0, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1298
}
 124:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1205
uint32_t I2C_ReadDataBuffer(uint8_t DeviceAddr, uint32_t RegisterAddr)
{
  uint8_t Buffer[4] , idx = 2;
  
  /* Initialize the buffer */
  Buffer[0] = 0; 
 126:	2300      	movs	r3, #0
 128:	f88d 3004 	strb.w	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1206
  Buffer[1] = 0; 
 12c:	f88d 3005 	strb.w	r3, [sp, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1207
  Buffer[2] = 0; 
 130:	f88d 3006 	strb.w	r3, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1208
  Buffer[3] = 0;   
 134:	f88d 3007 	strb.w	r3, [sp, #7]
 138:	2402      	movs	r4, #2
 13a:	e7db      	b.n	f4 <I2C_ReadDataBuffer+0xf4>
 13c:	40005400 	.word	0x40005400
 140:	00000000 	.word	0x00000000
 144:	00030001 	.word	0x00030001
 148:	00070082 	.word	0x00070082
 14c:	00070084 	.word	0x00070084
 150:	00030002 	.word	0x00030002
 154:	00030040 	.word	0x00030040
Disassembly of section .text.I2C_ReadDeviceRegister:

00000000 <I2C_ReadDeviceRegister>:
I2C_ReadDeviceRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1111
  *         or IOE_2_ADDR. 
  * @param  RegisterAddr: The target register adress (between 00x and 0x24)
  * @retval The value of the read register (0xAA if Timout occured)   
  */
uint8_t I2C_ReadDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
   4:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1115
  uint32_t tmp = 0;
  
  /* Disable the IOE_I2C peripheral  */
  I2C_Cmd(IOE_I2C, DISABLE);
   6:	4845      	ldr	r0, [pc, #276]	(11c <I2C_ReadDeviceRegister+0x11c>)
   8:	2100      	movs	r1, #0
   a:	f7ff fffe 	bl	0 <I2C_Cmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1118
  
  /* Reset all I2C2 registers */
  I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
   e:	4843      	ldr	r0, [pc, #268]	(11c <I2C_ReadDeviceRegister+0x11c>)
  10:	2101      	movs	r1, #1
  12:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1119
  I2C_SoftwareResetCmd(IOE_I2C, DISABLE);
  16:	4841      	ldr	r0, [pc, #260]	(11c <I2C_ReadDeviceRegister+0x11c>)
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1122
  
  /* Configure the I2C peripheral */
  IOE_I2C_Config();
  1e:	f7ff fffe 	bl	0 <I2C_ReadDeviceRegister>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1125
  
  /* Enable the I2C peripheral */
  I2C_GenerateSTART(IOE_I2C, ENABLE);
  22:	483e      	ldr	r0, [pc, #248]	(11c <I2C_ReadDeviceRegister+0x11c>)
  24:	2101      	movs	r1, #1
  26:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1127
 
  TimeOut = TIMEOUT_MAX;
  2a:	4b3d      	ldr	r3, [pc, #244]	(120 <I2C_ReadDeviceRegister+0x120>)
  2c:	f640 72ff 	movw	r2, #4095	; 0xfff
  30:	601a      	str	r2, [r3, #0]
  32:	e004      	b.n	3e <I2C_ReadDeviceRegister+0x3e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1131
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  34:	6822      	ldr	r2, [r4, #0]
  36:	1e53      	subs	r3, r2, #1
  38:	6023      	str	r3, [r4, #0]
  3a:	2a00      	cmp	r2, #0
  3c:	d06b      	beq.n	116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1129
  /* Enable the I2C peripheral */
  I2C_GenerateSTART(IOE_I2C, ENABLE);
 
  TimeOut = TIMEOUT_MAX;
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  3e:	4837      	ldr	r0, [pc, #220]	(11c <I2C_ReadDeviceRegister+0x11c>)
  40:	4938      	ldr	r1, [pc, #224]	(124 <I2C_ReadDeviceRegister+0x124>)
  42:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  46:	4c36      	ldr	r4, [pc, #216]	(120 <I2C_ReadDeviceRegister+0x120>)
  48:	2800      	cmp	r0, #0
  4a:	d0f3      	beq.n	34 <I2C_ReadDeviceRegister+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1134
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  /* Disable Acknowledgement */
  I2C_AcknowledgeConfig(IOE_I2C, DISABLE);
  4c:	4833      	ldr	r0, [pc, #204]	(11c <I2C_ReadDeviceRegister+0x11c>)
  4e:	2100      	movs	r1, #0
  50:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1137
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
  54:	4831      	ldr	r0, [pc, #196]	(11c <I2C_ReadDeviceRegister+0x11c>)
  56:	4631      	mov	r1, r6
  58:	2200      	movs	r2, #0
  5a:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1139
  
  TimeOut = TIMEOUT_MAX;
  5e:	f640 73ff 	movw	r3, #4095	; 0xfff
  62:	6023      	str	r3, [r4, #0]
  64:	e005      	b.n	72 <I2C_ReadDeviceRegister+0x72>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1144
  /* Test on EV6 and clear it */
  
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  66:	4b2e      	ldr	r3, [pc, #184]	(120 <I2C_ReadDeviceRegister+0x120>)
  68:	6819      	ldr	r1, [r3, #0]
  6a:	1e4a      	subs	r2, r1, #1
  6c:	601a      	str	r2, [r3, #0]
  6e:	2900      	cmp	r1, #0
  70:	d051      	beq.n	116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1142
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
  
  TimeOut = TIMEOUT_MAX;
  /* Test on EV6 and clear it */
  
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
  72:	482a      	ldr	r0, [pc, #168]	(11c <I2C_ReadDeviceRegister+0x11c>)
  74:	492c      	ldr	r1, [pc, #176]	(128 <I2C_ReadDeviceRegister+0x128>)
  76:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  7a:	2800      	cmp	r0, #0
  7c:	d0f3      	beq.n	66 <I2C_ReadDeviceRegister+0x66>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1148
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Transmit the first address for r/w operations */
  I2C_SendData(IOE_I2C, RegisterAddr);
  7e:	4827      	ldr	r0, [pc, #156]	(11c <I2C_ReadDeviceRegister+0x11c>)
  80:	4629      	mov	r1, r5
  82:	f7ff fffe 	bl	0 <I2C_SendData>
  86:	e005      	b.n	94 <I2C_ReadDeviceRegister+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1153
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  88:	4b25      	ldr	r3, [pc, #148]	(120 <I2C_ReadDeviceRegister+0x120>)
  8a:	6819      	ldr	r1, [r3, #0]
  8c:	1e4a      	subs	r2, r1, #1
  8e:	601a      	str	r2, [r3, #0]
  90:	2900      	cmp	r1, #0
  92:	d040      	beq.n	116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1151
  
  /* Transmit the first address for r/w operations */
  I2C_SendData(IOE_I2C, RegisterAddr);
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  94:	4821      	ldr	r0, [pc, #132]	(11c <I2C_ReadDeviceRegister+0x11c>)
  96:	4925      	ldr	r1, [pc, #148]	(12c <I2C_ReadDeviceRegister+0x12c>)
  98:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  9c:	2800      	cmp	r0, #0
  9e:	d0f3      	beq.n	88 <I2C_ReadDeviceRegister+0x88>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1156
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  /* Regenerate a start condition */
  I2C_GenerateSTART(IOE_I2C, ENABLE);
  a0:	481e      	ldr	r0, [pc, #120]	(11c <I2C_ReadDeviceRegister+0x11c>)
  a2:	2101      	movs	r1, #1
  a4:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
  a8:	e005      	b.n	b6 <I2C_ReadDeviceRegister+0xb6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1161
  
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  aa:	4b1d      	ldr	r3, [pc, #116]	(120 <I2C_ReadDeviceRegister+0x120>)
  ac:	6819      	ldr	r1, [r3, #0]
  ae:	1e4a      	subs	r2, r1, #1
  b0:	601a      	str	r2, [r3, #0]
  b2:	2900      	cmp	r1, #0
  b4:	d02f      	beq.n	116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1159
  }
  /* Regenerate a start condition */
  I2C_GenerateSTART(IOE_I2C, ENABLE);
  
  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  b6:	4819      	ldr	r0, [pc, #100]	(11c <I2C_ReadDeviceRegister+0x11c>)
  b8:	491a      	ldr	r1, [pc, #104]	(124 <I2C_ReadDeviceRegister+0x124>)
  ba:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  be:	2800      	cmp	r0, #0
  c0:	d0f3      	beq.n	aa <I2C_ReadDeviceRegister+0xaa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1165
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
  c2:	4816      	ldr	r0, [pc, #88]	(11c <I2C_ReadDeviceRegister+0x11c>)
  c4:	4631      	mov	r1, r6
  c6:	2201      	movs	r2, #1
  c8:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
  cc:	e004      	b.n	d8 <I2C_ReadDeviceRegister+0xd8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1170
  
  /* Test on EV6 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  ce:	4b14      	ldr	r3, [pc, #80]	(120 <I2C_ReadDeviceRegister+0x120>)
  d0:	6819      	ldr	r1, [r3, #0]
  d2:	1e4a      	subs	r2, r1, #1
  d4:	601a      	str	r2, [r3, #0]
  d6:	b1f1      	cbz	r1, 116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1168
  
  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Receiver);
  
  /* Test on EV6 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
  d8:	4810      	ldr	r0, [pc, #64]	(11c <I2C_ReadDeviceRegister+0x11c>)
  da:	4915      	ldr	r1, [pc, #84]	(130 <I2C_ReadDeviceRegister+0x130>)
  dc:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  e0:	2800      	cmp	r0, #0
  e2:	d0f4      	beq.n	ce <I2C_ReadDeviceRegister+0xce>
  e4:	e004      	b.n	f0 <I2C_ReadDeviceRegister+0xf0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1176
  }
  
  /* Test on EV7 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  e6:	4b0e      	ldr	r3, [pc, #56]	(120 <I2C_ReadDeviceRegister+0x120>)
  e8:	6819      	ldr	r1, [r3, #0]
  ea:	1e4a      	subs	r2, r1, #1
  ec:	601a      	str	r2, [r3, #0]
  ee:	b191      	cbz	r1, 116 <I2C_ReadDeviceRegister+0x116>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1174
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Test on EV7 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_RECEIVED))
  f0:	480a      	ldr	r0, [pc, #40]	(11c <I2C_ReadDeviceRegister+0x11c>)
  f2:	4910      	ldr	r1, [pc, #64]	(134 <I2C_ReadDeviceRegister+0x134>)
  f4:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  f8:	2800      	cmp	r0, #0
  fa:	d0f4      	beq.n	e6 <I2C_ReadDeviceRegister+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1180
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* End the configuration sequence */
  I2C_GenerateSTOP(IOE_I2C, ENABLE);
  fc:	2101      	movs	r1, #1
  fe:	4807      	ldr	r0, [pc, #28]	(11c <I2C_ReadDeviceRegister+0x11c>)
 100:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1183
  
  /* Load the register value */
  tmp = I2C_ReceiveData(IOE_I2C);
 104:	4805      	ldr	r0, [pc, #20]	(18 <I2C_ReceiveData+0x18>)
 106:	f7ff fffe 	bl	0 <I2C_ReceiveData>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1186
  
  /* Enable Acknowledgement */
  I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
 10a:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1183
  
  /* End the configuration sequence */
  I2C_GenerateSTOP(IOE_I2C, ENABLE);
  
  /* Load the register value */
  tmp = I2C_ReceiveData(IOE_I2C);
 10c:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1186
  
  /* Enable Acknowledgement */
  I2C_AcknowledgeConfig(IOE_I2C, ENABLE);
 10e:	4803      	ldr	r0, [pc, #12]	(11c <I2C_ReadDeviceRegister+0x11c>)
 110:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
 114:	e000      	b.n	118 <I2C_ReadDeviceRegister+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1189
  
  /* Return the read value */
  return tmp;
 116:	2402      	movs	r4, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1190
}
 118:	4620      	mov	r0, r4
 11a:	bd70      	pop	{r4, r5, r6, pc}
 11c:	40005400 	.word	0x40005400
 120:	00000000 	.word	0x00000000
 124:	00030001 	.word	0x00030001
 128:	00070082 	.word	0x00070082
 12c:	00070084 	.word	0x00070084
 130:	00030002 	.word	0x00030002
 134:	00030040 	.word	0x00030040
Disassembly of section .text.IOE_ReadID:

00000000 <IOE_ReadID>:
IOE_ReadID():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:623
  * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
  *         or IOE_2_ADDR.
  * @retval The Device ID (two bytes).
  */
uint16_t IOE_ReadID(uint8_t DeviceAddr)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:627
  uint16_t tmp = 0;

  /* Read device ID  */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
   2:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:623
  * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
  *         or IOE_2_ADDR.
  * @retval The Device ID (two bytes).
  */
uint16_t IOE_ReadID(uint8_t DeviceAddr)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:627
  uint16_t tmp = 0;

  /* Read device ID  */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
   6:	f7ff fffe 	bl	0 <IOE_ReadID>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:629
  tmp = (uint32_t)(tmp << 8);
  tmp |= (uint32_t)I2C_ReadDeviceRegister(DeviceAddr, 1);
   a:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:628
{
  uint16_t tmp = 0;

  /* Read device ID  */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
  tmp = (uint32_t)(tmp << 8);
   c:	0204      	lsls	r4, r0, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:629
  tmp |= (uint32_t)I2C_ReadDeviceRegister(DeviceAddr, 1);
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <IOE_ReadID>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:628
{
  uint16_t tmp = 0;

  /* Read device ID  */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, 0);
  tmp = (uint32_t)(tmp << 8);
  14:	b2a4      	uxth	r4, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:629
  tmp |= (uint32_t)I2C_ReadDeviceRegister(DeviceAddr, 1);
  16:	4304      	orrs	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:633
  
  /* Return the ID */
  return (uint16_t)tmp;
}
  18:	b2a0      	uxth	r0, r4
  1a:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_IsOperational:

00000000 <IOE_IsOperational>:
IOE_IsOperational():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:575
  * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
  *         or IOE_2_ADDR.
  * @retval IOE_OK if IOE is operational. Other value if failure.
  */
uint8_t IOE_IsOperational(uint8_t DeviceAddr)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:577
  /* Return Error if the ID is not correct */
  if( IOE_ReadID(DeviceAddr) != (uint16_t)STMPE811_ID )
   2:	f7ff fffe 	bl	0 <IOE_IsOperational>
   6:	f640 0311 	movw	r3, #2065	; 0x811
   a:	4298      	cmp	r0, r3
   c:	d101      	bne.n	12 <IOE_IsOperational+0x12>
   e:	2000      	movs	r0, #0
  10:	e005      	b.n	1e <IOE_IsOperational+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:580
  {
    /* Check if a Timeout occured */
    if (TimeOut == 0)
  12:	4b03      	ldr	r3, [pc, #12]	(20 <IOE_IsOperational+0x20>)
  14:	681b      	ldr	r3, [r3, #0]
  16:	2b00      	cmp	r3, #0
  18:	bf0c      	ite	eq
  1a:	2002      	moveq	r0, #2
  1c:	2001      	movne	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:593
  } 
  else 
  {
    return IOE_OK; /* ID is correct */
  }
}
  1e:	bd10      	pop	{r4, pc}
  20:	00000000 	.word	0x00000000
Disassembly of section .text.IOE_GetIOITStatus:

00000000 <IOE_GetIOITStatus>:
IOE_GetIOITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:525
  * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
  *         from 0 to 7.             
  * @retval Status of the checked flag. Could be SET or RESET.
  */
FlagStatus IOE_GetIOITStatus(uint8_t DeviceAddr, uint8_t IO_IT)
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:529
  uint8_t tmp = 0;
 
  /* get the Interrupt status */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA);
   4:	210d      	movs	r1, #13
   6:	f7ff fffe 	bl	0 <IOE_GetIOITStatus>
   a:	4204      	tst	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:539
  }
  else
  {
    return RESET;
  }
}
   c:	bf0c      	ite	eq
   e:	2000      	moveq	r0, #0
  10:	2001      	movne	r0, #1
  12:	bd10      	pop	{r4, pc}
Disassembly of section .text.IOE_GetGITStatus:

00000000 <IOE_GetGITStatus>:
IOE_GetGITStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:475
  *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt      
  * @retval Status of the checked flag. Could be SET or RESET.
  */
FlagStatus IOE_GetGITStatus(uint8_t DeviceAddr, uint8_t Global_IT)
{
   0:	b513      	push	{r0, r1, r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:476
  __IO uint8_t tmp = 0;
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:475
  *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt      
  * @retval Status of the checked flag. Could be SET or RESET.
  */
FlagStatus IOE_GetGITStatus(uint8_t DeviceAddr, uint8_t Global_IT)
{
   4:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:479
  __IO uint8_t tmp = 0;
 
  /* get the Interrupt status */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_STA);
   6:	210b      	movs	r1, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:476
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt      
  * @retval Status of the checked flag. Could be SET or RESET.
  */
FlagStatus IOE_GetGITStatus(uint8_t DeviceAddr, uint8_t Global_IT)
{
  __IO uint8_t tmp = 0;
   8:	f88d 3007 	strb.w	r3, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:479
 
  /* get the Interrupt status */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_STA);
   c:	f7ff fffe 	bl	0 <IOE_GetGITStatus>
  10:	f88d 0007 	strb.w	r0, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:481
  
  if ((tmp & (uint8_t)Global_IT) != 0)
  14:	f89d 3007 	ldrb.w	r3, [sp, #7]
  18:	421c      	tst	r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:489
  }
  else
  {
    return RESET;
  }
}
  1a:	bf0c      	ite	eq
  1c:	2000      	moveq	r0, #0
  1e:	2001      	movne	r0, #1
  20:	bd1c      	pop	{r2, r3, r4, pc}
  22:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_JoyStickGetState:

00000000 <IOE_JoyStickGetState>:
IOE_JoyStickGetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:363
  */
JOY_State_TypeDef IOE_JoyStickGetState(void)
{
  uint8_t tmp = 0;
  /* Read the status of all pins */
  tmp = (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_MP_STA);
   0:	2088      	movs	r0, #136
   2:	2112      	movs	r1, #18
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:360
  *   @arg  JOY_LEFT
  *   @arg  JOY_RIGHT
  *   @arg  JOY_UP
  */
JOY_State_TypeDef IOE_JoyStickGetState(void)
{
   4:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:363
  uint8_t tmp = 0;
  /* Read the status of all pins */
  tmp = (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_MP_STA);
   6:	f7ff fffe 	bl	0 <IOE_JoyStickGetState>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:366
   
  /* Check the pressed keys */
  if ((tmp & JOY_IO_NONE) == JOY_IO_NONE)
   a:	f000 03f8 	and.w	r3, r0, #248	; 0xf8
   e:	2bf8      	cmp	r3, #248
  10:	d018      	beq.n	44 <IOE_JoyStickGetState+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:370
  {
    return (JOY_State_TypeDef)JOY_NONE;
  }
  else if (!(tmp & JOY_IO_CENTER))
  12:	f010 0f80 	tst.w	r0, #128	; 0x80
  16:	d101      	bne.n	1c <IOE_JoyStickGetState+0x1c>
  18:	2001      	movs	r0, #1
  1a:	e014      	b.n	46 <IOE_JoyStickGetState+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:374
  {
    return (JOY_State_TypeDef)JOY_CENTER;
  }
  else if (!(tmp & JOY_IO_DOWN))
  1c:	f010 0f40 	tst.w	r0, #64	; 0x40
  20:	d101      	bne.n	26 <IOE_JoyStickGetState+0x26>
  22:	2002      	movs	r0, #2
  24:	e00f      	b.n	46 <IOE_JoyStickGetState+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:378
  {
    return (JOY_State_TypeDef)JOY_DOWN;
  }
  else if (!(tmp & JOY_IO_LEFT))
  26:	f010 0f20 	tst.w	r0, #32	; 0x20
  2a:	d101      	bne.n	30 <IOE_JoyStickGetState+0x30>
  2c:	2003      	movs	r0, #3
  2e:	e00a      	b.n	46 <IOE_JoyStickGetState+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:382
  {
    return (JOY_State_TypeDef)JOY_LEFT;
  }
  else if (!(tmp & JOY_IO_RIGHT))
  30:	f010 0f10 	tst.w	r0, #16	; 0x10
  34:	d101      	bne.n	3a <IOE_JoyStickGetState+0x3a>
  36:	2004      	movs	r0, #4
  38:	e005      	b.n	46 <IOE_JoyStickGetState+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:386
  {
    return (JOY_State_TypeDef)JOY_RIGHT;
  }
  else if (!(tmp & JOY_IO_UP))
  3a:	f010 0f08 	tst.w	r0, #8	; 0x8
  3e:	d101      	bne.n	44 <IOE_JoyStickGetState+0x44>
  40:	2005      	movs	r0, #5
  42:	e000      	b.n	46 <IOE_JoyStickGetState+0x46>
  44:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:394
  }
  else
  { 
    return (JOY_State_TypeDef)JOY_NONE;
  }
}
  46:	bd10      	pop	{r4, pc}
Disassembly of section .text.IOE_ReadIOPin:

00000000 <IOE_ReadIOPin>:
IOE_ReadIOPin():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:322
  */
uint8_t IOE_ReadIOPin(uint32_t IO_Pin)
{
  uint8_t DeviceAddr = 0;
  uint8_t tmp = 0;  
  if (IO_Pin & IO1_IN_ALL_PINS)
   0:	f010 0f0c 	tst.w	r0, #12	; 0xc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:319
  *   @arg  MEMS_INT2_PIN: MEMS interrupt line 2.
  *   @arg  JOY_IO_PINS: Joystick IO pins (use IOE_JoyStickGetState for these pins)  
  * @retval None
  */
uint8_t IOE_ReadIOPin(uint32_t IO_Pin)
{
   4:	b510      	push	{r4, lr}
   6:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:322
  uint8_t DeviceAddr = 0;
  uint8_t tmp = 0;  
  if (IO_Pin & IO1_IN_ALL_PINS)
   8:	d001      	beq.n	e <IOE_ReadIOPin+0xe>
   a:	2082      	movs	r0, #130
   c:	e005      	b.n	1a <IOE_ReadIOPin+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:326
  {
    DeviceAddr = IOE_1_ADDR;
  }
  else if (IO_Pin & IO2_IN_ALL_PINS)
   e:	f010 0ff8 	tst.w	r0, #248	; 0xf8
  12:	d101      	bne.n	18 <IOE_ReadIOPin+0x18>
  14:	2003      	movs	r0, #3
  16:	e009      	b.n	2c <IOE_ReadIOPin+0x2c>
  18:	2088      	movs	r0, #136
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:336
  {
    return PARAM_ERROR;
  }
  
  /* Get all the Pins status */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_MP_STA);
  1a:	2112      	movs	r1, #18
  1c:	f7ff fffe 	bl	0 <IOE_ReadIOPin>
  20:	4020      	ands	r0, r4
  22:	f010 0fff 	tst.w	r0, #255	; 0xff
  26:	bf0c      	ite	eq
  28:	2000      	moveq	r0, #0
  2a:	2001      	movne	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:345
  }  
  else 
  {
    return BitReset;
  }
}
  2c:	bd10      	pop	{r4, pc}
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.I2C_WriteDeviceRegister:

00000000 <I2C_WriteDeviceRegister>:
I2C_WriteDeviceRegister():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1025
  * @param  RegisterAddr: The target register adress
  * @param  RegisterValue: The target register value to be written 
  * @retval IOE_OK: if all operations are OK. Other value if error.
  */
uint8_t I2C_WriteDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr, uint8_t RegisterValue)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1029
  uint32_t read_verif = 0;

  /* Reset all I2C2 registers */
  I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
   6:	4830      	ldr	r0, [pc, #192]	(c8 <I2C_WriteDeviceRegister+0xc8>)
   8:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1025
  * @param  RegisterAddr: The target register adress
  * @param  RegisterValue: The target register value to be written 
  * @retval IOE_OK: if all operations are OK. Other value if error.
  */
uint8_t I2C_WriteDeviceRegister(uint8_t DeviceAddr, uint8_t RegisterAddr, uint8_t RegisterValue)
{
   a:	4616      	mov	r6, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1029
  uint32_t read_verif = 0;

  /* Reset all I2C2 registers */
  I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
   c:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1030
  I2C_SoftwareResetCmd(IOE_I2C, DISABLE);
  10:	2100      	movs	r1, #0
  12:	482d      	ldr	r0, [pc, #180]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  14:	f7ff fffe 	bl	0 <I2C_SoftwareResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1032

  TimeOut = TIMEOUT_MAX;
  18:	4b2c      	ldr	r3, [pc, #176]	(cc <I2C_WriteDeviceRegister+0xcc>)
  1a:	f640 72ff 	movw	r2, #4095	; 0xfff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1035

  /* Enable the IOE_I2C peripheral  */
  I2C_Cmd(IOE_I2C, ENABLE);
  1e:	2101      	movs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1032

  /* Reset all I2C2 registers */
  I2C_SoftwareResetCmd(IOE_I2C, ENABLE);
  I2C_SoftwareResetCmd(IOE_I2C, DISABLE);

  TimeOut = TIMEOUT_MAX;
  20:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1035

  /* Enable the IOE_I2C peripheral  */
  I2C_Cmd(IOE_I2C, ENABLE);
  22:	4829      	ldr	r0, [pc, #164]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  24:	f7ff fffe 	bl	0 <I2C_Cmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1038

  /* Configure the I2C peripheral */
  IOE_I2C_Config();
  28:	f7ff fffe 	bl	0 <I2C_WriteDeviceRegister>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1041

  /* Begin the config sequence */
  I2C_GenerateSTART(IOE_I2C, ENABLE);
  2c:	4826      	ldr	r0, [pc, #152]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  2e:	2101      	movs	r1, #1
  30:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
  34:	e005      	b.n	42 <I2C_WriteDeviceRegister+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1046

  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  36:	4b25      	ldr	r3, [pc, #148]	(cc <I2C_WriteDeviceRegister+0xcc>)
  38:	6819      	ldr	r1, [r3, #0]
  3a:	1e4a      	subs	r2, r1, #1
  3c:	601a      	str	r2, [r3, #0]
  3e:	2900      	cmp	r1, #0
  40:	d040      	beq.n	c4 <I2C_WriteDeviceRegister+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1044

  /* Begin the config sequence */
  I2C_GenerateSTART(IOE_I2C, ENABLE);

  /* Test on EV5 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_MODE_SELECT))
  42:	4821      	ldr	r0, [pc, #132]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  44:	4922      	ldr	r1, [pc, #136]	(d0 <I2C_WriteDeviceRegister+0xd0>)
  46:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  4a:	2800      	cmp	r0, #0
  4c:	d0f3      	beq.n	36 <I2C_WriteDeviceRegister+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1050
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }

  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
  4e:	481e      	ldr	r0, [pc, #120]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  50:	4621      	mov	r1, r4
  52:	2200      	movs	r2, #0
  54:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
  58:	e004      	b.n	64 <I2C_WriteDeviceRegister+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1055
  
  /* Test on EV6 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  5a:	6822      	ldr	r2, [r4, #0]
  5c:	1e53      	subs	r3, r2, #1
  5e:	6023      	str	r3, [r4, #0]
  60:	2a00      	cmp	r2, #0
  62:	d02f      	beq.n	c4 <I2C_WriteDeviceRegister+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1053

  /* Transmit the slave address and enable writing operation */
  I2C_Send7bitAddress(IOE_I2C, DeviceAddr, I2C_Direction_Transmitter);
  
  /* Test on EV6 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
  64:	4818      	ldr	r0, [pc, #96]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  66:	491b      	ldr	r1, [pc, #108]	(d4 <I2C_WriteDeviceRegister+0xd4>)
  68:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  6c:	4c17      	ldr	r4, [pc, #92]	(cc <I2C_WriteDeviceRegister+0xcc>)
  6e:	2800      	cmp	r0, #0
  70:	d0f3      	beq.n	5a <I2C_WriteDeviceRegister+0x5a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1059
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Transmit the first address for r/w operations */
  I2C_SendData(IOE_I2C, RegisterAddr);
  72:	4815      	ldr	r0, [pc, #84]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  74:	4629      	mov	r1, r5
  76:	f7ff fffe 	bl	0 <I2C_SendData>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1061
  
  TimeOut = TIMEOUT_MAX;
  7a:	f640 73ff 	movw	r3, #4095	; 0xfff
  7e:	6023      	str	r3, [r4, #0]
  80:	e004      	b.n	8c <I2C_WriteDeviceRegister+0x8c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1066
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  82:	4b12      	ldr	r3, [pc, #72]	(cc <I2C_WriteDeviceRegister+0xcc>)
  84:	6819      	ldr	r1, [r3, #0]
  86:	1e4a      	subs	r2, r1, #1
  88:	601a      	str	r2, [r3, #0]
  8a:	b1d9      	cbz	r1, c4 <I2C_WriteDeviceRegister+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1064
  I2C_SendData(IOE_I2C, RegisterAddr);
  
  TimeOut = TIMEOUT_MAX;
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  8c:	480e      	ldr	r0, [pc, #56]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  8e:	4912      	ldr	r1, [pc, #72]	(d8 <I2C_WriteDeviceRegister+0xd8>)
  90:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  94:	2800      	cmp	r0, #0
  96:	d0f4      	beq.n	82 <I2C_WriteDeviceRegister+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1070
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* Prepare the register value to be sent */
  I2C_SendData(IOE_I2C, RegisterValue);
  98:	480b      	ldr	r0, [pc, #44]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  9a:	4631      	mov	r1, r6
  9c:	f7ff fffe 	bl	0 <I2C_SendData>
  a0:	e004      	b.n	ac <I2C_WriteDeviceRegister+0xac>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1075
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  a2:	4b0a      	ldr	r3, [pc, #40]	(cc <I2C_WriteDeviceRegister+0xcc>)
  a4:	6819      	ldr	r1, [r3, #0]
  a6:	1e4a      	subs	r2, r1, #1
  a8:	601a      	str	r2, [r3, #0]
  aa:	b159      	cbz	r1, c4 <I2C_WriteDeviceRegister+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1073
  
  /* Prepare the register value to be sent */
  I2C_SendData(IOE_I2C, RegisterValue);
  
  /* Test on EV8 and clear it */
  while (!I2C_CheckEvent(IOE_I2C, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
  ac:	4806      	ldr	r0, [pc, #24]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  ae:	490a      	ldr	r1, [pc, #40]	(d8 <I2C_WriteDeviceRegister+0xd8>)
  b0:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  b4:	2800      	cmp	r0, #0
  b6:	d0f4      	beq.n	a2 <I2C_WriteDeviceRegister+0xa2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1079
  {
    if (TimeOut-- == 0) return IOE_TIEMOUT;
  }
  
  /* End the configuration sequence */
  I2C_GenerateSTOP(IOE_I2C, ENABLE);
  b8:	4803      	ldr	r0, [pc, #12]	(c8 <I2C_WriteDeviceRegister+0xc8>)
  ba:	2101      	movs	r1, #1
  bc:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  c0:	2000      	movs	r0, #0
  c2:	e000      	b.n	c6 <I2C_WriteDeviceRegister+0xc6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1100
    read_verif = 0;
  }
#endif
  
  /* Return the verifying value: 0 (Passed) or 1 (Failed) */
  return read_verif;
  c4:	2002      	movs	r0, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1101
}
  c6:	bd70      	pop	{r4, r5, r6, pc}
  c8:	40005400 	.word	0x40005400
  cc:	00000000 	.word	0x00000000
  d0:	00030001 	.word	0x00030001
  d4:	00070082 	.word	0x00070082
  d8:	00070084 	.word	0x00070084
Disassembly of section .text.IOE_ITOutConfig:

00000000 <IOE_ITOutConfig>:
IOE_ITOutConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:985
  *   @arg  Type_Level: Interrupt line is active in level model         
  *   @arg  Type_Edge: Interrupt line is active in edge model           
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_ITOutConfig(uint8_t Polarity, uint8_t Type)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:989
  uint8_t tmp = 0;
  
  /*  Get the register IOE_REG_INT_CTRL value */ 
  tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL);
   6:	2082      	movs	r0, #130
   8:	2109      	movs	r1, #9
   a:	f7ff fffe 	bl	0 <IOE_ITOutConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:995
  
  /* Mask the polarity and type bits */
  tmp &= ~(uint8_t)0x06;
    
  /* Modify the Interrupt Output line configuration */
  tmp |= (uint8_t)(Polarity | Type);
   e:	432c      	orrs	r4, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:992
  
  /*  Get the register IOE_REG_INT_CTRL value */ 
  tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL);
  
  /* Mask the polarity and type bits */
  tmp &= ~(uint8_t)0x06;
  10:	f000 02f9 	and.w	r2, r0, #249	; 0xf9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:998
    
  /* Modify the Interrupt Output line configuration */
  tmp |= (uint8_t)(Polarity | Type);
  
  /* Set the register */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_CTRL, tmp);
  14:	ea44 0202 	orr.w	r2, r4, r2
  18:	2109      	movs	r1, #9
  1a:	2082      	movs	r0, #130
  1c:	f7ff fffe 	bl	0 <IOE_ITOutConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1002
  
  
  /*  Get the register IOE_REG_INT_CTRL value */ 
  tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL);
  20:	2109      	movs	r1, #9
  22:	2088      	movs	r0, #136
  24:	f7ff fffe 	bl	0 <IOE_ITOutConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1004
  /* Mask the polarity and type bits */
  tmp &= ~(uint8_t)0x06;
  28:	f000 02f9 	and.w	r2, r0, #249	; 0xf9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1010
    
  /* Modify the Interrupt Output line configuration */
  tmp |= (uint8_t)(Polarity | Type);
  
  /* Set the register */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_INT_CTRL, tmp);  
  2c:	2109      	movs	r1, #9
  2e:	2088      	movs	r0, #136
  30:	ea44 0202 	orr.w	r2, r4, r2
  34:	f7ff fffe 	bl	0 <IOE_ITOutConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1014
  
  /* If all OK return IOE_OK */
  return IOE_OK;  
}
  38:	2000      	movs	r0, #0
  3a:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_IOEdgeConfig:

00000000 <IOE_IOEdgeConfig>:
IOE_IOEdgeConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:942
  * @param  Edge: The edge which will be detected. This parameter can be one or a
  *         a combination of follwing values: EDGE_FALLING and EDGE_RISING .
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOEdgeConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Edge)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:946
  uint8_t tmp1 = 0, tmp2 = 0;   
  
  /* Get the registers values */
  tmp1 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE);
   6:	2116      	movs	r1, #22
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:942
  * @param  Edge: The edge which will be detected. This parameter can be one or a
  *         a combination of follwing values: EDGE_FALLING and EDGE_RISING .
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOEdgeConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Edge)
{
   8:	4617      	mov	r7, r2
   a:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:946
  uint8_t tmp1 = 0, tmp2 = 0;   
  
  /* Get the registers values */
  tmp1 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE);
   c:	f7ff fffe 	bl	0 <IOE_IOEdgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:947
  tmp2 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE);
  10:	2115      	movs	r1, #21
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:946
uint8_t IOE_IOEdgeConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Edge)
{
  uint8_t tmp1 = 0, tmp2 = 0;   
  
  /* Get the registers values */
  tmp1 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE);
  12:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:947
  tmp2 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE);
  14:	4630      	mov	r0, r6
  16:	f7ff fffe 	bl	0 <IOE_IOEdgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:950

  /* Disable the Falling Edge */
  tmp1 &= ~(uint8_t)IO_Pin;
  1a:	43eb      	mvns	r3, r5
  1c:	b2db      	uxtb	r3, r3
  1e:	ea03 0204 	and.w	r2, r3, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:955
  /* Disable the Falling Edge */
  tmp2 &= ~(uint8_t)IO_Pin;

  /* Enable the Falling edge if selected */
  if (Edge & EDGE_FALLING)
  22:	f017 0f01 	tst.w	r7, #1	; 0x1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:952
  tmp2 = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE);

  /* Disable the Falling Edge */
  tmp1 &= ~(uint8_t)IO_Pin;
  /* Disable the Falling Edge */
  tmp2 &= ~(uint8_t)IO_Pin;
  26:	ea03 0400 	and.w	r4, r3, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:957

  /* Enable the Falling edge if selected */
  if (Edge & EDGE_FALLING)
  {
    tmp1 |= (uint8_t)IO_Pin;
  2a:	bf18      	it	ne
  2c:	432a      	orrne	r2, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:961
  }

  /* Enable the Rising edge if selected */
  if (Edge & EDGE_RISING)
  2e:	f017 0f02 	tst.w	r7, #2	; 0x2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:963
  {
    tmp2 |= (uint8_t)IO_Pin;
  32:	bf18      	it	ne
  34:	432c      	orrne	r4, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:967
  }

  /* Write back the registers values */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_FE, tmp1);
  36:	4630      	mov	r0, r6
  38:	2116      	movs	r1, #22
  3a:	f7ff fffe 	bl	0 <IOE_IOEdgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:968
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_RE, tmp2);
  3e:	4630      	mov	r0, r6
  40:	2115      	movs	r1, #21
  42:	4622      	mov	r2, r4
  44:	f7ff fffe 	bl	0 <IOE_IOEdgeConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:972
  
  /* if OK return 0 */
  return IOE_OK;
}
  48:	2000      	movs	r0, #0
  4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_IOAFConfig:

00000000 <IOE_IOAFConfig>:
IOE_IOAFConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:907
  * @param  NewState: State of the AF for the selected pin, could be 
  *         ENABLE or DISABLE.       
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOAFConfig(uint8_t DeviceAddr, uint8_t IO_Pin, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:911
  uint8_t tmp = 0;
  
  /* Get the current state of the GPIO_AF register */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF);
   6:	2117      	movs	r1, #23
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:907
  * @param  NewState: State of the AF for the selected pin, could be 
  *         ENABLE or DISABLE.       
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOAFConfig(uint8_t DeviceAddr, uint8_t IO_Pin, FunctionalState NewState)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:911
  uint8_t tmp = 0;
  
  /* Get the current state of the GPIO_AF register */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF);
   a:	f7ff fffe 	bl	0 <IOE_IOAFConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:913
  
  if (NewState != DISABLE)
   e:	b114      	cbz	r4, 16 <IOE_IOAFConfig+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:916
  {
    /* Enable the selected pins alternate function */
    tmp |= (uint8_t)IO_Pin;
  10:	ea45 0300 	orr.w	r3, r5, r0
  14:	e001      	b.n	1a <IOE_IOAFConfig+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:921
  }
  else
  {
    /* Disable the selected pins alternate function */   
    tmp &= ~(uint8_t)IO_Pin;   
  16:	ea20 0305 	bic.w	r3, r0, r5
  1a:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:925
  }
  
  /* Write back the new valu in GPIO_AF register */  
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_AF, tmp);  
  1c:	4630      	mov	r0, r6
  1e:	2117      	movs	r1, #23
  20:	f7ff fffe 	bl	0 <IOE_IOAFConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:929

  /* If all OK return IOE_OK */
  return IOE_OK;
}
  24:	2000      	movs	r0, #0
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_TempSens_Config:

00000000 <IOE_TempSens_Config>:
IOE_TempSens_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:879
  * @brief  Configures and enables the Temperature sensor module.
  * @param  None
  * @retval IOE_OK if all initializations are OK. Other value if error.
  */
uint8_t IOE_TempSens_Config(void)
{
   0:	b513      	push	{r0, r1, r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:880
  __IO uint8_t tmp = 0;
   2:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:883
  
  /* Enable Temperature Sensor Fct: already done in IOE_Config */
  tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2);
   4:	2104      	movs	r1, #4
   6:	2088      	movs	r0, #136
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:880
  * @param  None
  * @retval IOE_OK if all initializations are OK. Other value if error.
  */
uint8_t IOE_TempSens_Config(void)
{
  __IO uint8_t tmp = 0;
   8:	f88d 4007 	strb.w	r4, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:883
  
  /* Enable Temperature Sensor Fct: already done in IOE_Config */
  tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2);
   c:	f7ff fffe 	bl	0 <IOE_TempSens_Config>
  10:	f88d 0007 	strb.w	r0, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:884
  tmp &= ~(uint32_t)(IOE_TEMPSENS_FCT | IOE_ADC_FCT);
  14:	f89d 3007 	ldrb.w	r3, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:885
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2, tmp);  
  18:	2104      	movs	r1, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:884
{
  __IO uint8_t tmp = 0;
  
  /* Enable Temperature Sensor Fct: already done in IOE_Config */
  tmp = I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2);
  tmp &= ~(uint32_t)(IOE_TEMPSENS_FCT | IOE_ADC_FCT);
  1a:	f003 03f6 	and.w	r3, r3, #246	; 0xf6
  1e:	f88d 3007 	strb.w	r3, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:885
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_SYS_CTRL2, tmp);  
  22:	f89d 2007 	ldrb.w	r2, [sp, #7]
  26:	2088      	movs	r0, #136
  28:	f7ff fffe 	bl	0 <IOE_TempSens_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:888
  
  /* Enable the TEMPSENS module */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x01);
  2c:	2160      	movs	r1, #96
  2e:	2201      	movs	r2, #1
  30:	2088      	movs	r0, #136
  32:	f7ff fffe 	bl	0 <IOE_TempSens_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:891
  
  /* Aquire data enable */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x3);
  36:	2088      	movs	r0, #136
  38:	2160      	movs	r1, #96
  3a:	2203      	movs	r2, #3
  3c:	f7ff fffe 	bl	0 <IOE_TempSens_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:895
  
  /* All configuration done */
  return IOE_OK;
}
  40:	4620      	mov	r0, r4
  42:	bd1c      	pop	{r2, r3, r4, pc}
Disassembly of section .text.IOE_TS_Config:

00000000 <IOE_TS_Config>:
IOE_TS_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:814
  * @brief  Configures the touch Screen Controller (Single point detection)
  * @param  None
  * @retval IOE_OK if all initializations are OK. Other value if error.
  */
uint8_t IOE_TS_Config(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:818
  uint8_t tmp = 0;  
  
  /* Enable TSC Fct: already done in IOE_Config */
  tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_SYS_CTRL2);
   2:	2104      	movs	r1, #4
   4:	2082      	movs	r0, #130
   6:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:820
  tmp &= ~(uint32_t)(IOE_TS_FCT | IOE_ADC_FCT);
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_SYS_CTRL2, tmp); 
   a:	2104      	movs	r1, #4
   c:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
  10:	2082      	movs	r0, #130
  12:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:823
  
  /* Enable the TSC gloabl interrupts */
  tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_INT_EN);
  16:	210a      	movs	r1, #10
  18:	2082      	movs	r0, #130
  1a:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:825
  tmp |= (uint32_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV);
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_EN, tmp); 
  1e:	f040 0207 	orr.w	r2, r0, #7	; 0x7
  22:	210a      	movs	r1, #10
  24:	2082      	movs	r0, #130
  26:	b2d2      	uxtb	r2, r2
  28:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:828
  
  /* Select Sample Time, bit number and ADC Reference */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL1, 0x49);
  2c:	2120      	movs	r1, #32
  2e:	2249      	movs	r2, #73
  30:	2082      	movs	r0, #130
  32:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:831
  
  /* Wait for ~20 ms */
  _delay_(2);  
  36:	2002      	movs	r0, #2
  38:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:834
  
  /* Select the ADC clock speed: 3.25 MHz */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_ADC_CTRL2, 0x01);
  3c:	2201      	movs	r2, #1
  3e:	2121      	movs	r1, #33
  40:	2082      	movs	r0, #130
  42:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:837
  
  /* Select TSC pins in non default mode */  
  tmp = I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_AF);
  46:	2117      	movs	r1, #23
  48:	2082      	movs	r0, #130
  4a:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:839
  tmp &= ~(uint8_t)TOUCH_IO_ALL;
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_AF, tmp); 
  4e:	2117      	movs	r1, #23
  50:	f000 02e1 	and.w	r2, r0, #225	; 0xe1
  54:	2082      	movs	r0, #130
  56:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:842
  
  /* Select 2 nF filter capacitor */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CFG, 0x9A);   
  5a:	229a      	movs	r2, #154
  5c:	2082      	movs	r0, #130
  5e:	2141      	movs	r1, #65
  60:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:845
  
  /* Select single point reading  */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_TH, 0x01);
  64:	2082      	movs	r0, #130
  66:	214a      	movs	r1, #74
  68:	2201      	movs	r2, #1
  6a:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:848
  
  /* Write 0x01 to clear the FIFO memory content. */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
  6e:	214b      	movs	r1, #75
  70:	2201      	movs	r2, #1
  72:	2082      	movs	r0, #130
  74:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:851
  
  /* Write 0x00 to put the FIFO back into operation mode  */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
  78:	214b      	movs	r1, #75
  7a:	2200      	movs	r2, #0
  7c:	2082      	movs	r0, #130
  7e:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:854
  
  /* set the data format for Z value: 7 fractional part and 1 whole part */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_FRACT_XYZ, 0x01);
  82:	2156      	movs	r1, #86
  84:	2201      	movs	r2, #1
  86:	2082      	movs	r0, #130
  88:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:857
  
  /* set the driving capability of the device for TSC pins: 50mA */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_I_DRIVE, 0x01);
  8c:	2158      	movs	r1, #88
  8e:	2201      	movs	r2, #1
  90:	2082      	movs	r0, #130
  92:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:861
  
  /* Use no tracking index, touchscreen controller operation mode (XYZ) and 
     enable the TSC */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL, 0x01);
  96:	2140      	movs	r1, #64
  98:	2201      	movs	r2, #1
  9a:	2082      	movs	r0, #130
  9c:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:864
  
  /*  Clear all the status pending bits */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_INT_STA, 0xFF); 
  a0:	2082      	movs	r0, #130
  a2:	210b      	movs	r1, #11
  a4:	22ff      	movs	r2, #255
  a6:	f7ff fffe 	bl	0 <IOE_TS_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:867
  
  /* Initialize the TS structure to their default values */ 
  TS_State.TouchDetected = TS_State.X = TS_State.Y = TS_State.Z = 0;
  aa:	4b03      	ldr	r3, [pc, #12]	(b8 <IOE_TS_Config+0xb8>)
  ac:	2000      	movs	r0, #0
  ae:	80d8      	strh	r0, [r3, #6]
  b0:	8098      	strh	r0, [r3, #4]
  b2:	8058      	strh	r0, [r3, #2]
  b4:	8018      	strh	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:871
  
  /* All configuration done */
  return IOE_OK;  
}
  b6:	bd10      	pop	{r4, pc}
  b8:	00000000 	.word	0x00000000
Disassembly of section .text.IOE_IOITConfig:

00000000 <IOE_IOITConfig>:
IOE_IOITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:785
  *   @arg  IO_IT_x: where x can be from 0 to 7.
  * @param  NewState: could be ENABLE or DISABLE.  
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOITConfig(uint8_t DeviceAddr, uint8_t IO_IT, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:788
  uint8_t tmp = 0;
 
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN);
   6:	210c      	movs	r1, #12
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:785
  *   @arg  IO_IT_x: where x can be from 0 to 7.
  * @param  NewState: could be ENABLE or DISABLE.  
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOITConfig(uint8_t DeviceAddr, uint8_t IO_IT, FunctionalState NewState)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:788
  uint8_t tmp = 0;
 
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN);
   a:	f7ff fffe 	bl	0 <IOE_IOITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:790
  
  if (NewState != DISABLE)
   e:	b114      	cbz	r4, 16 <IOE_IOITConfig+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:793
  {
    /* Set the interrupts to be Enabled */    
    tmp |= (uint8_t)IO_IT;
  10:	ea45 0300 	orr.w	r3, r5, r0
  14:	e001      	b.n	1a <IOE_IOITConfig+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:798
  }
  else
  {
    /* Set the interrupts to be Disabled */    
    tmp &= ~(uint8_t)IO_IT;
  16:	ea20 0305 	bic.w	r3, r0, r5
  1a:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:802
  }
  
  /* Set the register */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_EN, tmp);
  1c:	4630      	mov	r0, r6
  1e:	210c      	movs	r1, #12
  20:	f7ff fffe 	bl	0 <IOE_IOITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:806
  
  /* If all OK return IOE_OK */
  return IOE_OK;   
}
  24:	2000      	movs	r0, #0
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_GITConfig:

00000000 <IOE_GITConfig>:
IOE_GITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:751
  *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_GITConfig(uint8_t DeviceAddr, uint8_t Global_IT, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:755
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_EN);
   6:	210a      	movs	r1, #10
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:751
  *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_GITConfig(uint8_t DeviceAddr, uint8_t Global_IT, FunctionalState NewState)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:755
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_EN);
   a:	f7ff fffe 	bl	0 <IOE_GITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:757
  
  if (NewState != DISABLE)
   e:	b114      	cbz	r4, 16 <IOE_GITConfig+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:760
  {
    /* Set the interrupts to be Enabled */    
    tmp |= (uint8_t)Global_IT;  
  10:	ea45 0300 	orr.w	r3, r5, r0
  14:	e001      	b.n	1a <IOE_GITConfig+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:765
  }
  else
  {
    /* Set the interrupts to be Disabled */    
    tmp &= ~(uint8_t)Global_IT;
  16:	ea20 0305 	bic.w	r3, r0, r5
  1a:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:768
  }
  /* Set the register */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_EN, tmp);
  1c:	4630      	mov	r0, r6
  1e:	210a      	movs	r1, #10
  20:	f7ff fffe 	bl	0 <IOE_GITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:772
  
  /* If all OK return IOE_OK */
  return IOE_OK;  
}
  24:	2000      	movs	r0, #0
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_GITCmd:

00000000 <IOE_GITCmd>:
IOE_GITCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:711
  *         or IOE_2_ADDR.
  * @param  NewState: could be ENABLE or DISABLE.        
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_GITCmd(uint8_t DeviceAddr, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:715
  uint8_t tmp = 0;
  
  /* Read the Interrupt Control register  */
  I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL);
   6:	2109      	movs	r1, #9
   8:	f7ff fffe 	bl	0 <IOE_GITCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:729
    /* Set the global interrupts to be Disabled */    
    tmp &= ~(uint8_t)IOE_GIT_EN;
  }  
  
  /* Write Back the Interrupt Control register */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_CTRL, tmp);
   c:	4620      	mov	r0, r4
   e:	2109      	movs	r1, #9
  10:	1e2a      	subs	r2, r5, #0
  12:	bf18      	it	ne
  14:	2201      	movne	r2, #1
  16:	f7ff fffe 	bl	0 <IOE_GITCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:733

  /* If all OK return IOE_OK */
  return IOE_OK;     
}
  1a:	2000      	movs	r0, #0
  1c:	bd70      	pop	{r4, r5, r6, pc}
  1e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_IOPinConfig:

00000000 <IOE_IOPinConfig>:
IOE_IOPinConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:681
  * @param  IO_Pin: IO_Pin_x: Where x can be from 0 to 7.   
  * @param  Direction: could be Direction_IN or Direction_OUT.      
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOPinConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Direction)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:685
  uint8_t tmp = 0;   
  
  /* Get all the Pins direction */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR);
   6:	2113      	movs	r1, #19
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:681
  * @param  IO_Pin: IO_Pin_x: Where x can be from 0 to 7.   
  * @param  Direction: could be Direction_IN or Direction_OUT.      
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_IOPinConfig(uint8_t DeviceAddr, uint8_t IO_Pin, uint8_t Direction)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:685
  uint8_t tmp = 0;   
  
  /* Get all the Pins direction */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR);
   a:	f7ff fffe 	bl	0 <IOE_IOPinConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:687
  
  if (Direction != Direction_IN)
   e:	b114      	cbz	r4, 16 <IOE_IOPinConfig+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:689
  {
    tmp |= (uint8_t)IO_Pin;
  10:	ea45 0300 	orr.w	r3, r5, r0
  14:	e001      	b.n	1a <IOE_IOPinConfig+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:693
  }  
  else 
  {
    tmp &= ~(uint8_t)IO_Pin;
  16:	ea20 0305 	bic.w	r3, r0, r5
  1a:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:697
  }
  
  /* Write the register new value */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_DIR, tmp);
  1c:	4630      	mov	r0, r6
  1e:	2113      	movs	r1, #19
  20:	f7ff fffe 	bl	0 <IOE_IOPinConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:701
  
  /* If all OK return IOE_OK */
  return IOE_OK;      
}
  24:	2000      	movs	r0, #0
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_FnctCmd:

00000000 <IOE_FnctCmd>:
IOE_FnctCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:648
  *   @arg  IOE_ADC_FCT : ADC function
  *   @arg  IOE_TEMPSENS_FCT : Tempreature Sensor function
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_FnctCmd(uint8_t DeviceAddr, uint8_t Fct, FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:652
  uint8_t tmp = 0;
  
  /* Get the register value */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2);
   6:	2104      	movs	r1, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:648
  *   @arg  IOE_ADC_FCT : ADC function
  *   @arg  IOE_TEMPSENS_FCT : Tempreature Sensor function
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_FnctCmd(uint8_t DeviceAddr, uint8_t Fct, FunctionalState NewState)
{
   8:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:652
  uint8_t tmp = 0;
  
  /* Get the register value */
  tmp = I2C_ReadDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2);
   a:	f7ff fffe 	bl	0 <IOE_FnctCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:654
  
  if (NewState != DISABLE)
   e:	b114      	cbz	r4, 16 <IOE_FnctCmd+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:657
  {
    /* Set the Functionalities to be Enabled */    
    tmp &= ~(uint8_t)Fct;
  10:	ea20 0305 	bic.w	r3, r0, r5
  14:	e001      	b.n	1a <IOE_FnctCmd+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:662
  }
  else
  {
    /* Set the Functionalities to be Disabled */    
    tmp |= (uint8_t)Fct;  
  16:	ea45 0300 	orr.w	r3, r5, r0
  1a:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:666
  }
  
  /* Set the register value */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL2, tmp);
  1c:	4630      	mov	r0, r6
  1e:	2104      	movs	r1, #4
  20:	f7ff fffe 	bl	0 <IOE_FnctCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:670
  
  /* If all OK return IOE_OK */
  return IOE_OK;    
}
  24:	2000      	movs	r0, #0
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.IOE_Reset:

00000000 <IOE_Reset>:
IOE_Reset():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:602
  * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
  *         or IOE_2_ADDR.
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_Reset(uint8_t DeviceAddr)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:604
  /* Power Down the IO_Expander */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x02);
   2:	2103      	movs	r1, #3
   4:	2202      	movs	r2, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:602
  * @param  DeviceAddr: The address of the IOExpander, could be : IOE_1_ADDR
  *         or IOE_2_ADDR.
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_Reset(uint8_t DeviceAddr)
{
   6:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:604
  /* Power Down the IO_Expander */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x02);
   8:	f7ff fffe 	bl	0 <IOE_Reset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:607

  /* wait for a delay to insure registers erasing */
  _delay_(2); 
   c:	2002      	movs	r0, #2
   e:	f7ff fffe 	bl	0 <IOE_Reset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:610
  
  /* Power On the Codec after the power off => all registers are reinitialized*/
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_SYS_CTRL1, 0x00);
  12:	4620      	mov	r0, r4
  14:	2103      	movs	r1, #3
  16:	2200      	movs	r2, #0
  18:	f7ff fffe 	bl	0 <IOE_Reset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:614
  
  /* If all OK return IOE_OK */
  return IOE_OK;    
}
  1c:	2000      	movs	r0, #0
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.IOE_ClearIOITPending:

00000000 <IOE_ClearIOITPending>:
IOE_ClearIOITPending():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:550
  * @param  IO_IT: the IO interrupt to be checked could be IO_ITx Where x can be 
  *         from 0 to 7.              
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_ClearIOITPending(uint8_t DeviceAddr, uint8_t IO_IT)
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:552
  /* Write 1 to the bits that have to be cleared */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_INT_STA, IO_IT);  
   4:	4622      	mov	r2, r4
   6:	210d      	movs	r1, #13
   8:	f7ff fffe 	bl	0 <IOE_ClearIOITPending>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:555

  /* Clear the Edge detection pending bit*/
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_ED, IO_IT);
   c:	2114      	movs	r1, #20
   e:	4622      	mov	r2, r4
  10:	2088      	movs	r0, #136
  12:	f7ff fffe 	bl	0 <IOE_ClearIOITPending>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:558

  /* Clear the Rising edge pending bit */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_RE, IO_IT);
  16:	2115      	movs	r1, #21
  18:	4622      	mov	r2, r4
  1a:	2088      	movs	r0, #136
  1c:	f7ff fffe 	bl	0 <IOE_ClearIOITPending>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:561

  /* Clear the Falling edge pending bit */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_FE, IO_IT);  
  20:	2088      	movs	r0, #136
  22:	2116      	movs	r1, #22
  24:	4622      	mov	r2, r4
  26:	f7ff fffe 	bl	0 <IOE_ClearIOITPending>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:565

  /* If all OK return IOE_OK */
  return IOE_OK;
}
  2a:	2000      	movs	r0, #0
  2c:	bd10      	pop	{r4, pc}
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_ClearGITPending:

00000000 <IOE_ClearGITPending>:
IOE_ClearGITPending():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:508
  *   @arg  Global_IT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  Global_IT_TOUCH : Touch Screen Controller Touch Detected interrupt 
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_ClearGITPending(uint8_t DeviceAddr, uint8_t Global_IT)
{
   0:	460a      	mov	r2, r1
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:510
  /* Write 1 to the bits that have to be cleared */
  I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_INT_STA, Global_IT); 
   4:	210b      	movs	r1, #11
   6:	f7ff fffe 	bl	0 <IOE_ClearGITPending>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:514

  /* If all OK return IOE_OK */
  return IOE_OK;
}
   a:	2000      	movs	r0, #0
   c:	bd10      	pop	{r4, pc}
   e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_TempSens_GetData:

00000000 <IOE_TempSens_GetData>:
IOE_TempSens_GetData():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:442
  * @brief  Returns the temperature row value (in 16 bit format).
  * @param  None
  * @retval The temperature row value.
  */
uint32_t IOE_TempSens_GetData(void)
{  
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:446
  static __IO uint32_t tmp = 0;  
    
  /* Aquire data enable */
  I2C_WriteDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_CTRL, 0x03);
   2:	2203      	movs	r2, #3
   4:	2160      	movs	r1, #96
   6:	2088      	movs	r0, #136
   8:	f7ff fffe 	bl	0 <IOE_TempSens_GetData>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:449
  
  /* Enable the TEMPSENS module */
  tmp = (uint32_t)((I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA) & 0x03) << 8); 
   c:	2161      	movs	r1, #97
   e:	2088      	movs	r0, #136
  10:	f7ff fffe 	bl	0 <IOE_TempSens_GetData>
  14:	4c0e      	ldr	r4, [pc, #56]	(50 <IOE_TempSens_GetData+0x50>)
  16:	f000 0003 	and.w	r0, r0, #3	; 0x3
  1a:	0200      	lsls	r0, r0, #8
  1c:	6020      	str	r0, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:450
  tmp |= (uint32_t)I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_TEMP_DATA + 1); 
  1e:	2162      	movs	r1, #98
  20:	2088      	movs	r0, #136
  22:	6825      	ldr	r5, [r4, #0]
  24:	f7ff fffe 	bl	0 <IOE_TempSens_GetData>
  28:	4328      	orrs	r0, r5
  2a:	6020      	str	r0, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:452
  
  tmp = (uint32_t)((33 * tmp * 100) / 751);
  2c:	6822      	ldr	r2, [r4, #0]
  2e:	f640 43e4 	movw	r3, #3300	; 0xce4
  32:	4353      	muls	r3, r2
  34:	f240 22ef 	movw	r2, #751	; 0x2ef
  38:	fbb3 f3f2 	udiv	r3, r3, r2
  3c:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:453
  tmp = (uint32_t)((tmp + 5) / 10);
  3e:	6823      	ldr	r3, [r4, #0]
  40:	220a      	movs	r2, #10
  42:	3305      	adds	r3, #5
  44:	fbb3 f3f2 	udiv	r3, r3, r2
  48:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:456
  
  /* return the temprature row value */
  return tmp;
  4a:	6820      	ldr	r0, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:457
}
  4c:	bd70      	pop	{r4, r5, r6, pc}
  4e:	46c0      	nop			(mov r8, r8)
  50:	00000000 	.word	0x00000000
Disassembly of section .text.IOE_TS_GetState:

00000000 <IOE_TS_GetState>:
IOE_TS_GetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:402
  * @brief  Returns Status and positions of the Touch screen.
  * @param  None
  * @retval Pointer to TS_STATE structure holding Touch Screen information.
  */
TS_STATE* IOE_TS_GetState(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:407
  uint32_t xDiff, yDiff , x , y;
  static uint32_t _x = 0, _y = 0;
  
  /* Check if the Touch detect event happenned */
  TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
   2:	2082      	movs	r0, #130
   4:	2140      	movs	r1, #64
   6:	f7ff fffe 	bl	0 <IOE_TS_GetState>
   a:	4b28      	ldr	r3, [pc, #160]	(ac <IOE_TS_GetState+0xac>)
   c:	f000 0080 	and.w	r0, r0, #128	; 0x80
  10:	8018      	strh	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:408
  if(TS_State.TouchDetected) 
  12:	2800      	cmp	r0, #0
  14:	d032      	beq.n	7c <IOE_TS_GetState+0x7c>
IOE_TS_Read_X():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1323
  */
static uint16_t IOE_TS_Read_X(void)
{
  int32_t x, xr;
 
  x = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Y);
  16:	214f      	movs	r1, #79
  18:	2082      	movs	r0, #130
  1a:	f7ff fffe 	bl	0 <IOE_TS_GetState>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1328
  
  /* first correction */
  xr =  (x * 320) >> 12;
  /* second correction */
  xr = ((xr * 32)/29) - 17;
  1e:	f44f 73a0 	mov.w	r3, #320	; 0x140
  22:	4343      	muls	r3, r0
  24:	131b      	asrs	r3, r3, #12
  26:	221d      	movs	r2, #29
  28:	015b      	lsls	r3, r3, #5
  2a:	fb93 f3f2 	sdiv	r3, r3, r2
  2e:	3b11      	subs	r3, #17
IOE_TS_GetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:410
  
  /* Check if the Touch detect event happenned */
  TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
  if(TS_State.TouchDetected) 
  {
    x = IOE_TS_Read_X();
  30:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
IOE_TS_Read_Y():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1344
  * @retval Y position.
  */
static uint16_t IOE_TS_Read_Y(void)
{
  int32_t y, yr;
  y= I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_X);
  34:	2082      	movs	r0, #130
  36:	214d      	movs	r1, #77
IOE_TS_GetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:410
  
  /* Check if the Touch detect event happenned */
  TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
  if(TS_State.TouchDetected) 
  {
    x = IOE_TS_Read_X();
  38:	b29c      	uxth	r4, r3
IOE_TS_Read_Y():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1344
  * @retval Y position.
  */
static uint16_t IOE_TS_Read_Y(void)
{
  int32_t y, yr;
  y= I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_X);
  3a:	f7ff fffe 	bl	0 <IOE_TS_GetState>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1347
  
  yr= (y * 240) >> 12;
  yr = ((yr * 240) / 217) - 12;
  3e:	23f0      	movs	r3, #240
  40:	4358      	muls	r0, r3
  42:	1300      	asrs	r0, r0, #12
  44:	4343      	muls	r3, r0
  46:	22d9      	movs	r2, #217
  48:	fb93 f3f2 	sdiv	r3, r3, r2
  4c:	3b0c      	subs	r3, #12
IOE_TS_GetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:411
  /* Check if the Touch detect event happenned */
  TS_State.TouchDetected = (I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_TSC_CTRL) & 0x80);
  if(TS_State.TouchDetected) 
  {
    x = IOE_TS_Read_X();
    y = IOE_TS_Read_Y();
  4e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  52:	b29a      	uxth	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:412
    xDiff = x > _x? (x - _x): (_x - x);
  54:	4b16      	ldr	r3, [pc, #88]	(b0 <IOE_TS_GetState+0xb0>)
  56:	685b      	ldr	r3, [r3, #4]
  58:	429c      	cmp	r4, r3
  5a:	d901      	bls.n	60 <IOE_TS_GetState+0x60>
  5c:	1ae1      	subs	r1, r4, r3
  5e:	e000      	b.n	62 <IOE_TS_GetState+0x62>
  60:	1b19      	subs	r1, r3, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:413
    yDiff = y > _y? (y - _y): (_y - y);       
  62:	4b13      	ldr	r3, [pc, #76]	(b0 <IOE_TS_GetState+0xb0>)
  64:	689b      	ldr	r3, [r3, #8]
  66:	429a      	cmp	r2, r3
  68:	d901      	bls.n	6e <IOE_TS_GetState+0x6e>
  6a:	1ad3      	subs	r3, r2, r3
  6c:	e000      	b.n	70 <IOE_TS_GetState+0x70>
  6e:	1a9b      	subs	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:414
    if (xDiff + yDiff > 5)
  70:	185b      	adds	r3, r3, r1
  72:	2b05      	cmp	r3, #5
  74:	d902      	bls.n	7c <IOE_TS_GetState+0x7c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:416
    {
      _x = x;
  76:	4b0e      	ldr	r3, [pc, #56]	(b0 <IOE_TS_GetState+0xb0>)
  78:	605c      	str	r4, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:417
      _y = y;       
  7a:	609a      	str	r2, [r3, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:421
    }
  }  
  /* Update the X position */
  TS_State.X = _x;
  7c:	4b0c      	ldr	r3, [pc, #48]	(b0 <IOE_TS_GetState+0xb0>)
  7e:	4c0b      	ldr	r4, [pc, #44]	(ac <IOE_TS_GetState+0xac>)
  80:	889a      	ldrh	r2, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:424
    
  /* Update the Y position */  
  TS_State.Y = _y;
  82:	891b      	ldrh	r3, [r3, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:421
      _x = x;
      _y = y;       
    }
  }  
  /* Update the X position */
  TS_State.X = _x;
  84:	8062      	strh	r2, [r4, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:424
    
  /* Update the Y position */  
  TS_State.Y = _y;
  86:	80a3      	strh	r3, [r4, #4]
IOE_TS_Read_Z():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1363
  * @retval Z position.
  */
static uint16_t IOE_TS_Read_Z(void)
{
  uint32_t z;
  z = I2C_ReadDataBuffer(IOE_1_ADDR, IOE_REG_TSC_DATA_Z);
  88:	2151      	movs	r1, #81
  8a:	2082      	movs	r0, #130
  8c:	f7ff fffe 	bl	0 <IOE_TS_GetState>
IOE_TS_GetState():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:429
  TS_State.Y = _y;
  /* Update the Z Pression index */  
  TS_State.Z = IOE_TS_Read_Z();  
  
  /* Clear the interrupt pending bit and enable the FIFO again */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
  90:	214b      	movs	r1, #75
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:426
  TS_State.X = _x;
    
  /* Update the Y position */  
  TS_State.Y = _y;
  /* Update the Z Pression index */  
  TS_State.Z = IOE_TS_Read_Z();  
  92:	80e0      	strh	r0, [r4, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:429
  
  /* Clear the interrupt pending bit and enable the FIFO again */
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x01);
  94:	2201      	movs	r2, #1
  96:	2082      	movs	r0, #130
  98:	f7ff fffe 	bl	0 <IOE_TS_GetState>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:430
  I2C_WriteDeviceRegister(IOE_1_ADDR, IOE_REG_FIFO_STA, 0x00);
  9c:	2082      	movs	r0, #130
  9e:	214b      	movs	r1, #75
  a0:	2200      	movs	r2, #0
  a2:	f7ff fffe 	bl	0 <IOE_TS_GetState>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:434
  
  /* Return pointer to the updated structure */
  return &TS_State; 
}
  a6:	4620      	mov	r0, r4
  a8:	bd10      	pop	{r4, pc}
  aa:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.IOE_WriteIOPin:

00000000 <IOE_WriteIOPin>:
IOE_WriteIOPin():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:276
  * @param BitVal: The value to be set. This parameter can be one of the
  *        following values: BitSet or BitReset. See IOE_BitVal_TypeDef.
  * @retval IOE_OK or PARAM_ERROR
  */
uint8_t IOE_WriteIOPin(uint8_t IO_Pin, IOE_BitValue_TypeDef BitVal)
{
   0:	f010 0f01 	tst.w	r0, #1	; 0x1
   4:	b510      	push	{r4, lr}
   6:	4602      	mov	r2, r0
   8:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:280
  uint8_t DeviceAddr = 0;
  
  /* Get the IO expander Address according to which pin is to be controlled */
  if (IO_Pin & IO1_OUT_ALL_PINS)
   a:	d001      	beq.n	10 <IOE_WriteIOPin+0x10>
   c:	2082      	movs	r0, #130
   e:	e005      	b.n	1c <IOE_WriteIOPin+0x1c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:284
  {
    DeviceAddr = IOE_1_ADDR;
  }
  else if (IO_Pin & IO2_OUT_ALL_PINS)
  10:	f010 0f05 	tst.w	r0, #5	; 0x5
  14:	d101      	bne.n	1a <IOE_WriteIOPin+0x1a>
  16:	2003      	movs	r0, #3
  18:	e00a      	b.n	30 <IOE_WriteIOPin+0x30>
  1a:	2088      	movs	r0, #136
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:294
  {
    return PARAM_ERROR;
  }
  
  /* Apply the bit value to the selected pin */
  if (BitVal == BitReset)
  1c:	b924      	cbnz	r4, 28 <IOE_WriteIOPin+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:297
  {
    /* Set the register */
    I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_CLR_PIN, IO_Pin);
  1e:	2111      	movs	r1, #17
  20:	f7ff fffe 	bl	0 <IOE_WriteIOPin>
  24:	4620      	mov	r0, r4
  26:	e003      	b.n	30 <IOE_WriteIOPin+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:302
  }
  else
  {
    /* Set the register */
    I2C_WriteDeviceRegister(DeviceAddr, IOE_REG_GPIO_SET_PIN, IO_Pin);
  28:	2110      	movs	r1, #16
  2a:	f7ff fffe 	bl	0 <IOE_WriteIOPin>
  2e:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:306
  }
  
  return IOE_OK;
}
  30:	bd10      	pop	{r4, pc}
  32:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.IOE_ITConfig:

00000000 <IOE_ITConfig>:
IOE_ITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:196
  *   @arg  IOE_ITSRC_TSC: Touch Screen interrupts.
  *   @arg  IOE_ITSRC_INMEMS: MEMS interrupt lines.
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_ITConfig(uint32_t IOE_ITSRC_Source)
{   
   0:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:198
  /* Configure the Interrupt output pin to generate low level (INT_CTRL) */
  IOE_ITOutConfig(Polarity_High, Type_Level);  
   2:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:196
  *   @arg  IOE_ITSRC_TSC: Touch Screen interrupts.
  *   @arg  IOE_ITSRC_INMEMS: MEMS interrupt lines.
  * @retval IOE_OK: if all initializations are OK. Other value if error.
  */
uint8_t IOE_ITConfig(uint32_t IOE_ITSRC_Source)
{   
   4:	4604      	mov	r4, r0
   6:	b085      	sub	sp, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:198
  /* Configure the Interrupt output pin to generate low level (INT_CTRL) */
  IOE_ITOutConfig(Polarity_High, Type_Level);  
   8:	2004      	movs	r0, #4
   a:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:201
  
  /* Manage the Joystick Interrupts */  
  if (IOE_ITSRC_Source & IOE_ITSRC_JOYSTICK)
   e:	f014 0f04 	tst.w	r4, #4	; 0x4
  12:	d01a      	beq.n	4a <IOE_ITConfig+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:204
  {   
    /* Enable the Global interrupt */  
    IOE_GITCmd(IOE_2_ADDR, ENABLE);     
  14:	2101      	movs	r1, #1
  16:	2088      	movs	r0, #136
  18:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:207
        
    /* Enable the Joystick pins to generate interrupt (GPIO_INT_EN) */
    IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);   
  1c:	21f8      	movs	r1, #248
  1e:	2201      	movs	r2, #1
  20:	2088      	movs	r0, #136
  22:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:210
    
    /* Enable the Global GPIO Interrupt */
    IOE_GITConfig(IOE_2_ADDR, IOE_GIT_GPIO, ENABLE);    
  26:	2201      	movs	r2, #1
  28:	2180      	movs	r1, #128
  2a:	2088      	movs	r0, #136
  2c:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:213
    
    /* Read the GPIO_IT_STA to clear all pending bits if any */
    I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);    
  30:	210d      	movs	r1, #13
  32:	2088      	movs	r0, #136
  34:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:216
    
    /* Enable the Joystick pins to generate interrupt */
    IOE_IOITConfig(IOE_2_ADDR, IOE_JOY_IT, ENABLE);  
  38:	21f8      	movs	r1, #248
  3a:	2088      	movs	r0, #136
  3c:	2201      	movs	r2, #1
  3e:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:219
    
    /* Read the GPIO_IT_STA to clear all pending bits if any */
    I2C_ReadDeviceRegister(IOE_2_ADDR, IOE_REG_GPIO_INT_STA);     
  42:	2088      	movs	r0, #136
  44:	210d      	movs	r1, #13
  46:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:223
  }

  /* Manage the MEMS Interrupts lines  */  
  if (IOE_ITSRC_Source & IOE_ITSRC_INMEMS)
  4a:	f014 0f02 	tst.w	r4, #2	; 0x2
  4e:	d01a      	beq.n	86 <IOE_ITConfig+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:226
  {   
    /* Enable the Global interrupt */  
    IOE_GITCmd(IOE_1_ADDR, ENABLE);     
  50:	2101      	movs	r1, #1
  52:	2082      	movs	r0, #130
  54:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:229
        
    /* Enable the pins to generate interrupt (GPIO_INT_EN) */
    IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);   
  58:	210c      	movs	r1, #12
  5a:	2201      	movs	r2, #1
  5c:	2082      	movs	r0, #130
  5e:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:232
    
    /* Enable the Global GPIO Interrupt */
    IOE_GITConfig(IOE_1_ADDR, IOE_GIT_GPIO, ENABLE);    
  62:	2201      	movs	r2, #1
  64:	2180      	movs	r1, #128
  66:	2082      	movs	r0, #130
  68:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:235
    
    /* Read the GPIO_IT_STA to clear all pending bits if any */
    I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);    
  6c:	210d      	movs	r1, #13
  6e:	2082      	movs	r0, #130
  70:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:238
    
    /* Enable the pins to generate interrupt */
    IOE_IOITConfig(IOE_1_ADDR, IOE_INMEMS_IT, ENABLE);  
  74:	210c      	movs	r1, #12
  76:	2082      	movs	r0, #130
  78:	2201      	movs	r2, #1
  7a:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:241
    
    /* Read the GPIO_IT_STA to clear all pending bits if any */
    I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA);     
  7e:	2082      	movs	r0, #130
  80:	210d      	movs	r1, #13
  82:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:245
  }  
  
  /* Manage the Touch Screen Interrupts */  
  if (IOE_ITSRC_Source & IOE_ITSRC_TSC)
  86:	f014 0f01 	tst.w	r4, #1	; 0x1
  8a:	d00c      	beq.n	a6 <IOE_ITConfig+0xa6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:248
  {   
    /* Enable the Global interrupt */  
    IOE_GITCmd(IOE_1_ADDR, ENABLE);     
  8c:	2101      	movs	r1, #1
  8e:	2082      	movs	r0, #130
  90:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:251
           
    /* Enable the Global GPIO Interrupt */
    IOE_GITConfig(IOE_1_ADDR, (uint8_t)(IOE_GIT_TOUCH | IOE_GIT_FTH | IOE_GIT_FOV), ENABLE);    
  94:	2107      	movs	r1, #7
  96:	2082      	movs	r0, #130
  98:	2201      	movs	r2, #1
  9a:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:254
    
    /* Read the GPIO_IT_STA to clear all pending bits if any */
    I2C_ReadDeviceRegister(IOE_1_ADDR, IOE_REG_GPIO_INT_STA); 
  9e:	2082      	movs	r0, #130
  a0:	210d      	movs	r1, #13
  a2:	f7ff fffe 	bl	0 <IOE_ITConfig>
IOE_EXTI_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1440
  GPIO_InitTypeDef GPIO_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
 
  /* Enable Button GPIO clock */
  RCC_APB2PeriphClockCmd(RCC_APB_GPIO_IOE_ITPORT | RCC_APB2Periph_AFIO, ENABLE);
  a6:	2009      	movs	r0, #9
  a8:	2101      	movs	r1, #1
  aa:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1443
  
  /* Configure Button pin as input floating */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  ae:	f44f 4480 	mov.w	r4, #16384	; 0x4000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1444
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  b2:	2304      	movs	r3, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1445
  GPIO_Init(GPIO_IOE_ITPORT, &GPIO_InitStructure);  
  b4:	a903      	add	r1, sp, #12
  b6:	4814      	ldr	r0, [pc, #80]	(108 <IOE_ITConfig+0x108>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1444
  /* Enable Button GPIO clock */
  RCC_APB2PeriphClockCmd(RCC_APB_GPIO_IOE_ITPORT | RCC_APB2Periph_AFIO, ENABLE);
  
  /* Configure Button pin as input floating */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  b8:	f88d 300f 	strb.w	r3, [sp, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1443
 
  /* Enable Button GPIO clock */
  RCC_APB2PeriphClockCmd(RCC_APB_GPIO_IOE_ITPORT | RCC_APB2Periph_AFIO, ENABLE);
  
  /* Configure Button pin as input floating */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  bc:	f8ad 400c 	strh.w	r4, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1445
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIO_IOE_ITPORT, &GPIO_InitStructure);  
  c0:	f7ff fffe 	bl	0 <GPIO_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1448
  
  /* Connect Button EXTI Line to Button GPIO Pin */
  GPIO_EXTILineConfig(GPIO_PortSource_IOE_ITPORT, GPIO_PinSource_IOE_ITPIN);  
  c4:	210e      	movs	r1, #14
  c6:	2001      	movs	r0, #1
  c8:	f7ff fffe 	bl	0 <GPIO_EXTILineConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1452
  
  /* Configure Button EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_LINE_IOE_ITLINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  cc:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1453
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  ce:	2310      	movs	r3, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1451
  
  /* Connect Button EXTI Line to Button GPIO Pin */
  GPIO_EXTILineConfig(GPIO_PortSource_IOE_ITPORT, GPIO_PinSource_IOE_ITPIN);  
  
  /* Configure Button EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_LINE_IOE_ITLINE;
  d0:	9400      	str	r4, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1455
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  d2:	4668      	mov	r0, sp
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1454
  
  /* Configure Button EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_LINE_IOE_ITLINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  d4:	2401      	movs	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1453
  GPIO_EXTILineConfig(GPIO_PortSource_IOE_ITPORT, GPIO_PinSource_IOE_ITPIN);  
  
  /* Configure Button EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_LINE_IOE_ITLINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  d6:	f88d 3005 	strb.w	r3, [sp, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1452
  /* Connect Button EXTI Line to Button GPIO Pin */
  GPIO_EXTILineConfig(GPIO_PortSource_IOE_ITPORT, GPIO_PinSource_IOE_ITPIN);  
  
  /* Configure Button EXTI line */
  EXTI_InitStructure.EXTI_Line = EXTI_LINE_IOE_ITLINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  da:	f88d 5004 	strb.w	r5, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1454
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  de:	f88d 4006 	strb.w	r4, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1455
  EXTI_Init(&EXTI_InitStructure);
  e2:	f7ff fffe 	bl	0 <EXTI_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1458
  
  /* Enable and set Button EXTI Interrupt to the lowest priority */
  NVIC_InitStructure.NVIC_IRQChannel = IOE_IT_EXTI_IRQn;
  e6:	2328      	movs	r3, #40
  e8:	f88d 3008 	strb.w	r3, [sp, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1462
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
  ec:	a802      	add	r0, sp, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1459
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  EXTI_Init(&EXTI_InitStructure);
  
  /* Enable and set Button EXTI Interrupt to the lowest priority */
  NVIC_InitStructure.NVIC_IRQChannel = IOE_IT_EXTI_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
  ee:	230f      	movs	r3, #15
  f0:	f88d 3009 	strb.w	r3, [sp, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1460
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
  f4:	f88d 300a 	strb.w	r3, [sp, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1461
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  f8:	f88d 400b 	strb.w	r4, [sp, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1462
  NVIC_Init(&NVIC_InitStructure);
  fc:	f7ff fffe 	bl	0 <NVIC_Init>
IOE_ITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:262
  /* Configure the Interrupt line as EXTI source */
  IOE_EXTI_Config();    
  
  /* If all OK return IOE_OK */
  return IOE_OK;
}
 100:	4628      	mov	r0, r5
 102:	b005      	add	sp, #20
 104:	bd30      	pop	{r4, r5, pc}
 106:	46c0      	nop			(mov r8, r8)
 108:	40010c00 	.word	0x40010c00
Disassembly of section .text.IOE_Config:

00000000 <IOE_Config>:
IOE_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:114
  *         hardware (GPIOs, APB clocks ..).
  * @param  None
  * @retval IOE_OK if all initializations done correctly. Other value if error.
  */
uint8_t IOE_Config(void)
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
IOE_GPIO_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1382
static void IOE_GPIO_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  
  /* Enable IOE_I2C and IOE_I2C_PORT & Alternate Function clocks */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_IOE_I2C, ENABLE);
   2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
   6:	2101      	movs	r1, #1
   8:	f7ff fffe 	bl	0 <RCC_APB1PeriphClockCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1383
  RCC_APB2PeriphClockCmd(RCC_APB_IOE_I2C_PORT | RCC_APB_GPIO_IOE_ITPORT | RCC_APB2Periph_AFIO, ENABLE);
   c:	2009      	movs	r0, #9
   e:	2101      	movs	r1, #1
  10:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1386
  
  /* Reset IOE_I2C IP */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_IOE_I2C, ENABLE);
  14:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  18:	2101      	movs	r1, #1
  1a:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1389
  
  /* Release reset signal of IOE_I2C IP */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_IOE_I2C, DISABLE);
  1e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  22:	2100      	movs	r1, #0
  24:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1395
  
  /* IOE_I2C SCL and SDA pins configuration */
  GPIO_InitStructure.GPIO_Pin = IOE_SCL_PIN | IOE_SDA_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  GPIO_Init(IOE_I2C_PORT, &GPIO_InitStructure);
  28:	ac01      	add	r4, sp, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1392
  
  /* Release reset signal of IOE_I2C IP */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_IOE_I2C, DISABLE);
  
  /* IOE_I2C SCL and SDA pins configuration */
  GPIO_InitStructure.GPIO_Pin = IOE_SCL_PIN | IOE_SDA_PIN;
  2a:	f04f 03c0 	mov.w	r3, #192	; 0xc0
  2e:	f8ad 3004 	strh.w	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1393
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  32:	2501      	movs	r5, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1394
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  34:	231c      	movs	r3, #28
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1395
  GPIO_Init(IOE_I2C_PORT, &GPIO_InitStructure);
  36:	483f      	ldr	r0, [pc, #252]	(134 <IOE_Config+0x134>)
  38:	4621      	mov	r1, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1394
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_IOE_I2C, DISABLE);
  
  /* IOE_I2C SCL and SDA pins configuration */
  GPIO_InitStructure.GPIO_Pin = IOE_SCL_PIN | IOE_SDA_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  3a:	f88d 3007 	strb.w	r3, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1393
  /* Release reset signal of IOE_I2C IP */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_IOE_I2C, DISABLE);
  
  /* IOE_I2C SCL and SDA pins configuration */
  GPIO_InitStructure.GPIO_Pin = IOE_SCL_PIN | IOE_SDA_PIN;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
  3e:	f88d 5006 	strb.w	r5, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1395
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  GPIO_Init(IOE_I2C_PORT, &GPIO_InitStructure);
  42:	f7ff fffe 	bl	0 <GPIO_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1398
  
  /* Set EXTI pin as Input PullUp - IO_Expander_INT */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  46:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  4a:	f8ad 3004 	strh.w	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1400
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_Init(GPIO_IOE_ITPORT, &GPIO_InitStructure);
  4e:	4839      	ldr	r0, [pc, #228]	(134 <IOE_Config+0x134>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1399
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  GPIO_Init(IOE_I2C_PORT, &GPIO_InitStructure);
  
  /* Set EXTI pin as Input PullUp - IO_Expander_INT */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  50:	2348      	movs	r3, #72
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1400
  GPIO_Init(GPIO_IOE_ITPORT, &GPIO_InitStructure);
  52:	4621      	mov	r1, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1399
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
  GPIO_Init(IOE_I2C_PORT, &GPIO_InitStructure);
  
  /* Set EXTI pin as Input PullUp - IO_Expander_INT */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_IOE_ITPIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  54:	f88d 3007 	strb.w	r3, [sp, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1400
  GPIO_Init(GPIO_IOE_ITPORT, &GPIO_InitStructure);
  58:	f7ff fffe 	bl	0 <GPIO_Init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:1403
  
  /* Connect IO Expander IT line to EXTI line */
  GPIO_EXTILineConfig(GPIO_PortSource_IOE_ITPORT, GPIO_PinSource_IOE_ITPIN);
  5c:	4628      	mov	r0, r5
  5e:	210e      	movs	r1, #14
  60:	f7ff fffe 	bl	0 <GPIO_EXTILineConfig>
IOE_Config():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:119
{
  /* Configure the needed pins */
  IOE_GPIO_Config(); 
  
  /* Read IO Expander 1 ID  */
  if(IOE_IsOperational(IOE_1_ADDR))
  64:	2082      	movs	r0, #130
  66:	f7ff fffe 	bl	0 <IOE_Config>
  6a:	b108      	cbz	r0, 70 <IOE_Config+0x70>
  6c:	2004      	movs	r0, #4
  6e:	e05f      	b.n	130 <IOE_Config+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:123
  {
    return IOE1_NOT_OPERATIONAL;
  }
  if(IOE_IsOperational(IOE_2_ADDR))
  70:	2088      	movs	r0, #136
  72:	f7ff fffe 	bl	0 <IOE_Config>
  76:	4604      	mov	r4, r0
  78:	b108      	cbz	r0, 7e <IOE_Config+0x7e>
  7a:	2005      	movs	r0, #5
  7c:	e058      	b.n	130 <IOE_Config+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:129
  {
    return IOE2_NOT_OPERATIONAL;
  }
  
  /* Generate IOExpander Software reset */
  IOE_Reset(IOE_1_ADDR); 
  7e:	2082      	movs	r0, #130
  80:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:130
  IOE_Reset(IOE_2_ADDR);
  84:	2088      	movs	r0, #136
  86:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:134
  
  /* ---------------------- IO Expander 1 configuration --------------------- */
  /* Enable the GPIO, Touch Screen and ADC functionalities */
  IOE_FnctCmd(IOE_1_ADDR, IOE_IO_FCT | IOE_TS_FCT | IOE_ADC_FCT, ENABLE);
  8a:	2107      	movs	r1, #7
  8c:	2082      	movs	r0, #130
  8e:	462a      	mov	r2, r5
  90:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:136
  /* Configure the VBAT pin in output mode pin*/
  IOE_IOPinConfig(IOE_1_ADDR, VBAT_DIV_PIN , Direction_OUT);  
  94:	2082      	movs	r0, #130
  96:	4629      	mov	r1, r5
  98:	462a      	mov	r2, r5
  9a:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:138
  /* ENABLE the alternate function for IN1 pin */
  IOE_IOAFConfig(IOE_1_ADDR, VBAT_DIV_PIN, ENABLE);
  9e:	462a      	mov	r2, r5
  a0:	2082      	movs	r0, #130
  a2:	4629      	mov	r1, r5
  a4:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:141
  
  /* Apply the default state for the out pins */
  IOE_WriteIOPin(VBAT_DIV_PIN, BitReset);
  a8:	4621      	mov	r1, r4
  aa:	4628      	mov	r0, r5
  ac:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:143
  /* Configure the MEMS interrupt pins in Input mode */
  IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), Direction_IN); 
  b0:	210c      	movs	r1, #12
  b2:	2088      	movs	r0, #136
  b4:	4622      	mov	r2, r4
  b6:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:146
  
  /* ENABLE the alternate function for the Joystick pins */
  IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), ENABLE);
  ba:	210c      	movs	r1, #12
  bc:	2088      	movs	r0, #136
  be:	462a      	mov	r2, r5
  c0:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:148
  /* Configure the IOs to detect Falling and Rising Edges */
  IOE_IOEdgeConfig(IOE_2_ADDR, (uint32_t)(MEMS_INT1_PIN | MEMS_INT2_PIN), (uint32_t)(EDGE_FALLING | EDGE_RISING));
  c4:	210c      	movs	r1, #12
  c6:	2203      	movs	r2, #3
  c8:	2088      	movs	r0, #136
  ca:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:150
  /* Touch Screen controller configuration */
  IOE_TS_Config();
  ce:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:156
  
  /* ------------------------------------------------------------------------ */
  
  /* ---------------------- IO Expander 2 configuration --------------------- */
  /* Enable the GPIO, Temperature Sensor and ADC functionalities */
  IOE_FnctCmd(IOE_2_ADDR, IOE_IO_FCT | IOE_TEMPSENS_FCT | IOE_ADC_FCT, ENABLE);
  d2:	210d      	movs	r1, #13
  d4:	2088      	movs	r0, #136
  d6:	462a      	mov	r2, r5
  d8:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:159
  /* Configure the Audio Codec Reset pin in output mode pin*/
  //IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN | MII_INT_PIN), Direction_OUT);  
  IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN ), Direction_OUT); 
  dc:	2104      	movs	r1, #4
  de:	2088      	movs	r0, #136
  e0:	462a      	mov	r2, r5
  e2:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:162
  /* ENABLE the alternate function for IN1 pin */
  //IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN | MII_INT_PIN), ENABLE);
  IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(AUDIO_RESET_PIN), ENABLE);
  e6:	2104      	movs	r1, #4
  e8:	462a      	mov	r2, r5
  ea:	2088      	movs	r0, #136
  ec:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:164
  /* Apply the default state for the out pins */
  IOE_WriteIOPin(AUDIO_RESET_PIN, BitReset);
  f0:	4621      	mov	r1, r4
  f2:	2004      	movs	r0, #4
  f4:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:167
      
  //IOE_WriteIOPin(MII_INT_PIN, BitReset);
  IOE_IOPinConfig(IOE_2_ADDR, (uint32_t)(MII_INT_PIN ), Direction_IN);
  f8:	4629      	mov	r1, r5
  fa:	4622      	mov	r2, r4
  fc:	2088      	movs	r0, #136
  fe:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:168
  IOE_IOAFConfig(IOE_2_ADDR, (uint32_t)(MII_INT_PIN), ENABLE);
 102:	4629      	mov	r1, r5
 104:	462a      	mov	r2, r5
 106:	2088      	movs	r0, #136
 108:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:171

  /* Configure the Joystick pins in Input mode */
  IOE_IOPinConfig(IOE_2_ADDR, JOY_IO_PINS , Direction_IN); 
 10c:	21f8      	movs	r1, #248
 10e:	4622      	mov	r2, r4
 110:	2088      	movs	r0, #136
 112:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:174
  
  /* ENABLE the alternate function for the Joystick pins */
  IOE_IOAFConfig(IOE_2_ADDR, JOY_IO_PINS, ENABLE);
 116:	21f8      	movs	r1, #248
 118:	462a      	mov	r2, r5
 11a:	2088      	movs	r0, #136
 11c:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:176
  /* Configure the IOs to detect Falling and Rising Edges */
  IOE_IOEdgeConfig(IOE_2_ADDR, JOY_IO_PINS, (uint8_t)(EDGE_FALLING | EDGE_RISING));
 120:	21f8      	movs	r1, #248
 122:	2203      	movs	r2, #3
 124:	2088      	movs	r0, #136
 126:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:179
  
  /* Temperature Sensor module configuration */
  IOE_TempSens_Config();
 12a:	f7ff fffe 	bl	0 <IOE_Config>
 12e:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\STM32_EVAL\STM3210C_EVAL/stm3210c_eval_ioe.c:184
  /* ------------------------------------------------------------------------ */
  
  /* Configuration is OK */
  return IOE_OK; 
}
 130:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 132:	46c0      	nop			(mov r8, r8)
 134:	40010c00 	.word	0x40010c00
