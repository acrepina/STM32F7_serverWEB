
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\netconf.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\netconf.o

Disassembly of section .text.Display_Periodic_Handle:

00000000 <Display_Periodic_Handle>:
Display_Periodic_Handle():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:212
  * @brief  LCD & LEDs periodic handling
  * @param  localtime: the current LocalTime value
  * @retval None
  */
void Display_Periodic_Handle(__IO uint32_t localtime)
{ 
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:214
  /* 250 ms */
  if (localtime - DisplayTimer >= LCD_TIMER_MSECS)
   2:	4e65      	ldr	r6, [pc, #404]	(198 <Display_Periodic_Handle+0x198>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:212
  * @brief  LCD & LEDs periodic handling
  * @param  localtime: the current LocalTime value
  * @retval None
  */
void Display_Periodic_Handle(__IO uint32_t localtime)
{ 
   4:	b08e      	sub	sp, #56
   6:	9003      	str	r0, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:214
  /* 250 ms */
  if (localtime - DisplayTimer >= LCD_TIMER_MSECS)
   8:	9b03      	ldr	r3, [sp, #12]
   a:	6832      	ldr	r2, [r6, #0]
   c:	1a9b      	subs	r3, r3, r2
   e:	2bf9      	cmp	r3, #249
  10:	f240 80c0 	bls.w	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:216
  {
    DisplayTimer = localtime;
  14:	9b03      	ldr	r3, [sp, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:219

    /* We have got a new IP address so update the display */
    if (IPaddress != netif.ip_addr.addr)
  16:	4d61      	ldr	r5, [pc, #388]	(19c <Display_Periodic_Handle+0x19c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:216
void Display_Periodic_Handle(__IO uint32_t localtime)
{ 
  /* 250 ms */
  if (localtime - DisplayTimer >= LCD_TIMER_MSECS)
  {
    DisplayTimer = localtime;
  18:	6033      	str	r3, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:219

    /* We have got a new IP address so update the display */
    if (IPaddress != netif.ip_addr.addr)
  1a:	686a      	ldr	r2, [r5, #4]
  1c:	6873      	ldr	r3, [r6, #4]
  1e:	4293      	cmp	r3, r2
  20:	f000 8084 	beq.w	12c <Display_Periodic_Handle+0x12c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:227
      uint8_t iptxt[20];

      /* Read the new IP address */
      IPaddress = netif.ip_addr.addr;

      iptab[0] = (uint8_t)(IPaddress >> 24);
  24:	0e13      	lsrs	r3, r2, #24
  26:	f88d 3034 	strb.w	r3, [sp, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:228
      iptab[1] = (uint8_t)(IPaddress >> 16);
  2a:	f3c2 4307 	ubfx	r3, r2, #16, #8
  2e:	f88d 3035 	strb.w	r3, [sp, #53]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:229
      iptab[2] = (uint8_t)(IPaddress >> 8);
  32:	f3c2 2307 	ubfx	r3, r2, #8, #8
  36:	f88d 3036 	strb.w	r3, [sp, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:230
      iptab[3] = (uint8_t)(IPaddress);
  3a:	b2d3      	uxtb	r3, r2
  3c:	f88d 3037 	strb.w	r3, [sp, #55]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:225
    {
      __IO uint8_t iptab[4];
      uint8_t iptxt[20];

      /* Read the new IP address */
      IPaddress = netif.ip_addr.addr;
  40:	6072      	str	r2, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:232
      iptab[0] = (uint8_t)(IPaddress >> 24);
      iptab[1] = (uint8_t)(IPaddress >> 16);
      iptab[2] = (uint8_t)(IPaddress >> 8);
      iptab[3] = (uint8_t)(IPaddress);

      sprintf((char*)iptxt, "   %d.%d.%d.%d    ", iptab[3], iptab[2], iptab[1], iptab[0]);
  42:	f89d 2037 	ldrb.w	r2, [sp, #55]
  46:	f89d 3036 	ldrb.w	r3, [sp, #54]
  4a:	f89d 1035 	ldrb.w	r1, [sp, #53]
  4e:	f89d 0034 	ldrb.w	r0, [sp, #52]
  52:	ac05      	add	r4, sp, #20
  54:	9100      	str	r1, [sp, #0]
  56:	9001      	str	r0, [sp, #4]
  58:	4951      	ldr	r1, [pc, #324]	(1a0 <Display_Periodic_Handle+0x1a0>)
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <sprintf>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:236

      /* Display the new IP address */
#if LWIP_DHCP
      if (netif.flags & NETIF_FLAG_DHCP)
  60:	f895 302e 	ldrb.w	r3, [r5, #46]
  64:	f013 0f08 	tst.w	r3, #8	; 0x8
  68:	d053      	beq.n	112 <Display_Periodic_Handle+0x112>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:239
      {        
		/* Display the IP address */
		LCD_DisplayStringLine(Line7, "IP address assigned ");
  6a:	20a8      	movs	r0, #168
  6c:	494d      	ldr	r1, [pc, #308]	(1a4 <Display_Periodic_Handle+0x1a4>)
  6e:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:240
        LCD_DisplayStringLine(Line8, "  by a DHCP server  ");
  72:	20c0      	movs	r0, #192
  74:	494c      	ldr	r1, [pc, #304]	(1a8 <Display_Periodic_Handle+0x1a8>)
  76:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:241
        LCD_DisplayStringLine(Line9, iptxt);
  7a:	4621      	mov	r1, r4
  7c:	20d8      	movs	r0, #216
  7e:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:242
		Delay(LCD_DELAY);
  82:	f640 30b8 	movw	r0, #3000	; 0xbb8
  86:	f7ff fffe 	bl	0 <Delay>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:246
		
		/** Start the client/server application: only when a dynamic IP address has been obtained  **/
	    /* Clear the LCD */
        LCD_Clear(Black);
  8a:	2000      	movs	r0, #0
  8c:	f7ff fffe 	bl	0 <LCD_Clear>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:247
	    LCD_SetBackColor(Black);
  90:	2000      	movs	r0, #0
  92:	f7ff fffe 	bl	0 <LCD_SetBackColor>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:248
        LCD_SetTextColor(White);		   	
  96:	f64f 70ff 	movw	r0, #65535	; 0xffff
  9a:	f7ff fffe 	bl	0 <LCD_SetTextColor>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:250
       
	    iptab[0] = (uint8_t)(IPaddress >> 24);
  9e:	6872      	ldr	r2, [r6, #4]
  a0:	0e13      	lsrs	r3, r2, #24
  a2:	f88d 3034 	strb.w	r3, [sp, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:251
        iptab[1] = (uint8_t)(IPaddress >> 16);
  a6:	f3c2 4307 	ubfx	r3, r2, #16, #8
  aa:	f88d 3035 	strb.w	r3, [sp, #53]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:252
        iptab[2] = (uint8_t)(IPaddress >> 8);
  ae:	f3c2 2307 	ubfx	r3, r2, #8, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:253
        iptab[3] = (uint8_t)(IPaddress);
  b2:	b2d2      	uxtb	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:252
	    LCD_SetBackColor(Black);
        LCD_SetTextColor(White);		   	
       
	    iptab[0] = (uint8_t)(IPaddress >> 24);
        iptab[1] = (uint8_t)(IPaddress >> 16);
        iptab[2] = (uint8_t)(IPaddress >> 8);
  b4:	f88d 3036 	strb.w	r3, [sp, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:253
        iptab[3] = (uint8_t)(IPaddress);
  b8:	f88d 2037 	strb.w	r2, [sp, #55]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:255
        	   
	    sprintf((char*)iptxt, "is: %d.%d.%d.%d ", iptab[3], iptab[2], iptab[1], iptab[0]);		
  bc:	f89d 2037 	ldrb.w	r2, [sp, #55]
  c0:	f89d 3036 	ldrb.w	r3, [sp, #54]
  c4:	f89d 1035 	ldrb.w	r1, [sp, #53]
  c8:	f89d 0034 	ldrb.w	r0, [sp, #52]
  cc:	9100      	str	r1, [sp, #0]
  ce:	9001      	str	r0, [sp, #4]
  d0:	4936      	ldr	r1, [pc, #216]	(1ac <Display_Periodic_Handle+0x1ac>)
  d2:	4620      	mov	r0, r4
  d4:	f7ff fffe 	bl	0 <sprintf>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:257
       
	    LCD_DisplayStringLine(Line0, " You are configured ");
  d8:	2000      	movs	r0, #0
  da:	4935      	ldr	r1, [pc, #212]	(1b0 <Display_Periodic_Handle+0x1b0>)
  dc:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:258
	    LCD_DisplayStringLine(Line2, iptxt);
  e0:	2030      	movs	r0, #48
  e2:	4621      	mov	r1, r4
  e4:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:260

	    if(Server)
  e8:	7a33      	ldrb	r3, [r6, #8]
  ea:	b133      	cbz	r3, fa <Display_Periodic_Handle+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:262
	    {
	      LCD_DisplayStringLine(Line1, "as a server, your IP");
  ec:	2018      	movs	r0, #24
  ee:	4931      	ldr	r1, [pc, #196]	(1b4 <Display_Periodic_Handle+0x1b4>)
  f0:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:265
		 
		  /* Initialize the server application */
	      server_init(); 
  f4:	f7ff fffe 	bl	0 <server_init>
  f8:	e04c      	b.n	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:269
	    }
	    else
	    {
	      LCD_DisplayStringLine(Line1, "as a client, your IP");
  fa:	492f      	ldr	r1, [pc, #188]	(1b8 <Display_Periodic_Handle+0x1b8>)
  fc:	2018      	movs	r0, #24
  fe:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:272
		 
		  /* Configure the IO Expander */
          IOE_Config(); 
 102:	f7ff fffe 	bl	0 <IOE_Config>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:275
      
          /* Enable the Touch Screen and Joystick interrupts */
          IOE_ITConfig(IOE_ITSRC_TSC);
 106:	2001      	movs	r0, #1
 108:	f7ff fffe 	bl	0 <IOE_ITConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:278
		  
		  /* Initialize the client application */
	      client_init();
 10c:	f7ff fffe 	bl	0 <client_init>
 110:	e040      	b.n	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:285
      }
      else
#endif
      {
        /* Display the IP address */
		LCD_DisplayStringLine(Line8, "  Static IP address   ");
 112:	20c0      	movs	r0, #192
 114:	4929      	ldr	r1, [pc, #164]	(1bc <Display_Periodic_Handle+0x1bc>)
 116:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:286
        LCD_DisplayStringLine(Line9, iptxt);	    
 11a:	20d8      	movs	r0, #216
 11c:	4621      	mov	r1, r4
 11e:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:287
		Delay(LCD_DELAY);
 122:	f640 30b8 	movw	r0, #3000	; 0xbb8
 126:	f7ff fffe 	bl	0 <Delay>
 12a:	e033      	b.n	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:293
      }           
    }

#if LWIP_DHCP
    
    else if (IPaddress == 0)
 12c:	2b00      	cmp	r3, #0
 12e:	d131      	bne.n	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:296
    {
      /* We still waiting for the DHCP server */
	  LCD_DisplayStringLine(Line4, "     Looking for    ");
 130:	2060      	movs	r0, #96
 132:	4923      	ldr	r1, [pc, #140]	(1c0 <Display_Periodic_Handle+0x1c0>)
 134:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:297
      LCD_DisplayStringLine(Line5, "     DHCP server    ");
 138:	2078      	movs	r0, #120
 13a:	4922      	ldr	r1, [pc, #136]	(1c4 <Display_Periodic_Handle+0x1c4>)
 13c:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:298
      LCD_DisplayStringLine(Line6, "     please wait... ");
 140:	2090      	movs	r0, #144
 142:	4921      	ldr	r1, [pc, #132]	(1c8 <Display_Periodic_Handle+0x1c8>)
 144:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:300

      LedToggle &= 3;
 148:	4a20      	ldr	r2, [pc, #128]	(1cc <Display_Periodic_Handle+0x1cc>)
 14a:	7810      	ldrb	r0, [r2, #0]
 14c:	f000 0003 	and.w	r0, r0, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:302

      STM_EVAL_LEDToggle((Led_TypeDef)(LedToggle++));
 150:	1c43      	adds	r3, r0, #1
 152:	7013      	strb	r3, [r2, #0]
 154:	f7ff fffe 	bl	0 <STM_EVAL_LEDToggle>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:306

      /* If no response from a DHCP server for MAX_DHCP_TRIES times */
	  /* stop the dhcp client and set a static IP address */
	  if (netif.dhcp->tries > MAX_DHCP_TRIES)
 158:	6a2b      	ldr	r3, [r5, #32]
 15a:	785b      	ldrb	r3, [r3, #1]
 15c:	2b04      	cmp	r3, #4
 15e:	d919      	bls.n	194 <Display_Periodic_Handle+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:312
      {
        struct ip_addr ipaddr;
        struct ip_addr netmask;
        struct ip_addr gw;

        LCD_DisplayStringLine(Line7, "    DHCP timeout    ");        
 160:	491b      	ldr	r1, [pc, #108]	(1d0 <Display_Periodic_Handle+0x1d0>)
 162:	20a8      	movs	r0, #168
 164:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:314

        dhcp_stop(&netif);
 168:	4628      	mov	r0, r5
 16a:	f7ff fffe 	bl	0 <dhcp_stop>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:316

        IP4_ADDR(&ipaddr, 192, 168, 0, 8);
 16e:	4819      	ldr	r0, [pc, #100]	(68 <htonl+0x68>)
 170:	f7ff fffe 	bl	0 <htonl>
 174:	900c      	str	r0, [sp, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:317
        IP4_ADDR(&netmask, 255, 255, 255, 0);
 176:	f06f 00ff 	mvn.w	r0, #255	; 0xff
 17a:	f7ff fffe 	bl	0 <htonl>
 17e:	900b      	str	r0, [sp, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:318
        IP4_ADDR(&gw, 192, 168, 0, 1);
 180:	4815      	ldr	r0, [pc, #84]	(1d8 <Display_Periodic_Handle+0x1d8>)
 182:	f7ff fffe 	bl	0 <htonl>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:320

        netif_set_addr(&netif, &ipaddr , &netmask, &gw);
 186:	a90c      	add	r1, sp, #48
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:318

        dhcp_stop(&netif);

        IP4_ADDR(&ipaddr, 192, 168, 0, 8);
        IP4_ADDR(&netmask, 255, 255, 255, 0);
        IP4_ADDR(&gw, 192, 168, 0, 1);
 188:	900a      	str	r0, [sp, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:320

        netif_set_addr(&netif, &ipaddr , &netmask, &gw);
 18a:	aa0b      	add	r2, sp, #44
 18c:	4628      	mov	r0, r5
 18e:	ab0a      	add	r3, sp, #40
 190:	f7ff fffe 	bl	0 <netif_set_addr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:326

      }
    }
#endif
  } 
}
 194:	b00e      	add	sp, #56
 196:	bd70      	pop	{r4, r5, r6, pc}
	...
 1a4:	00000013 	.word	0x00000013
 1a8:	00000028 	.word	0x00000028
 1ac:	0000003d 	.word	0x0000003d
 1b0:	0000004e 	.word	0x0000004e
 1b4:	00000063 	.word	0x00000063
 1b8:	00000078 	.word	0x00000078
 1bc:	0000008d 	.word	0x0000008d
 1c0:	000000a4 	.word	0x000000a4
 1c4:	000000b9 	.word	0x000000b9
 1c8:	000000ce 	.word	0x000000ce
 1cc:	00000000 	.word	0x00000000
 1d0:	000000e3 	.word	0x000000e3
 1d4:	c0a80008 	.word	0xc0a80008
 1d8:	c0a80001 	.word	0xc0a80001
Disassembly of section .text.LwIP_Periodic_Handle:

00000000 <LwIP_Periodic_Handle>:
LwIP_Periodic_Handle():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:174
  * @brief  LwIP periodic tasks
  * @param  localtime the current LocalTime value
  * @retval None
  */
void LwIP_Periodic_Handle(__IO uint32_t localtime)
{
   0:	b507      	push	{r0, r1, r2, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:177

  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
   2:	4917      	ldr	r1, [pc, #92]	(60 <LwIP_Periodic_Handle+0x60>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:174
  * @brief  LwIP periodic tasks
  * @param  localtime the current LocalTime value
  * @retval None
  */
void LwIP_Periodic_Handle(__IO uint32_t localtime)
{
   4:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:177

  /* TCP periodic process every 250 ms */
  if (localtime - TCPTimer >= TCP_TMR_INTERVAL)
   6:	9b01      	ldr	r3, [sp, #4]
   8:	68ca      	ldr	r2, [r1, #12]
   a:	1a9b      	subs	r3, r3, r2
   c:	2bf9      	cmp	r3, #249
   e:	d903      	bls.n	18 <LwIP_Periodic_Handle+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:179
  {
    TCPTimer =  localtime;
  10:	9b01      	ldr	r3, [sp, #4]
  12:	60cb      	str	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:180
    tcp_tmr();
  14:	f7ff fffe 	bl	0 <tcp_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:183
  }
  /* ARP periodic process every 5s */
  if (localtime - ARPTimer >= ARP_TMR_INTERVAL)
  18:	4911      	ldr	r1, [pc, #68]	(60 <LwIP_Periodic_Handle+0x60>)
  1a:	9b01      	ldr	r3, [sp, #4]
  1c:	690a      	ldr	r2, [r1, #16]
  1e:	1a9b      	subs	r3, r3, r2
  20:	f241 3287 	movw	r2, #4999	; 0x1387
  24:	4293      	cmp	r3, r2
  26:	d903      	bls.n	30 <LwIP_Periodic_Handle+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:185
  {
    ARPTimer =  localtime;
  28:	9b01      	ldr	r3, [sp, #4]
  2a:	610b      	str	r3, [r1, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:186
    etharp_tmr();
  2c:	f7ff fffe 	bl	0 <etharp_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:191
  }

#if LWIP_DHCP
  /* Fine DHCP periodic process every 500ms */
  if (localtime - DHCPfineTimer >= DHCP_FINE_TIMER_MSECS)
  30:	490b      	ldr	r1, [pc, #44]	(60 <LwIP_Periodic_Handle+0x60>)
  32:	9b01      	ldr	r3, [sp, #4]
  34:	694a      	ldr	r2, [r1, #20]
  36:	1a9b      	subs	r3, r3, r2
  38:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  3c:	d303      	bcc.n	46 <LwIP_Periodic_Handle+0x46>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:193
  {
    DHCPfineTimer =  localtime;
  3e:	9b01      	ldr	r3, [sp, #4]
  40:	614b      	str	r3, [r1, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:194
    dhcp_fine_tmr();
  42:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:197
  }
  /* DHCP Coarse periodic process every 60s */
  if (localtime - DHCPcoarseTimer >= DHCP_COARSE_TIMER_MSECS)
  46:	4906      	ldr	r1, [pc, #24]	(60 <LwIP_Periodic_Handle+0x60>)
  48:	9b01      	ldr	r3, [sp, #4]
  4a:	698a      	ldr	r2, [r1, #24]
  4c:	1a9b      	subs	r3, r3, r2
  4e:	f64e 225f 	movw	r2, #59999	; 0xea5f
  52:	4293      	cmp	r3, r2
  54:	d903      	bls.n	5e <LwIP_Periodic_Handle+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:199
  {
    DHCPcoarseTimer =  localtime;
  56:	9b01      	ldr	r3, [sp, #4]
  58:	618b      	str	r3, [r1, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:200
    dhcp_coarse_tmr();
  5a:	f7ff fffe 	bl	0 <dhcp_coarse_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:204
  }
#endif

}
  5e:	bd0e      	pop	{r1, r2, r3, pc}
  60:	00000000 	.word	0x00000000
Disassembly of section .text.LwIP_Pkt_Handle:

00000000 <LwIP_Pkt_Handle>:
LwIP_Pkt_Handle():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:163
  * @brief  Called when a frame is received
  * @param  None
  * @retval None
  */
void LwIP_Pkt_Handle(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:165
  /* Read a received packet from the Ethernet buffers and send it to the lwIP for handling */
  ethernetif_input(&netif);
   2:	4802      	ldr	r0, [pc, #8]	(c <LwIP_Pkt_Handle+0xc>)
   4:	f7ff fffe 	bl	0 <ethernetif_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:166
}
   8:	bd10      	pop	{r4, pc}
   a:	46c0      	nop			(mov r8, r8)
   c:	00000000 	.word	0x00000000
Disassembly of section .text.LwIP_Init:

00000000 <LwIP_Init>:
LwIP_Init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:72
  * @brief  Initializes the lwIP stack
  * @param  None
  * @retval None
  */
void LwIP_Init(void)
{
   0:	b510      	push	{r4, lr}
   2:	b08a      	sub	sp, #40
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:76
  struct ip_addr ipaddr;
  struct ip_addr netmask;
  struct ip_addr gw;
  uint8_t macaddress[6]={0,0,0,0,0,1};
   4:	2206      	movs	r2, #6
   6:	492d      	ldr	r1, [pc, #180]	(bc <LwIP_Init+0xbc>)
   8:	f10d 0016 	add.w	r0, sp, #22	; 0x16
   c:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:86
  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();


#if LWIP_DHCP
  ipaddr.addr = 0;
  10:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:79
  struct ip_addr netmask;
  struct ip_addr gw;
  uint8_t macaddress[6]={0,0,0,0,0,1};

  /* Initializes the dynamic memory heap defined by MEM_SIZE.*/
  mem_init();
  12:	f7ff fffe 	bl	0 <mem_init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:82

  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();
  16:	f7ff fffe 	bl	0 <memp_init>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:91
  ipaddr.addr = 0;
  netmask.addr = 0;
  gw.addr = 0;

  /* Configure the board opeartin mode: Client/Server */  
  LCD_DisplayStringLine(Line5, "  Keep Key button   ");
  1a:	2078      	movs	r0, #120
  1c:	4928      	ldr	r1, [pc, #160]	(c0 <LwIP_Init+0xc0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:86
  /* Initializes the memory pools defined by MEMP_NUM_x.*/
  memp_init();


#if LWIP_DHCP
  ipaddr.addr = 0;
  1e:	9409      	str	r4, [sp, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:87
  netmask.addr = 0;
  20:	9408      	str	r4, [sp, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:88
  gw.addr = 0;
  22:	9407      	str	r4, [sp, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:91

  /* Configure the board opeartin mode: Client/Server */  
  LCD_DisplayStringLine(Line5, "  Keep Key button   ");
  24:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:92
  LCD_DisplayStringLine(Line6, "pressed to activate ");
  28:	2090      	movs	r0, #144
  2a:	4926      	ldr	r1, [pc, #152]	(c4 <LwIP_Init+0xc4>)
  2c:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:93
  LCD_DisplayStringLine(Line7, "     the server     ");
  30:	4925      	ldr	r1, [pc, #148]	(c8 <LwIP_Init+0xc8>)
  32:	20a8      	movs	r0, #168
  34:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:95

  Delay(KEY_DELAY);
  38:	f640 30b8 	movw	r0, #3000	; 0xbb8
  3c:	f7ff fffe 	bl	0 <Delay>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:97
  
  if(!STM_EVAL_PBGetState(Button_KEY))
  40:	2002      	movs	r0, #2
  42:	f7ff fffe 	bl	0 <STM_EVAL_PBGetState>
  46:	4a21      	ldr	r2, [pc, #132]	(cc <LwIP_Init+0xcc>)
  48:	b940      	cbnz	r0, 5c <LwIP_Init+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:99
  {	
	Server = SELECTED;
  4a:	2301      	movs	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:101
	
	LCD_DisplayStringLine(Line5, "                    ");
  4c:	3078      	adds	r0, #120
  4e:	4920      	ldr	r1, [pc, #128]	(d0 <LwIP_Init+0xd0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:99

  Delay(KEY_DELAY);
  
  if(!STM_EVAL_PBGetState(Button_KEY))
  {	
	Server = SELECTED;
  50:	7213      	strb	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:101
	
	LCD_DisplayStringLine(Line5, "                    ");
  52:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:102
	LCD_DisplayStringLine(Line6, "  Server selected   ");	
  56:	2090      	movs	r0, #144
  58:	491e      	ldr	r1, [pc, #120]	(d4 <LwIP_Init+0xd4>)
  5a:	e009      	b.n	70 <LwIP_Init+0x70>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:108
	LCD_DisplayStringLine(Line7, "                    ");
	Delay(LCD_DELAY);
  }
  else
  {
    macaddress[5]=CLIENTMAC6;
  5c:	2302      	movs	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:112
	
	Server = NOT_SELECTED;
	
	LCD_DisplayStringLine(Line5, "                    ");
  5e:	2078      	movs	r0, #120
  60:	491b      	ldr	r1, [pc, #108]	(d0 <LwIP_Init+0xd0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:110
  }
  else
  {
    macaddress[5]=CLIENTMAC6;
	
	Server = NOT_SELECTED;
  62:	7214      	strb	r4, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:108
	LCD_DisplayStringLine(Line7, "                    ");
	Delay(LCD_DELAY);
  }
  else
  {
    macaddress[5]=CLIENTMAC6;
  64:	f88d 301b 	strb.w	r3, [sp, #27]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:112
	
	Server = NOT_SELECTED;
	
	LCD_DisplayStringLine(Line5, "                    ");
  68:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:113
	LCD_DisplayStringLine(Line6, "  Client selected   ");	
  6c:	491a      	ldr	r1, [pc, #104]	(d8 <LwIP_Init+0xd8>)
  6e:	2090      	movs	r0, #144
  70:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:114
	LCD_DisplayStringLine(Line7, "                    ");
  74:	4916      	ldr	r1, [pc, #88]	(d0 <LwIP_Init+0xd0>)
  76:	20a8      	movs	r0, #168
  78:	f7ff fffe 	bl	0 <LCD_DisplayStringLine>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:115
	Delay(LCD_DELAY);
  7c:	f640 30b8 	movw	r0, #3000	; 0xbb8
  80:	f7ff fffe 	bl	0 <Delay>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:124
  IP4_ADDR(&ipaddr, 192, 168, 0, 8);
  IP4_ADDR(&netmask, 255, 255, 255, 0);
  IP4_ADDR(&gw, 192, 168, 0, 1);
#endif

  Set_MAC_Address(macaddress);
  84:	f10d 0016 	add.w	r0, sp, #22	; 0x16
  88:	f7ff fffe 	bl	0 <Set_MAC_Address>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:138
  Give pointers to cleared ip_addr structures when using DHCP,
  or fill them with sane numbers otherwise. The state pointer may be NULL.

  The init function pointer must point to a initialization function for
  your ethernet netif interface. The following code illustrates it's use.*/
  netif_add(&netif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
  8c:	2300      	movs	r3, #0
  8e:	9300      	str	r3, [sp, #0]
  90:	4b12      	ldr	r3, [pc, #72]	(dc <LwIP_Init+0xdc>)
  92:	a909      	add	r1, sp, #36
  94:	9301      	str	r3, [sp, #4]
  96:	4b12      	ldr	r3, [pc, #72]	(e0 <LwIP_Init+0xe0>)
  98:	aa08      	add	r2, sp, #32
  9a:	9302      	str	r3, [sp, #8]
  9c:	4811      	ldr	r0, [pc, #68]	(e4 <LwIP_Init+0xe4>)
  9e:	ab07      	add	r3, sp, #28
  a0:	f7ff fffe 	bl	0 <netif_add>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:141

  /*  Registers the default network interface.*/
  netif_set_default(&netif);
  a4:	480f      	ldr	r0, [pc, #60]	(40 <netif_set_default+0x40>)
  a6:	f7ff fffe 	bl	0 <netif_set_default>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:149
#if LWIP_DHCP
  /*  Creates a new DHCP client for this interface on the first call.
  Note: you must call dhcp_fine_tmr() and dhcp_coarse_tmr() at
  the predefined regular intervals after starting the client.
  You can peek in the netif->dhcp struct for the actual DHCP status.*/
  dhcp_start(&netif);
  aa:	480e      	ldr	r0, [pc, #56]	(3c <dhcp_start+0x3c>)
  ac:	f7ff fffe 	bl	0 <dhcp_start>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:153
#endif

  /*  When the netif is fully configured this function must be called.*/
  netif_set_up(&netif);
  b0:	480c      	ldr	r0, [pc, #48]	(34 <netif_set_up+0x34>)
  b2:	f7ff fffe 	bl	0 <netif_set_up>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\src/netconf.c:155

}
  b6:	b00a      	add	sp, #40
  b8:	bd10      	pop	{r4, pc}
  ba:	46c0      	nop			(mov r8, r8)
  bc:	00000000 	.word	0x00000000
  c0:	000000f8 	.word	0x000000f8
  c4:	0000010d 	.word	0x0000010d
  c8:	00000122 	.word	0x00000122
  cc:	00000000 	.word	0x00000000
  d0:	00000137 	.word	0x00000137
  d4:	0000014c 	.word	0x0000014c
  d8:	00000161 	.word	0x00000161
	...
