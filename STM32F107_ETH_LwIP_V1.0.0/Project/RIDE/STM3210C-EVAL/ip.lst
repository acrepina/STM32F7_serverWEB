
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\ip.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\ip.o

Disassembly of section .text.ip_current_netif:

00000000 <ip_current_netif>:
ip_current_netif():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:84
 */
struct netif *
ip_current_netif(void)
{
  return current_netif;
}
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ip_current_netif+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	00000000 	.word	0x00000000
Disassembly of section .text.ip_current_header:

00000000 <ip_current_header>:
ip_current_header():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:98
 */
const struct ip_hdr *
ip_current_header(void)
{
  return current_header;
}
   0:	4b01      	ldr	r3, [pc, #4]	(8 <ip_current_header+0x8>)
   2:	6858      	ldr	r0, [r3, #4]
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	00000000 	.word	0x00000000
Disassembly of section .text.ip_output_if:

00000000 <ip_output_if>:
ip_output_if():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:522
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	461c      	mov	r4, r3
   6:	f89d 3030 	ldrb.w	r3, [sp, #48]
   a:	4680      	mov	r8, r0
   c:	460f      	mov	r7, r1
   e:	f8dd 9038 	ldr.w	r9, [sp, #56]
  12:	9301      	str	r3, [sp, #4]
  14:	f89d a034 	ldrb.w	sl, [sp, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:544
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  18:	4616      	mov	r6, r2
  1a:	2a00      	cmp	r2, #0
  1c:	d074      	beq.n	108 <ip_output_if+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:567
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
      }
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  1e:	2114      	movs	r1, #20
  20:	f7ff fffe 	bl	0 <pbuf_header>
  24:	4683      	mov	fp, r0
  26:	b108      	cbz	r0, 2c <ip_output_if+0x2c>
  28:	20fe      	movs	r0, #254
  2a:	e084      	b.n	136 <ip_output_if+0x136>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:575
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  2c:	f8d8 5004 	ldr.w	r5, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:579
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  30:	7a2b      	ldrb	r3, [r5, #8]
  32:	7a68      	ldrb	r0, [r5, #9]
  34:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  38:	f7ff fffe 	bl	0 <ntohs>
  3c:	f364 201f 	bfi	r0, r4, #8, #24
  40:	f7ff fffe 	bl	0 <htons>
  44:	f3c0 230f 	ubfx	r3, r0, #8, #16
  48:	726b      	strb	r3, [r5, #9]
  4a:	7228      	strb	r0, [r5, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:580
    IPH_PROTO_SET(iphdr, proto);
  4c:	f7ff fffe 	bl	0 <ntohs>
  50:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
  54:	ea40 000a 	orr.w	r0, r0, sl
  58:	f7ff fffe 	bl	0 <htons>
  5c:	7228      	strb	r0, [r5, #8]
  5e:	f3c0 200f 	ubfx	r0, r0, #8, #16
  62:	7268      	strb	r0, [r5, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:582

    ip_addr_set(&(iphdr->dest), dest);
  64:	7872      	ldrb	r2, [r6, #1]
  66:	7833      	ldrb	r3, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:587

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
  68:	4c34      	ldr	r4, [pc, #208]	(13c <ip_output_if+0x13c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:582
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);

    ip_addr_set(&(iphdr->dest), dest);
  6a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  6e:	78b2      	ldrb	r2, [r6, #2]
  70:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  74:	78f2      	ldrb	r2, [r6, #3]
  76:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  7a:	f3c3 2207 	ubfx	r2, r3, #8, #8
  7e:	742b      	strb	r3, [r5, #16]
  80:	746a      	strb	r2, [r5, #17]
  82:	f3c3 4207 	ubfx	r2, r3, #16, #8
  86:	0e1b      	lsrs	r3, r3, #24
  88:	74aa      	strb	r2, [r5, #18]
  8a:	74eb      	strb	r3, [r5, #19]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:584

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
  8c:	9b01      	ldr	r3, [sp, #4]
  8e:	f443 408a 	orr.w	r0, r3, #17664	; 0x4500
  92:	f7ff fffe 	bl	0 <htons>
  96:	7028      	strb	r0, [r5, #0]
  98:	f3c0 200f 	ubfx	r0, r0, #8, #16
  9c:	7068      	strb	r0, [r5, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:585
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  9e:	f8b8 0008 	ldrh.w	r0, [r8, #8]
  a2:	f7ff fffe 	bl	0 <htons>
  a6:	70a8      	strb	r0, [r5, #2]
  a8:	f3c0 200f 	ubfx	r0, r0, #8, #16
  ac:	70e8      	strb	r0, [r5, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:586
    IPH_OFFSET_SET(iphdr, 0);
  ae:	f885 b006 	strb.w	fp, [r5, #6]
  b2:	f885 b007 	strb.w	fp, [r5, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:587
    IPH_ID_SET(iphdr, htons(ip_id));
  b6:	8920      	ldrh	r0, [r4, #8]
  b8:	f7ff fffe 	bl	0 <htons>
  bc:	7128      	strb	r0, [r5, #4]
  be:	f3c0 200f 	ubfx	r0, r0, #8, #16
  c2:	7168      	strb	r0, [r5, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:588
    ++ip_id;
  c4:	8923      	ldrh	r3, [r4, #8]
  c6:	3301      	adds	r3, #1
  c8:	8123      	strh	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:590

    if (ip_addr_isany(src)) {
  ca:	b157      	cbz	r7, e2 <ip_output_if+0xe2>
  cc:	787b      	ldrb	r3, [r7, #1]
  ce:	783a      	ldrb	r2, [r7, #0]
  d0:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  d4:	78bb      	ldrb	r3, [r7, #2]
  d6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  da:	78fb      	ldrb	r3, [r7, #3]
  dc:	ea52 6203 	orrs.w	r2, r2, r3, lsl #24
  e0:	d105      	bne.n	ee <ip_output_if+0xee>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:591
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  e2:	f119 0304 	adds.w	r3, r9, #4	; 0x4
  e6:	bf14      	ite	ne
  e8:	f8d9 2004 	ldrne.w	r2, [r9, #4]
  ec:	461a      	moveq	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:593
    } else {
      ip_addr_set(&(iphdr->src), src);
  ee:	f3c2 2307 	ubfx	r3, r2, #8, #8
  f2:	736b      	strb	r3, [r5, #13]
  f4:	f3c2 4307 	ubfx	r3, r2, #16, #8
  f8:	73ab      	strb	r3, [r5, #14]
  fa:	0e13      	lsrs	r3, r2, #24
  fc:	73eb      	strb	r3, [r5, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:596
    }

    IPH_CHKSUM_SET(iphdr, 0);
  fe:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:593
    ++ip_id;

    if (ip_addr_isany(src)) {
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
 100:	732a      	strb	r2, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:596
    }

    IPH_CHKSUM_SET(iphdr, 0);
 102:	72ab      	strb	r3, [r5, #10]
 104:	72eb      	strb	r3, [r5, #11]
 106:	e002      	b.n	10e <ip_output_if+0x10e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:603
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
 108:	6843      	ldr	r3, [r0, #4]
 10a:	f103 0610 	add.w	r6, r3, #16	; 0x10
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:608
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
 10e:	f8b9 202c 	ldrh.w	r2, [r9, #44]
 112:	b14a      	cbz	r2, 128 <ip_output_if+0x128>
 114:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 118:	4293      	cmp	r3, r2
 11a:	d905      	bls.n	128 <ip_output_if+0x128>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:609
    return ip_frag(p,netif,dest);
 11c:	4640      	mov	r0, r8
 11e:	4649      	mov	r1, r9
 120:	4632      	mov	r2, r6
 122:	f7ff fffe 	bl	0 <ip_frag>
 126:	e005      	b.n	134 <ip_output_if+0x134>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:628
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
 128:	f8d9 3014 	ldr.w	r3, [r9, #20]
 12c:	4648      	mov	r0, r9
 12e:	4641      	mov	r1, r8
 130:	4632      	mov	r2, r6
 132:	4798      	blx	r3
 134:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:630
  }
}
 136:	b240      	sxtb	r0, r0
 138:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 13c:	00000000 	.word	0x00000000
Disassembly of section .text.ip_route:

00000000 <ip_route>:
ip_route():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:115
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
   0:	4b11      	ldr	r3, [pc, #68]	(48 <ip_route+0x48>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:111
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:115
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
   6:	681c      	ldr	r4, [r3, #0]
   8:	e013      	b.n	32 <ip_route+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:117
    /* network mask matches? */
    if (netif_is_up(netif)) {
   a:	4620      	mov	r0, r4
   c:	f7ff fffe 	bl	0 <netif_is_up>
  10:	b170      	cbz	r0, 30 <ip_route+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:118
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  12:	786a      	ldrb	r2, [r5, #1]
  14:	782b      	ldrb	r3, [r5, #0]
  16:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  1a:	78aa      	ldrb	r2, [r5, #2]
  1c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  20:	78ea      	ldrb	r2, [r5, #3]
  22:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  26:	6862      	ldr	r2, [r4, #4]
  28:	4053      	eors	r3, r2
  2a:	68a2      	ldr	r2, [r4, #8]
  2c:	4213      	tst	r3, r2
  2e:	d009      	beq.n	44 <ip_route+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:115
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  30:	6824      	ldr	r4, [r4, #0]
  32:	2c00      	cmp	r4, #0
  34:	d1e9      	bne.n	a <ip_route+0xa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:124
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  36:	4d05      	ldr	r5, [pc, #20]	(4c <ip_route+0x4c>)
  38:	6828      	ldr	r0, [r5, #0]
  3a:	b118      	cbz	r0, 44 <ip_route+0x44>
  3c:	f7ff fffe 	bl	0 <netif_is_up>
  40:	b100      	cbz	r0, 44 <ip_route+0x44>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:131
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  42:	682c      	ldr	r4, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:132
}
  44:	4620      	mov	r0, r4
  46:	bd70      	pop	{r4, r5, r6, pc}
	...
Disassembly of section .text.ip_output:

00000000 <ip_output>:
ip_output():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:652
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	4607      	mov	r7, r0
   6:	b085      	sub	sp, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:655
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
   8:	4610      	mov	r0, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:652
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
   a:	4688      	mov	r8, r1
   c:	4616      	mov	r6, r2
   e:	4699      	mov	r9, r3
  10:	f89d 4030 	ldrb.w	r4, [sp, #48]
  14:	f89d 5034 	ldrb.w	r5, [sp, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:655
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  18:	f7ff fffe 	bl	0 <ip_output>
  1c:	b908      	cbnz	r0, 22 <ip_output+0x22>
  1e:	30fc      	adds	r0, #252
  20:	e009      	b.n	36 <ip_output+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:661
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  22:	9002      	str	r0, [sp, #8]
  24:	4641      	mov	r1, r8
  26:	4638      	mov	r0, r7
  28:	4632      	mov	r2, r6
  2a:	464b      	mov	r3, r9
  2c:	9400      	str	r4, [sp, #0]
  2e:	9501      	str	r5, [sp, #4]
  30:	f7ff fffe 	bl	0 <ip_output>
  34:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:662
}
  36:	b240      	sxtb	r0, r0
  38:	b005      	add	sp, #20
  3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  3e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.ip_input:

00000000 <ip_input>:
ip_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:218
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:231

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
   4:	6846      	ldr	r6, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:218
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
   6:	4680      	mov	r8, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:232
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  if (IPH_V(iphdr) != 4) {
   8:	7873      	ldrb	r3, [r6, #1]
   a:	7830      	ldrb	r0, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:218
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
   c:	4689      	mov	r9, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:232
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  if (IPH_V(iphdr) != 4) {
   e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  12:	f7ff fffe 	bl	0 <ntohs>
  16:	f3c0 300f 	ubfx	r0, r0, #12, #16
  1a:	2804      	cmp	r0, #4
  1c:	d176      	bne.n	10c <ip_input+0x10c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:243
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  1e:	7833      	ldrb	r3, [r6, #0]
  20:	7870      	ldrb	r0, [r6, #1]
  22:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  26:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:245
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  2a:	f3c0 2003 	ubfx	r0, r0, #8, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:247
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  2e:	78b3      	ldrb	r3, [r6, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:245
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  30:	ea4f 0a80 	mov.w	sl, r0, lsl #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:247
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  34:	78f0      	ldrb	r0, [r6, #3]
  36:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  3a:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:250

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  3e:	f8b8 300a 	ldrh.w	r3, [r8, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:247
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  42:	4601      	mov	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:250

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  44:	4553      	cmp	r3, sl
  46:	d361      	bcc.n	10c <ip_input+0x10c>
  48:	f8b8 3008 	ldrh.w	r3, [r8, #8]
  4c:	4283      	cmp	r3, r0
  4e:	d35d      	bcc.n	10c <ip_input+0x10c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:282
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  50:	4640      	mov	r0, r8
  52:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:310
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  56:	f106 0510 	add.w	r5, r6, #16	; 0x10
  5a:	464f      	mov	r7, r9
  5c:	2401      	movs	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:308
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  5e:	4638      	mov	r0, r7
  60:	f7ff fffe 	bl	0 <netif_is_up>
  64:	b1a8      	cbz	r0, 92 <ip_input+0x92>
  66:	f117 0f04 	cmn.w	r7, #4	; 0x4
  6a:	d012      	beq.n	92 <ip_input+0x92>
  6c:	6879      	ldr	r1, [r7, #4]
  6e:	b181      	cbz	r1, 92 <ip_input+0x92>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:310
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  70:	7c72      	ldrb	r2, [r6, #17]
  72:	7c33      	ldrb	r3, [r6, #16]
  74:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  78:	7cb2      	ldrb	r2, [r6, #18]
  7a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  7e:	7cf2      	ldrb	r2, [r6, #19]
  80:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  84:	428b      	cmp	r3, r1
  86:	d022      	beq.n	ce <ip_input+0xce>
  88:	4628      	mov	r0, r5
  8a:	4639      	mov	r1, r7
  8c:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  90:	b9e8      	cbnz	r0, ce <ip_input+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:319
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  92:	b114      	cbz	r4, 9a <ip_input+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:321
        first = 0;
        netif = netif_list;
  94:	4b51      	ldr	r3, [pc, #324]	(1dc <ip_input+0x1dc>)
  96:	681f      	ldr	r7, [r3, #0]
  98:	e000      	b.n	9c <ip_input+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:323
      } else {
        netif = netif->next;
  9a:	683f      	ldr	r7, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:325
      }
      if (netif == inp) {
  9c:	454f      	cmp	r7, r9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:326
        netif = netif->next;
  9e:	bf08      	it	eq
  a0:	683f      	ldreq	r7, [r7, #0]
  a2:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:328
      }
    } while(netif != NULL);
  a4:	2f00      	cmp	r7, #0
  a6:	d1da      	bne.n	5e <ip_input+0x5e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:338
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  a8:	7a30      	ldrb	r0, [r6, #8]
  aa:	7a73      	ldrb	r3, [r6, #9]
  ac:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  b0:	f7ff fffe 	bl	0 <ntohs>
  b4:	b2c0      	uxtb	r0, r0
  b6:	2811      	cmp	r0, #17
  b8:	d109      	bne.n	ce <ip_input+0xce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:341
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  ba:	eb06 030a 	add.w	r3, r6, sl
  be:	789a      	ldrb	r2, [r3, #2]
  c0:	78d8      	ldrb	r0, [r3, #3]
  c2:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  c6:	f7ff fffe 	bl	0 <ntohs>
  ca:	2844      	cmp	r0, #68
  cc:	d01c      	beq.n	108 <ip_input+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:354

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  ce:	f106 000c 	add.w	r0, r6, #12	; 0xc
  d2:	4649      	mov	r1, r9
  d4:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  d8:	b9c0      	cbnz	r0, 10c <ip_input+0x10c>
  da:	7b73      	ldrb	r3, [r6, #13]
  dc:	7b34      	ldrb	r4, [r6, #12]
  de:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
  e2:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  e6:	7bb3      	ldrb	r3, [r6, #14]
  e8:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  ec:	7bf3      	ldrb	r3, [r6, #15]
  ee:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  f2:	f7ff fffe 	bl	0 <ntohl>
  f6:	4605      	mov	r5, r0
  f8:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  fc:	f7ff fffe 	bl	0 <ntohl>
 100:	4025      	ands	r5, r4
 102:	4285      	cmp	r5, r0
 104:	d101      	bne.n	10a <ip_input+0x10a>
 106:	e001      	b.n	10c <ip_input+0x10c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:363
      /* free (drop) packet pbufs */
      pbuf_free(p);
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 108:	464f      	mov	r7, r9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:368
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 10a:	b91f      	cbnz	r7, 114 <ip_input+0x114>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:382
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 10c:	4640      	mov	r0, r8
 10e:	f7ff fffe 	bl	0 <pbuf_free>
 112:	e060      	b.n	1d6 <ip_input+0x1d6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:386
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
 114:	79b4      	ldrb	r4, [r6, #6]
 116:	79f3      	ldrb	r3, [r6, #7]
 118:	f643 70ff 	movw	r0, #16383	; 0x3fff
 11c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 120:	f7ff fffe 	bl	0 <htons>
 124:	4220      	tst	r0, r4
 126:	d006      	beq.n	136 <ip_input+0x136>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:391
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 128:	4640      	mov	r0, r8
 12a:	f7ff fffe 	bl	0 <ip_reass>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:393
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 12e:	4680      	mov	r8, r0
 130:	2800      	cmp	r0, #0
 132:	d050      	beq.n	1d6 <ip_input+0x1d6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:396
      return ERR_OK;
    }
    iphdr = p->payload;
 134:	6846      	ldr	r6, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:432
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 136:	4b2a      	ldr	r3, [pc, #168]	(1e0 <ip_input+0x1e0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:437
  current_header = iphdr;

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 138:	4640      	mov	r0, r8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:432
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 13a:	f8c3 9000 	str.w	r9, [r3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:433
  current_header = iphdr;
 13e:	605e      	str	r6, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:437

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 140:	4649      	mov	r1, r9
 142:	f7ff fffe 	bl	0 <raw_input>
 146:	2800      	cmp	r0, #0
 148:	d141      	bne.n	1ce <ip_input+0x1ce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:441
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
 14a:	7a33      	ldrb	r3, [r6, #8]
 14c:	7a70      	ldrb	r0, [r6, #9]
 14e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 152:	f7ff fffe 	bl	0 <ntohs>
 156:	b2c0      	uxtb	r0, r0
 158:	2806      	cmp	r0, #6
 15a:	d009      	beq.n	170 <ip_input+0x170>
 15c:	2811      	cmp	r0, #17
 15e:	d002      	beq.n	166 <ip_input+0x166>
 160:	2801      	cmp	r0, #1
 162:	d10f      	bne.n	184 <ip_input+0x184>
 164:	e009      	b.n	17a <ip_input+0x17a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:448
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 166:	4640      	mov	r0, r8
 168:	4649      	mov	r1, r9
 16a:	f7ff fffe 	bl	0 <udp_input>
 16e:	e02e      	b.n	1ce <ip_input+0x1ce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:454
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 170:	4640      	mov	r0, r8
 172:	4649      	mov	r1, r9
 174:	f7ff fffe 	bl	0 <tcp_input>
 178:	e029      	b.n	1ce <ip_input+0x1ce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:460
      break;
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 17a:	4640      	mov	r0, r8
 17c:	4649      	mov	r1, r9
 17e:	f7ff fffe 	bl	0 <icmp_input>
 182:	e024      	b.n	1ce <ip_input+0x1ce>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:471
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
 184:	f106 0010 	add.w	r0, r6, #16	; 0x10
 188:	4649      	mov	r1, r9
 18a:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
 18e:	b9d8      	cbnz	r0, 1c8 <ip_input+0x1c8>
 190:	7c73      	ldrb	r3, [r6, #17]
 192:	7c34      	ldrb	r4, [r6, #16]
 194:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
 198:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 19c:	7cb3      	ldrb	r3, [r6, #18]
 19e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1a2:	7cf3      	ldrb	r3, [r6, #19]
 1a4:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
 1a8:	f7ff fffe 	bl	0 <ntohl>
 1ac:	4605      	mov	r5, r0
 1ae:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 1b2:	f7ff fffe 	bl	0 <ntohl>
 1b6:	4025      	ands	r5, r4
 1b8:	4285      	cmp	r5, r0
 1ba:	d005      	beq.n	1c8 <ip_input+0x1c8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:473
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
 1bc:	f8c8 6004 	str.w	r6, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:474
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 1c0:	4640      	mov	r0, r8
 1c2:	2102      	movs	r1, #2
 1c4:	f7ff fffe 	bl	0 <icmp_dest_unreach>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:477
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 1c8:	4640      	mov	r0, r8
 1ca:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:487
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 1ce:	4a04      	ldr	r2, [pc, #16]	(1e0 <ip_input+0x1e0>)
 1d0:	2300      	movs	r3, #0
 1d2:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:488
  current_header = NULL;
 1d4:	6053      	str	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/ip.c:491

  return ERR_OK;
}
 1d6:	2000      	movs	r0, #0
 1d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...
