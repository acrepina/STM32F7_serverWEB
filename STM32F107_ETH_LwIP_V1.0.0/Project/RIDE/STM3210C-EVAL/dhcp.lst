
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\dhcp.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\dhcp.o

Disassembly of section .text.dhcp_set_state:

00000000 <dhcp_set_state>:
dhcp_set_state():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1159
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
   0:	7803      	ldrb	r3, [r0, #0]
   2:	428b      	cmp	r3, r1
   4:	d002      	beq.n	c <dhcp_set_state+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1161
    dhcp->state = new_state;
    dhcp->tries = 0;
   6:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1160
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
   8:	7001      	strb	r1, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1161
    dhcp->tries = 0;
   a:	7043      	strb	r3, [r0, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1163
  }
}
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_option:

00000000 <dhcp_option>:
dhcp_option():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1172
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1174
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
   2:	6a03      	ldr	r3, [r0, #32]
   4:	8c84      	ldrh	r4, [r0, #36]
   6:	191b      	adds	r3, r3, r4
   8:	f883 10f0 	strb.w	r1, [r3, #240]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1175
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
   c:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1174
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
   e:	3401      	adds	r4, #1
  10:	b2a4      	uxth	r4, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1175
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  12:	191b      	adds	r3, r3, r4
  14:	3401      	adds	r4, #1
  16:	f883 20f0 	strb.w	r2, [r3, #240]
  1a:	8484      	strh	r4, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1176
}
  1c:	bd10      	pop	{r4, pc}
  1e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_option_byte:

00000000 <dhcp_option_byte>:
dhcp_option_byte():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1185
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
   0:	8c82      	ldrh	r2, [r0, #36]
   2:	6a03      	ldr	r3, [r0, #32]
   4:	189b      	adds	r3, r3, r2
   6:	3201      	adds	r2, #1
   8:	f883 10f0 	strb.w	r1, [r3, #240]
   c:	8482      	strh	r2, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1186
}
   e:	4770      	bx	lr
Disassembly of section .text.dhcp_option_short:

00000000 <dhcp_option_short>:
dhcp_option_short():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1192

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
   0:	8c82      	ldrh	r2, [r0, #36]
   2:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1190
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
   4:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1192
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
   6:	189b      	adds	r3, r3, r2
   8:	0a0c      	lsrs	r4, r1, #8
   a:	f883 40f0 	strb.w	r4, [r3, #240]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1193
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
   e:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1192

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  10:	3201      	adds	r2, #1
  12:	b292      	uxth	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1193
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  14:	189b      	adds	r3, r3, r2
  16:	3201      	adds	r2, #1
  18:	f883 10f0 	strb.w	r1, [r3, #240]
  1c:	8482      	strh	r2, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1194
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.dhcp_option_long:

00000000 <dhcp_option_long>:
dhcp_option_long():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1200

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
   0:	8c82      	ldrh	r2, [r0, #36]
   2:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1198
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
   4:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1200
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
   6:	189b      	adds	r3, r3, r2
   8:	0e0c      	lsrs	r4, r1, #24
   a:	f883 40f0 	strb.w	r4, [r3, #240]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1201
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
   e:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1200

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  10:	3201      	adds	r2, #1
  12:	b292      	uxth	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1201
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  14:	189b      	adds	r3, r3, r2
  16:	f3c1 4407 	ubfx	r4, r1, #16, #8
  1a:	f883 40f0 	strb.w	r4, [r3, #240]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1202
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  1e:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1201
static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  20:	3201      	adds	r2, #1
  22:	b292      	uxth	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1202
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  24:	189b      	adds	r3, r3, r2
  26:	f3c1 2407 	ubfx	r4, r1, #8, #8
  2a:	f883 40f0 	strb.w	r4, [r3, #240]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1203
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  2e:	6a03      	ldr	r3, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1202
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  30:	3201      	adds	r2, #1
  32:	b292      	uxth	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1203
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  34:	189b      	adds	r3, r3, r2
  36:	3201      	adds	r2, #1
  38:	f883 10f0 	strb.w	r1, [r3, #240]
  3c:	8482      	strh	r2, [r0, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1204
}
  3e:	bd10      	pop	{r4, pc}
Disassembly of section .text.dhcp_option_trailer:

00000000 <dhcp_option_trailer>:
dhcp_option_trailer():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1487
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1488
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
   2:	4604      	mov	r4, r0
   4:	b1a8      	cbz	r0, 32 <dhcp_option_trailer+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1491
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
   6:	8c83      	ldrh	r3, [r0, #36]
   8:	6a02      	ldr	r2, [r0, #32]
   a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   e:	18d2      	adds	r2, r2, r3
  10:	f882 10f0 	strb.w	r1, [r2, #240]
  14:	3301      	adds	r3, #1
  16:	e005      	b.n	24 <dhcp_option_trailer+0x24>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1497
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  18:	6a23      	ldr	r3, [r4, #32]
  1a:	2200      	movs	r2, #0
  1c:	185b      	adds	r3, r3, r1
  1e:	f883 20f0 	strb.w	r2, [r3, #240]
  22:	1c4b      	adds	r3, r1, #1
  24:	84a3      	strh	r3, [r4, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1493
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  26:	8ca1      	ldrh	r1, [r4, #36]
  28:	2943      	cmp	r1, #67
  2a:	d9f5      	bls.n	18 <dhcp_option_trailer+0x18>
  2c:	f011 0f03 	tst.w	r1, #3	; 0x3
  30:	d1f2      	bne.n	18 <dhcp_option_trailer+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1499
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  32:	bd10      	pop	{r4, pc}
Disassembly of section .text.dhcp_get_option_ptr:

00000000 <dhcp_get_option_ptr>:
dhcp_get_option_ptr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1511
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1515
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
   4:	6940      	ldr	r0, [r0, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1511
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
   6:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1515
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
   8:	2800      	cmp	r0, #0
   a:	d03c      	beq.n	86 <dhcp_get_option_ptr+0x86>
   c:	8b25      	ldrh	r5, [r4, #24]
   e:	2d00      	cmp	r5, #0
  10:	d039      	beq.n	86 <dhcp_get_option_ptr+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1517
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  12:	2100      	movs	r1, #0
  14:	460b      	mov	r3, r1
  16:	e00e      	b.n	36 <dhcp_get_option_ptr+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1523
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  18:	2a34      	cmp	r2, #52
  1a:	d104      	bne.n	26 <dhcp_get_option_ptr+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1526
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  1c:	3302      	adds	r3, #2
  1e:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1527
        overload = options[offset++];
  20:	5cc1      	ldrb	r1, [r0, r3]
  22:	3301      	adds	r3, #1
  24:	e006      	b.n	34 <dhcp_get_option_ptr+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1530
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  26:	42b2      	cmp	r2, r6
  28:	d02f      	beq.n	8a <dhcp_get_option_ptr+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1537
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  2a:	3301      	adds	r3, #1
  2c:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1539
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  2e:	5cc2      	ldrb	r2, [r0, r3]
  30:	3301      	adds	r3, #1
  32:	189b      	adds	r3, r3, r2
  34:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1520
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  36:	42ab      	cmp	r3, r5
  38:	d204      	bcs.n	44 <dhcp_get_option_ptr+0x44>
  3a:	5cc2      	ldrb	r2, [r0, r3]
  3c:	eb00 0c03 	add.w	ip, r0, r3
  40:	2aff      	cmp	r2, #255
  42:	d1e9      	bne.n	18 <dhcp_get_option_ptr+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1543
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  44:	b1f9      	cbz	r1, 86 <dhcp_get_option_ptr+0x86>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1545
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  46:	2901      	cmp	r1, #1
  48:	d104      	bne.n	54 <dhcp_get_option_ptr+0x54>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1547
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  4a:	6923      	ldr	r3, [r4, #16]
  4c:	317f      	adds	r1, #127
  4e:	f103 006c 	add.w	r0, r3, #108	; 0x6c
  52:	e007      	b.n	64 <dhcp_get_option_ptr+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1549
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  54:	2902      	cmp	r1, #2
  56:	6920      	ldr	r0, [r4, #16]
  58:	d102      	bne.n	60 <dhcp_get_option_ptr+0x60>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1551
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  5a:	302c      	adds	r0, #44
  5c:	313e      	adds	r1, #62
  5e:	e001      	b.n	64 <dhcp_get_option_ptr+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1556
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  60:	302c      	adds	r0, #44
  62:	21c0      	movs	r1, #192
  64:	2300      	movs	r3, #0
  66:	e009      	b.n	7c <dhcp_get_option_ptr+0x7c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1563
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
        if (options[offset] == option_type) {
  68:	42b2      	cmp	r2, r6
  6a:	d00e      	beq.n	8a <dhcp_get_option_ptr+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1570
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  6c:	3301      	adds	r3, #1
  6e:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1571
          offset += 1 + options[offset];
  70:	5cc2      	ldrb	r2, [r0, r3]
  72:	3301      	adds	r3, #1
  74:	189b      	adds	r3, r3, r2
  76:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1562
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  78:	428b      	cmp	r3, r1
  7a:	d204      	bcs.n	86 <dhcp_get_option_ptr+0x86>
  7c:	5cc2      	ldrb	r2, [r0, r3]
  7e:	eb00 0c03 	add.w	ip, r0, r3
  82:	2aff      	cmp	r2, #255
  84:	d1f0      	bne.n	68 <dhcp_get_option_ptr+0x68>
  86:	f04f 0c00 	mov.w	ip, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1577
        }
      }
    }
  }
  return NULL;
}
  8a:	4660      	mov	r0, ip
  8c:	bd70      	pop	{r4, r5, r6, pc}
  8e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_get_option_long:

00000000 <dhcp_get_option_long>:
dhcp_get_option_long():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1625
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
   0:	4602      	mov	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1626
  value |= (u32_t)(*ptr++) << 16;
   2:	7840      	ldrb	r0, [r0, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1625
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
   4:	f812 3b01 	ldrb.w	r3, [r2], #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1626
  value |= (u32_t)(*ptr++) << 16;
   8:	0400      	lsls	r0, r0, #16
   a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1627
  value |= (u32_t)(*ptr++) << 8;
   e:	7853      	ldrb	r3, [r2, #1]
  10:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  14:	7893      	ldrb	r3, [r2, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1631
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  16:	4318      	orrs	r0, r3
  18:	4770      	bx	lr
  1a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_delete_request:

00000000 <dhcp_delete_request>:
dhcp_delete_request():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1463
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1465
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
   2:	b140      	cbz	r0, 16 <dhcp_delete_request+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1466
  dhcp = netif->dhcp;
   4:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1467
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
   6:	b134      	cbz	r4, 16 <dhcp_delete_request+0x16>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1470
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
   8:	69e0      	ldr	r0, [r4, #28]
   a:	b108      	cbz	r0, 10 <dhcp_delete_request+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1471
    pbuf_free(dhcp->p_out);
   c:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1473
  }
  dhcp->p_out = NULL;
  10:	2300      	movs	r3, #0
  12:	61e3      	str	r3, [r4, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1474
  dhcp->msg_out = NULL;
  14:	6223      	str	r3, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1475
}
  16:	bd10      	pop	{r4, pc}
Disassembly of section .text.dhcp_free_reply:

00000000 <dhcp_free_reply>:
dhcp_free_reply():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1264
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1265
  if (dhcp->msg_in != NULL) {
   4:	6900      	ldr	r0, [r0, #16]
   6:	b118      	cbz	r0, 10 <dhcp_free_reply+0x10>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1266
    mem_free((void *)dhcp->msg_in);
   8:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1267
    dhcp->msg_in = NULL;
   c:	2300      	movs	r3, #0
   e:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1269
  }
  if (dhcp->options_in) {
  10:	6960      	ldr	r0, [r4, #20]
  12:	b120      	cbz	r0, 1e <dhcp_free_reply+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1270
    mem_free((void *)dhcp->options_in);
  14:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1271
    dhcp->options_in = NULL;
  18:	2300      	movs	r3, #0
  1a:	6163      	str	r3, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1272
    dhcp->options_in_len = 0;
  1c:	8323      	strh	r3, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1275
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  1e:	bd10      	pop	{r4, pc}
Disassembly of section .text.dhcp_stop:

00000000 <dhcp_stop>:
dhcp_stop():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1118
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1122
  struct dhcp *dhcp = netif->dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   2:	f890 302e 	ldrb.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1119
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
   6:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1122
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   8:	f023 0308 	bic.w	r3, r3, #8	; 0x8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1118
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
   c:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1122
  struct dhcp *dhcp = netif->dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   e:	f880 302e 	strb.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1126

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  12:	b19c      	cbz	r4, 3c <dhcp_stop+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1134
    autoip_stop(netif);
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
  14:	68a0      	ldr	r0, [r4, #8]
  16:	b118      	cbz	r0, 20 <dhcp_stop+0x20>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1135
      udp_remove(dhcp->pcb);
  18:	f7ff fffe 	bl	0 <udp_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1136
      dhcp->pcb = NULL;
  1c:	2300      	movs	r3, #0
  1e:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1138
    }
    if (dhcp->p != NULL) {
  20:	68e0      	ldr	r0, [r4, #12]
  22:	b118      	cbz	r0, 2c <dhcp_stop+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1139
      pbuf_free(dhcp->p);
  24:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1140
      dhcp->p = NULL;
  28:	2300      	movs	r3, #0
  2a:	60e3      	str	r3, [r4, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1143
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  2c:	4620      	mov	r0, r4
  2e:	f7ff fffe 	bl	0 <dhcp_stop>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1144
    mem_free((void *)dhcp);
  32:	4620      	mov	r0, r4
  34:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1145
    netif->dhcp = NULL;
  38:	2300      	movs	r3, #0
  3a:	622b      	str	r3, [r5, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1147
  }
}
  3c:	bd70      	pop	{r4, r5, r6, pc}
  3e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_create_request:

00000000 <dhcp_create_request>:
dhcp_create_request():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1382
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1399
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
   4:	4607      	mov	r7, r0
   6:	b908      	cbnz	r0, c <dhcp_create_request+0xc>
   8:	30f6      	adds	r0, #246
   a:	e099      	b.n	140 <dhcp_create_request+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1400
  dhcp = netif->dhcp;
   c:	6a06      	ldr	r6, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1401
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
   e:	b90e      	cbnz	r6, 14 <dhcp_create_request+0x14>
  10:	20f7      	movs	r0, #247
  12:	e095      	b.n	140 <dhcp_create_request+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1404
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  14:	2000      	movs	r0, #0
  16:	f44f 719a 	mov.w	r1, #308	; 0x134
  1a:	4602      	mov	r2, r0
  1c:	f7ff fffe 	bl	0 <pbuf_alloc>
  20:	61f0      	str	r0, [r6, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1405
  if (dhcp->p_out == NULL) {
  22:	b908      	cbnz	r0, 28 <dhcp_create_request+0x28>
  24:	30ff      	adds	r0, #255
  26:	e08b      	b.n	140 <dhcp_create_request+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1413
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
  28:	7873      	ldrb	r3, [r6, #1]
  2a:	b91b      	cbnz	r3, 34 <dhcp_create_request+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1414
      xid++;
  2c:	4a46      	ldr	r2, [pc, #280]	(148 <dhcp_create_request+0x148>)
  2e:	6813      	ldr	r3, [r2, #0]
  30:	3301      	adds	r3, #1
  32:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1415
  dhcp->xid = xid;
  34:	4b44      	ldr	r3, [pc, #272]	(148 <dhcp_create_request+0x148>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1421
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  36:	2201      	movs	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1415
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
      xid++;
  dhcp->xid = xid;
  38:	681b      	ldr	r3, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1426
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  dhcp->msg_out->hops = 0;
  3a:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1415
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries==0)
      xid++;
  dhcp->xid = xid;
  3c:	6073      	str	r3, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1419
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  3e:	69f3      	ldr	r3, [r6, #28]
  40:	685b      	ldr	r3, [r3, #4]
  42:	6233      	str	r3, [r6, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1421

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  44:	701a      	strb	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1423
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  46:	6a33      	ldr	r3, [r6, #32]
  48:	705a      	strb	r2, [r3, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1425
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  4a:	6a32      	ldr	r2, [r6, #32]
  4c:	2306      	movs	r3, #6
  4e:	7093      	strb	r3, [r2, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1426
  dhcp->msg_out->hops = 0;
  50:	6a33      	ldr	r3, [r6, #32]
  52:	70dc      	strb	r4, [r3, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1427
  dhcp->msg_out->xid = htonl(dhcp->xid);
  54:	6870      	ldr	r0, [r6, #4]
  56:	6a35      	ldr	r5, [r6, #32]
  58:	f7ff fffe 	bl	0 <htonl>
  5c:	f3c0 2307 	ubfx	r3, r0, #8, #8
  60:	7128      	strb	r0, [r5, #4]
  62:	716b      	strb	r3, [r5, #5]
  64:	f3c0 4307 	ubfx	r3, r0, #16, #8
  68:	0e00      	lsrs	r0, r0, #24
  6a:	71ab      	strb	r3, [r5, #6]
  6c:	71e8      	strb	r0, [r5, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1428
  dhcp->msg_out->secs = 0;
  6e:	6a33      	ldr	r3, [r6, #32]
  70:	721c      	strb	r4, [r3, #8]
  72:	725c      	strb	r4, [r3, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1429
  dhcp->msg_out->flags = 0;
  74:	6a33      	ldr	r3, [r6, #32]
  76:	729c      	strb	r4, [r3, #10]
  78:	72dc      	strb	r4, [r3, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1430
  dhcp->msg_out->ciaddr.addr = 0;
  7a:	6a33      	ldr	r3, [r6, #32]
  7c:	731c      	strb	r4, [r3, #12]
  7e:	735c      	strb	r4, [r3, #13]
  80:	739c      	strb	r4, [r3, #14]
  82:	73dc      	strb	r4, [r3, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1431
  if (dhcp->state==DHCP_BOUND || dhcp->state==DHCP_RENEWING || dhcp->state==DHCP_REBINDING) {
  84:	7833      	ldrb	r3, [r6, #0]
  86:	2b0a      	cmp	r3, #10
  88:	d003      	beq.n	92 <dhcp_create_request+0x92>
  8a:	2b05      	cmp	r3, #5
  8c:	d001      	beq.n	92 <dhcp_create_request+0x92>
  8e:	2b04      	cmp	r3, #4
  90:	d108      	bne.n	a4 <dhcp_create_request+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1432
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  92:	793b      	ldrb	r3, [r7, #4]
  94:	6a32      	ldr	r2, [r6, #32]
  96:	7313      	strb	r3, [r2, #12]
  98:	797b      	ldrb	r3, [r7, #5]
  9a:	7353      	strb	r3, [r2, #13]
  9c:	79bb      	ldrb	r3, [r7, #6]
  9e:	7393      	strb	r3, [r2, #14]
  a0:	79fb      	ldrb	r3, [r7, #7]
  a2:	73d3      	strb	r3, [r2, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1434
  }
  dhcp->msg_out->yiaddr.addr = 0;
  a4:	6a32      	ldr	r2, [r6, #32]
  a6:	2300      	movs	r3, #0
  a8:	7413      	strb	r3, [r2, #16]
  aa:	7453      	strb	r3, [r2, #17]
  ac:	7493      	strb	r3, [r2, #18]
  ae:	74d3      	strb	r3, [r2, #19]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1435
  dhcp->msg_out->siaddr.addr = 0;
  b0:	6a32      	ldr	r2, [r6, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1436
  dhcp->msg_out->giaddr.addr = 0;
  b2:	4619      	mov	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1435
  dhcp->msg_out->ciaddr.addr = 0;
  if (dhcp->state==DHCP_BOUND || dhcp->state==DHCP_RENEWING || dhcp->state==DHCP_REBINDING) {
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  }
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  b4:	7513      	strb	r3, [r2, #20]
  b6:	7553      	strb	r3, [r2, #21]
  b8:	7593      	strb	r3, [r2, #22]
  ba:	75d3      	strb	r3, [r2, #23]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1436
  dhcp->msg_out->giaddr.addr = 0;
  bc:	6a32      	ldr	r2, [r6, #32]
  be:	7613      	strb	r3, [r2, #24]
  c0:	7653      	strb	r3, [r2, #25]
  c2:	7693      	strb	r3, [r2, #26]
  c4:	76d3      	strb	r3, [r2, #27]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1439
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  c6:	f897 2024 	ldrb.w	r2, [r7, #36]
  ca:	b28b      	uxth	r3, r1
  cc:	429a      	cmp	r2, r3
  ce:	6a30      	ldr	r0, [r6, #32]
  d0:	d801      	bhi.n	d6 <dhcp_create_request+0xd6>
  d2:	2200      	movs	r2, #0
  d4:	e002      	b.n	dc <dhcp_create_request+0xdc>
  d6:	187b      	adds	r3, r7, r1
  d8:	f893 2025 	ldrb.w	r2, [r3, #37]
  dc:	1843      	adds	r3, r0, r1
  de:	3101      	adds	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1437
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  }
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  e0:	2910      	cmp	r1, #16
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1439
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  e2:	771a      	strb	r2, [r3, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1437
    dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  }
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  e4:	d1ef      	bne.n	c6 <dhcp_create_request+0xc6>
  e6:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1442
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  e8:	6a33      	ldr	r3, [r6, #32]
  ea:	2100      	movs	r1, #0
  ec:	189b      	adds	r3, r3, r2
  ee:	3201      	adds	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1441
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  f0:	2a40      	cmp	r2, #64
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1442
    dhcp->msg_out->sname[i] = 0;
  f2:	f883 102c 	strb.w	r1, [r3, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1441
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  f6:	d1f7      	bne.n	e8 <dhcp_create_request+0xe8>
  f8:	460a      	mov	r2, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1445
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  fa:	6a33      	ldr	r3, [r6, #32]
  fc:	2500      	movs	r5, #0
  fe:	189b      	adds	r3, r3, r2
 100:	3201      	adds	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1444
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 102:	2a80      	cmp	r2, #128
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1445
    dhcp->msg_out->file[i] = 0;
 104:	f883 506c 	strb.w	r5, [r3, #108]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1444
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 108:	d1f7      	bne.n	fa <dhcp_create_request+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1447
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
 10a:	4810      	ldr	r0, [pc, #64]	(14c <dhcp_create_request+0x14c>)
 10c:	6a34      	ldr	r4, [r6, #32]
 10e:	f7ff fffe 	bl	0 <htonl>
 112:	f3c0 2307 	ubfx	r3, r0, #8, #8
 116:	f884 00ec 	strb.w	r0, [r4, #236]
 11a:	f884 30ed 	strb.w	r3, [r4, #237]
 11e:	f3c0 4307 	ubfx	r3, r0, #16, #8
 122:	0e00      	lsrs	r0, r0, #24
 124:	f884 30ee 	strb.w	r3, [r4, #238]
 128:	f884 00ef 	strb.w	r0, [r4, #239]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1448
  dhcp->options_out_len = 0;
 12c:	462a      	mov	r2, r5
 12e:	84b5      	strh	r5, [r6, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1451
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 130:	6a33      	ldr	r3, [r6, #32]
 132:	189b      	adds	r3, r3, r2
 134:	f883 20f0 	strb.w	r2, [r3, #240]
 138:	3201      	adds	r2, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1450
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 13a:	2a44      	cmp	r2, #68
 13c:	d1f8      	bne.n	130 <dhcp_create_request+0x130>
 13e:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1454
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
 140:	b240      	sxtb	r0, r0
 142:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 146:	46c0      	nop			(mov r8, r8)
 148:	00000000 	.word	0x00000000
 14c:	63825363 	.word	0x63825363
Disassembly of section .text.dhcp_release:

00000000 <dhcp_release>:
dhcp_release():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1064
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1065
  struct dhcp *dhcp = netif->dhcp;
   2:	6a05      	ldr	r5, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1064
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
   4:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1071
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
   6:	210d      	movs	r1, #13
   8:	4628      	mov	r0, r5
   a:	f7ff fffe 	bl	0 <dhcp_release>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1073
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
   e:	2300      	movs	r3, #0
  10:	62eb      	str	r3, [r5, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1074
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  12:	636b      	str	r3, [r5, #52]
  14:	632b      	str	r3, [r5, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1075
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  16:	63eb      	str	r3, [r5, #60]
  18:	63ab      	str	r3, [r5, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1076
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  1a:	656b      	str	r3, [r5, #84]
  1c:	652b      	str	r3, [r5, #80]
  1e:	64eb      	str	r3, [r5, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1077
  dhcp->dns_count = 0;
  20:	642b      	str	r3, [r5, #64]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1080
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  22:	4630      	mov	r0, r6
  24:	f7ff fffe 	bl	0 <dhcp_release>
  28:	b2c7      	uxtb	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1081
  if (result == ERR_OK) {
  2a:	bb17      	cbnz	r7, 72 <dhcp_release+0x72>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1082
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  2c:	2201      	movs	r2, #1
  2e:	4628      	mov	r0, r5
  30:	2135      	movs	r1, #53
  32:	f7ff fffe 	bl	0 <dhcp_release>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1083
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  36:	2107      	movs	r1, #7
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <dhcp_release>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1085

    dhcp_option_trailer(dhcp);
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <dhcp_release>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1087

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  44:	8ca9      	ldrh	r1, [r5, #36]
  46:	69e8      	ldr	r0, [r5, #28]
  48:	31f0      	adds	r1, #240
  4a:	b289      	uxth	r1, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1089

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  4c:	f105 042c 	add.w	r4, r5, #44	; 0x2c
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1087
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    dhcp_option_byte(dhcp, DHCP_RELEASE);

    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  50:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1089

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  54:	4621      	mov	r1, r4
  56:	2243      	movs	r2, #67
  58:	68a8      	ldr	r0, [r5, #8]
  5a:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1090
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  5e:	9600      	str	r6, [sp, #0]
  60:	68a8      	ldr	r0, [r5, #8]
  62:	69e9      	ldr	r1, [r5, #28]
  64:	4622      	mov	r2, r4
  66:	2343      	movs	r3, #67
  68:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1091
    dhcp_delete_request(netif);
  6c:	4630      	mov	r0, r6
  6e:	f7ff fffe 	bl	0 <dhcp_release>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1096
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  72:	786b      	ldrb	r3, [r5, #1]
  74:	3301      	adds	r3, #1
  76:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1097
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  78:	2a09      	cmp	r2, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1096
    dhcp_delete_request(netif);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  7a:	706a      	strb	r2, [r5, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1097
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  7c:	d902      	bls.n	84 <dhcp_release+0x84>
  7e:	f242 7310 	movw	r3, #10000	; 0x2710
  82:	e003      	b.n	8c <dhcp_release+0x8c>
  84:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  88:	4353      	muls	r3, r2
  8a:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1098
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8c:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
  90:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  94:	3303      	adds	r3, #3
  96:	fb93 f3f2 	sdiv	r3, r3, r2
  9a:	84eb      	strh	r3, [r5, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1101
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  9c:	4630      	mov	r0, r6
  9e:	f7ff fffe 	bl	0 <netif_set_down>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1103
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  a2:	4630      	mov	r0, r6
  a4:	4906      	ldr	r1, [pc, #24]	(c0 <dhcp_release+0xc0>)
  a6:	f7ff fffe 	bl	0 <netif_set_ipaddr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1104
  netif_set_gw(netif, IP_ADDR_ANY);
  aa:	4630      	mov	r0, r6
  ac:	4904      	ldr	r1, [pc, #16]	(c0 <dhcp_release+0xc0>)
  ae:	f7ff fffe 	bl	0 <netif_set_gw>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1105
  netif_set_netmask(netif, IP_ADDR_ANY);
  b2:	4630      	mov	r0, r6
  b4:	4902      	ldr	r1, [pc, #8]	(c0 <dhcp_release+0xc0>)
  b6:	f7ff fffe 	bl	0 <netif_set_netmask>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1109
  
  /* TODO: netif_down(netif); */
  return result;
}
  ba:	b278      	sxtb	r0, r7
  bc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  be:	46c0      	nop			(mov r8, r8)
  c0:	00000000 	.word	0x00000000
Disassembly of section .text.dhcp_renew:

00000000 <dhcp_renew>:
dhcp_renew():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:933
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:934
  struct dhcp *dhcp = netif->dhcp;
   2:	6a05      	ldr	r5, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:933
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
   4:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:941
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
   6:	2105      	movs	r1, #5
   8:	4628      	mov	r0, r5
   a:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:944

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
   e:	4630      	mov	r0, r6
  10:	f7ff fffe 	bl	0 <dhcp_renew>
  14:	b2c7      	uxtb	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:945
  if (result == ERR_OK) {
  16:	bb5f      	cbnz	r7, 70 <dhcp_renew+0x70>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:947

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  18:	2201      	movs	r2, #1
  1a:	4628      	mov	r0, r5
  1c:	2135      	movs	r1, #53
  1e:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:948
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  22:	4628      	mov	r0, r5
  24:	2103      	movs	r1, #3
  26:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:950

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  2a:	2202      	movs	r2, #2
  2c:	4628      	mov	r0, r5
  2e:	2139      	movs	r1, #57
  30:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:951
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  34:	8db1      	ldrh	r1, [r6, #44]
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:973
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:975

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  42:	8ca9      	ldrh	r1, [r5, #36]
  44:	69e8      	ldr	r0, [r5, #28]
  46:	31f0      	adds	r1, #240
  48:	b289      	uxth	r1, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:977

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  4a:	f105 042c 	add.w	r4, r5, #44	; 0x2c
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:975
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  4e:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:977

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  52:	4621      	mov	r1, r4
  54:	2243      	movs	r2, #67
  56:	68a8      	ldr	r0, [r5, #8]
  58:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:978
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  5c:	9600      	str	r6, [sp, #0]
  5e:	68a8      	ldr	r0, [r5, #8]
  60:	69e9      	ldr	r1, [r5, #28]
  62:	4622      	mov	r2, r4
  64:	2343      	movs	r3, #67
  66:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:979
    dhcp_delete_request(netif);
  6a:	4630      	mov	r0, r6
  6c:	f7ff fffe 	bl	0 <dhcp_renew>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:985

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  70:	786b      	ldrb	r3, [r5, #1]
  72:	3301      	adds	r3, #1
  74:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:987
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  76:	2a09      	cmp	r2, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:985

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  78:	706a      	strb	r2, [r5, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:987
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  7a:	d902      	bls.n	82 <dhcp_renew+0x82>
  7c:	f644 6320 	movw	r3, #20000	; 0x4e20
  80:	e003      	b.n	8a <dhcp_renew+0x8a>
  82:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
  86:	4353      	muls	r3, r2
  88:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:988
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8a:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
  8e:	3303      	adds	r3, #3
  90:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  94:	fb93 f3f2 	sdiv	r3, r3, r2
  98:	84eb      	strh	r3, [r5, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:991
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  9a:	b278      	sxtb	r0, r7
  9c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  9e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.dhcp_discover:

00000000 <dhcp_discover>:
dhcp_discover():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:787
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:792
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
   2:	4e37      	ldr	r6, [pc, #220]	(e0 <dhcp_discover+0xe0>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:788
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
   4:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:792
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
   6:	7872      	ldrb	r2, [r6, #1]
   8:	7833      	ldrb	r3, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:787
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
   a:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:792
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	78b2      	ldrb	r2, [r6, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:793
  dhcp_set_state(dhcp, DHCP_SELECTING);
  12:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:792
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  14:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  18:	78f2      	ldrb	r2, [r6, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:793
  dhcp_set_state(dhcp, DHCP_SELECTING);
  1a:	2106      	movs	r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:792
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  1c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  20:	6323      	str	r3, [r4, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:793
  dhcp_set_state(dhcp, DHCP_SELECTING);
  22:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:795
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <dhcp_discover>
  2c:	b2c7      	uxtb	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:796
  if (result == ERR_OK) {
  2e:	2f00      	cmp	r7, #0
  30:	d13e      	bne.n	b0 <dhcp_discover+0xb0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:798
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  32:	2201      	movs	r2, #1
  34:	4620      	mov	r0, r4
  36:	2135      	movs	r1, #53
  38:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:799
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  3c:	4620      	mov	r0, r4
  3e:	2101      	movs	r1, #1
  40:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:801

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  44:	2202      	movs	r2, #2
  46:	4620      	mov	r0, r4
  48:	2139      	movs	r1, #57
  4a:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:802
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  4e:	4620      	mov	r0, r4
  50:	8da9      	ldrh	r1, [r5, #44]
  52:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:804

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  56:	2204      	movs	r2, #4
  58:	4620      	mov	r0, r4
  5a:	2137      	movs	r1, #55
  5c:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:805
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  60:	4620      	mov	r0, r4
  62:	2101      	movs	r1, #1
  64:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:806
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  68:	4620      	mov	r0, r4
  6a:	2103      	movs	r1, #3
  6c:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:807
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  70:	4620      	mov	r0, r4
  72:	211c      	movs	r1, #28
  74:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:808
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  78:	2106      	movs	r1, #6
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:810

    dhcp_option_trailer(dhcp);
  80:	4620      	mov	r0, r4
  82:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:813

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  86:	8ca1      	ldrh	r1, [r4, #36]
  88:	69e0      	ldr	r0, [r4, #28]
  8a:	31f0      	adds	r1, #240
  8c:	b289      	uxth	r1, r1
  8e:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:815

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  92:	4631      	mov	r1, r6
  94:	2243      	movs	r2, #67
  96:	68a0      	ldr	r0, [r4, #8]
  98:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:817
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  9c:	9500      	str	r5, [sp, #0]
  9e:	68a0      	ldr	r0, [r4, #8]
  a0:	69e1      	ldr	r1, [r4, #28]
  a2:	4a10      	ldr	r2, [pc, #64]	(e4 <dhcp_discover+0xe4>)
  a4:	2343      	movs	r3, #67
  a6:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:819
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  aa:	4628      	mov	r0, r5
  ac:	f7ff fffe 	bl	0 <dhcp_discover>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:824
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  b0:	7863      	ldrb	r3, [r4, #1]
  b2:	3301      	adds	r3, #1
  b4:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:831
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  b6:	2a05      	cmp	r2, #5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:824
    dhcp_delete_request(netif);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  b8:	7062      	strb	r2, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:831
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  ba:	d902      	bls.n	c2 <dhcp_discover+0xc2>
  bc:	f64e 2360 	movw	r3, #60000	; 0xea60
  c0:	e003      	b.n	ca <dhcp_discover+0xca>
  c2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  c6:	4093      	lsls	r3, r2
  c8:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:832
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  ca:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
  ce:	3303      	adds	r3, #3
  d0:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  d4:	fb93 f3f2 	sdiv	r3, r3, r2
  d8:	84e3      	strh	r3, [r4, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:835
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  da:	b278      	sxtb	r0, r7
  dc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  de:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_rebind:

00000000 <dhcp_rebind>:
dhcp_rebind():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1000
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1001
  struct dhcp *dhcp = netif->dhcp;
   2:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1000
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1008
  u16_t msecs;
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
   6:	2104      	movs	r1, #4
   8:	4620      	mov	r0, r4
   a:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1011

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <dhcp_rebind>
  14:	b2c6      	uxtb	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1012
  if (result == ERR_OK) {
  16:	bb4e      	cbnz	r6, 6c <dhcp_rebind+0x6c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1014

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  18:	2201      	movs	r2, #1
  1a:	4620      	mov	r0, r4
  1c:	2135      	movs	r1, #53
  1e:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1015
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  22:	4620      	mov	r0, r4
  24:	2103      	movs	r1, #3
  26:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1017

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  2a:	2202      	movs	r2, #2
  2c:	4620      	mov	r0, r4
  2e:	2139      	movs	r1, #57
  30:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1018
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  34:	8da9      	ldrh	r1, [r5, #44]
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1038

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1040

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  42:	8ca1      	ldrh	r1, [r4, #36]
  44:	69e0      	ldr	r0, [r4, #28]
  46:	31f0      	adds	r1, #240
  48:	b289      	uxth	r1, r1
  4a:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1043

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  4e:	4913      	ldr	r1, [pc, #76]	(9c <dhcp_rebind+0x9c>)
  50:	2243      	movs	r2, #67
  52:	68a0      	ldr	r0, [r4, #8]
  54:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1044
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  58:	9500      	str	r5, [sp, #0]
  5a:	68a0      	ldr	r0, [r4, #8]
  5c:	69e1      	ldr	r1, [r4, #28]
  5e:	4a10      	ldr	r2, [pc, #64]	(a0 <dhcp_rebind+0xa0>)
  60:	2343      	movs	r3, #67
  62:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1045
    dhcp_delete_request(netif);
  66:	4628      	mov	r0, r5
  68:	f7ff fffe 	bl	0 <dhcp_rebind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1050
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  6c:	7863      	ldrb	r3, [r4, #1]
  6e:	3301      	adds	r3, #1
  70:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1051
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  72:	2a09      	cmp	r2, #9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1050
    dhcp_delete_request(netif);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  74:	7062      	strb	r2, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1051
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  76:	d902      	bls.n	7e <dhcp_rebind+0x7e>
  78:	f242 7310 	movw	r3, #10000	; 0x2710
  7c:	e003      	b.n	86 <dhcp_rebind+0x86>
  7e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  82:	4353      	muls	r3, r2
  84:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1052
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  86:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
  8a:	3303      	adds	r3, #3
  8c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  90:	fb93 f3f2 	sdiv	r3, r3, r2
  94:	84e3      	strh	r3, [r4, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1055
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  96:	b270      	sxtb	r0, r6
  98:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
  9a:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_coarse_tmr:

00000000 <dhcp_coarse_tmr>:
dhcp_coarse_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:314
 *
 */
void
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
   0:	4b14      	ldr	r3, [pc, #80]	(54 <dhcp_coarse_tmr+0x54>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:313
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:314
  struct netif *netif = netif_list;
   4:	681c      	ldr	r4, [r3, #0]
   6:	e021      	b.n	4c <dhcp_coarse_tmr+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:319
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
   8:	6a21      	ldr	r1, [r4, #32]
   a:	b1f1      	cbz	r1, 4a <dhcp_coarse_tmr+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:321
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
   c:	8d4a      	ldrh	r2, [r1, #42]
   e:	1e53      	subs	r3, r2, #1
  10:	2a01      	cmp	r2, #1
  12:	854b      	strh	r3, [r1, #42]
  14:	d10a      	bne.n	2c <dhcp_coarse_tmr+0x2c>
dhcp_t2_timeout():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:455
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  16:	780b      	ldrb	r3, [r1, #0]
  18:	2b01      	cmp	r3, #1
  1a:	d003      	beq.n	24 <dhcp_coarse_tmr+0x24>
  1c:	2b0a      	cmp	r3, #10
  1e:	d001      	beq.n	24 <dhcp_coarse_tmr+0x24>
  20:	2b05      	cmp	r3, #5
  22:	d112      	bne.n	4a <dhcp_coarse_tmr+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:458
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <dhcp_coarse_tmr>
  2a:	e00e      	b.n	4a <dhcp_coarse_tmr+0x4a>
dhcp_coarse_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:326
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  2c:	8d0a      	ldrh	r2, [r1, #40]
  2e:	1e53      	subs	r3, r2, #1
  30:	2a01      	cmp	r2, #1
  32:	850b      	strh	r3, [r1, #40]
  34:	d109      	bne.n	4a <dhcp_coarse_tmr+0x4a>
dhcp_t1_timeout():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:437
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  36:	780b      	ldrb	r3, [r1, #0]
  38:	2b01      	cmp	r3, #1
  3a:	d003      	beq.n	44 <dhcp_coarse_tmr+0x44>
  3c:	2b0a      	cmp	r3, #10
  3e:	d001      	beq.n	44 <dhcp_coarse_tmr+0x44>
  40:	2b05      	cmp	r3, #5
  42:	d102      	bne.n	4a <dhcp_coarse_tmr+0x4a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:441
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <dhcp_coarse_tmr>
dhcp_coarse_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:333
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  4a:	6824      	ldr	r4, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:317
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  4c:	2c00      	cmp	r4, #0
  4e:	d1db      	bne.n	8 <dhcp_coarse_tmr+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:335
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  50:	bd10      	pop	{r4, pc}
  52:	46c0      	nop			(mov r8, r8)
  54:	00000000 	.word	0x00000000
Disassembly of section .text.dhcp_arp_reply:

00000000 <dhcp_arp_reply>:
dhcp_arp_reply():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:716
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:717
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   2:	4605      	mov	r5, r0
   4:	2800      	cmp	r0, #0
   6:	d04f      	beq.n	a8 <dhcp_arp_reply+0xa8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:720
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
   8:	6a04      	ldr	r4, [r0, #32]
   a:	2c00      	cmp	r4, #0
   c:	d04c      	beq.n	a8 <dhcp_arp_reply+0xa8>
   e:	7823      	ldrb	r3, [r4, #0]
  10:	2b08      	cmp	r3, #8
  12:	d149      	bne.n	a8 <dhcp_arp_reply+0xa8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:724
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  14:	784a      	ldrb	r2, [r1, #1]
  16:	780b      	ldrb	r3, [r1, #0]
  18:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  1c:	788a      	ldrb	r2, [r1, #2]
  1e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  22:	78ca      	ldrb	r2, [r1, #3]
  24:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  28:	6b22      	ldr	r2, [r4, #48]
  2a:	4293      	cmp	r3, r2
  2c:	d13c      	bne.n	a8 <dhcp_arp_reply+0xa8>
dhcp_decline():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:748
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  2e:	210c      	movs	r1, #12
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:750
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:751
  if (result == ERR_OK) {
  3c:	f010 0fff 	tst.w	r0, #255	; 0xff
  40:	d12c      	bne.n	9c <dhcp_arp_reply+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:752
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  42:	2201      	movs	r2, #1
  44:	4620      	mov	r0, r4
  46:	2135      	movs	r1, #53
  48:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:753
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  4c:	4620      	mov	r0, r4
  4e:	2104      	movs	r1, #4
  50:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:755

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  54:	2204      	movs	r2, #4
  56:	2132      	movs	r1, #50
  58:	4620      	mov	r0, r4
  5a:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:756
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  5e:	6b20      	ldr	r0, [r4, #48]
  60:	f7ff fffe 	bl	0 <ntohl>
  64:	4601      	mov	r1, r0
  66:	4620      	mov	r0, r4
  68:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:758

    dhcp_option_trailer(dhcp);
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:760
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  72:	8ca1      	ldrh	r1, [r4, #36]
  74:	69e0      	ldr	r0, [r4, #28]
  76:	31f0      	adds	r1, #240
  78:	b289      	uxth	r1, r1
  7a:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:763

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  7e:	490b      	ldr	r1, [pc, #44]	(ac <dhcp_arp_reply+0xac>)
  80:	2243      	movs	r2, #67
  82:	68a0      	ldr	r0, [r4, #8]
  84:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:765
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  88:	9500      	str	r5, [sp, #0]
  8a:	68a0      	ldr	r0, [r4, #8]
  8c:	69e1      	ldr	r1, [r4, #28]
  8e:	4a08      	ldr	r2, [pc, #32]	(b0 <dhcp_arp_reply+0xb0>)
  90:	2343      	movs	r3, #67
  92:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:766
    dhcp_delete_request(netif);
  96:	4628      	mov	r0, r5
  98:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:771
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  9c:	7863      	ldrb	r3, [r4, #1]
  9e:	3301      	adds	r3, #1
  a0:	7063      	strb	r3, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:773
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  a2:	f04f 0314 	mov.w	r3, #20	; 0x14
  a6:	84e3      	strh	r3, [r4, #38]
dhcp_arp_reply():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:730
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  a8:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
  aa:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_select:

00000000 <dhcp_select>:
dhcp_select():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:242
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:243
  struct dhcp *dhcp = netif->dhcp;
   2:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:242
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:251
#if LWIP_NETIF_HOSTNAME
  const char *p;
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
   6:	2101      	movs	r1, #1
   8:	4620      	mov	r0, r4
   a:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:254

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <dhcp_select>
  14:	b2c6      	uxtb	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:255
  if (result == ERR_OK) {
  16:	2e00      	cmp	r6, #0
  18:	d156      	bne.n	c8 <dhcp_select+0xc8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:256
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  1a:	2201      	movs	r2, #1
  1c:	2135      	movs	r1, #53
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:257
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  24:	2103      	movs	r1, #3
  26:	4620      	mov	r0, r4
  28:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:259

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  2c:	2202      	movs	r2, #2
  2e:	2139      	movs	r1, #57
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:260
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  36:	4620      	mov	r0, r4
  38:	8da9      	ldrh	r1, [r5, #44]
  3a:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:263

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  3e:	2204      	movs	r2, #4
  40:	2132      	movs	r1, #50
  42:	4620      	mov	r0, r4
  44:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:264
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  48:	6b20      	ldr	r0, [r4, #48]
  4a:	f7ff fffe 	bl	0 <ntohl>
  4e:	4601      	mov	r1, r0
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:266

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  56:	2204      	movs	r2, #4
  58:	2136      	movs	r1, #54
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:267
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  60:	6ae0      	ldr	r0, [r4, #44]
  62:	f7ff fffe 	bl	0 <ntohl>
  66:	4601      	mov	r1, r0
  68:	4620      	mov	r0, r4
  6a:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:269

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  6e:	2204      	movs	r2, #4
  70:	2137      	movs	r1, #55
  72:	4620      	mov	r0, r4
  74:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:270
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  78:	2101      	movs	r1, #1
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:271
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80:	2103      	movs	r1, #3
  82:	4620      	mov	r0, r4
  84:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:272
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  88:	211c      	movs	r1, #28
  8a:	4620      	mov	r0, r4
  8c:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:273
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  90:	2106      	movs	r1, #6
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:285
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  98:	4620      	mov	r0, r4
  9a:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:287
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  9e:	8ca1      	ldrh	r1, [r4, #36]
  a0:	69e0      	ldr	r0, [r4, #28]
  a2:	31f0      	adds	r1, #240
  a4:	b289      	uxth	r1, r1
  a6:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:292

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  aa:	9500      	str	r5, [sp, #0]
  ac:	2343      	movs	r3, #67
  ae:	69e1      	ldr	r1, [r4, #28]
  b0:	4a11      	ldr	r2, [pc, #68]	(f8 <dhcp_select+0xf8>)
  b2:	68a0      	ldr	r0, [r4, #8]
  b4:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:294
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  b8:	68a0      	ldr	r0, [r4, #8]
  ba:	4910      	ldr	r1, [pc, #64]	(fc <dhcp_select+0xfc>)
  bc:	2243      	movs	r2, #67
  be:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:295
    dhcp_delete_request(netif);
  c2:	4628      	mov	r0, r5
  c4:	f7ff fffe 	bl	0 <dhcp_select>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:300
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  c8:	7863      	ldrb	r3, [r4, #1]
  ca:	3301      	adds	r3, #1
  cc:	b2da      	uxtb	r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:301
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  ce:	2a05      	cmp	r2, #5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:300
    dhcp_delete_request(netif);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  d0:	7062      	strb	r2, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:301
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
  d2:	d902      	bls.n	da <dhcp_select+0xda>
  d4:	f64e 2360 	movw	r3, #60000	; 0xea60
  d8:	e003      	b.n	e2 <dhcp_select+0xe2>
  da:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  de:	4093      	lsls	r3, r2
  e0:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:302
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  e2:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
  e6:	3303      	adds	r3, #3
  e8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  ec:	fb93 f3f2 	sdiv	r3, r3, r2
  f0:	84e3      	strh	r3, [r4, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:305
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  f2:	b270      	sxtb	r0, r6
  f4:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
  f6:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_inform:

00000000 <dhcp_inform>:
dhcp_inform():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:654
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:655
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
   2:	6a06      	ldr	r6, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:654
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:657
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
   6:	2058      	movs	r0, #88
   8:	f7ff fffe 	bl	0 <mem_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:658
  if (dhcp == NULL) {
   c:	4604      	mov	r4, r0
   e:	2800      	cmp	r0, #0
  10:	d050      	beq.n	b4 <dhcp_inform+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:663
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  memset(dhcp, 0, sizeof(struct dhcp));
  12:	2100      	movs	r1, #0
  14:	2258      	movs	r2, #88
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:662
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  16:	6228      	str	r0, [r5, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:663
  memset(dhcp, 0, sizeof(struct dhcp));
  18:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:666

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  1c:	f7ff fffe 	bl	0 <udp_new>
  20:	60a0      	str	r0, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:667
  if (dhcp->pcb == NULL) {
  22:	b918      	cbnz	r0, 2c <dhcp_inform+0x2c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:669
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <mem_free>
  2a:	e043      	b.n	b4 <dhcp_inform+0xb4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:674
    return;
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:675
  if (result == ERR_OK) {
  32:	f010 0fff 	tst.w	r0, #255	; 0xff
  36:	d133      	bne.n	a0 <dhcp_inform+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:677

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  38:	2201      	movs	r2, #1
  3a:	4620      	mov	r0, r4
  3c:	2135      	movs	r1, #53
  3e:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:678
    dhcp_option_byte(dhcp, DHCP_INFORM);
  42:	4620      	mov	r0, r4
  44:	2108      	movs	r1, #8
  46:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:680

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  4a:	2202      	movs	r2, #2
  4c:	4620      	mov	r0, r4
  4e:	2139      	movs	r1, #57
  50:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:681
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
  54:	8da9      	ldrh	r1, [r5, #44]
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:683

    dhcp_option_trailer(dhcp);
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:685

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  62:	8ca1      	ldrh	r1, [r4, #36]
  64:	69e0      	ldr	r0, [r4, #28]
  66:	31f0      	adds	r1, #240
  68:	b289      	uxth	r1, r1
  6a:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:690

#if IP_SOF_BROADCAST
    dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  6e:	4912      	ldr	r1, [pc, #72]	(b8 <dhcp_inform+0xb8>)
  70:	2244      	movs	r2, #68
  72:	68a0      	ldr	r0, [r4, #8]
  74:	f7ff fffe 	bl	0 <udp_bind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:691
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  78:	4910      	ldr	r1, [pc, #64]	(bc <dhcp_inform+0xbc>)
  7a:	2243      	movs	r2, #67
  7c:	68a0      	ldr	r0, [r4, #8]
  7e:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:693
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  82:	9500      	str	r5, [sp, #0]
  84:	69e1      	ldr	r1, [r4, #28]
  86:	4a0d      	ldr	r2, [pc, #52]	(bc <dhcp_inform+0xbc>)
  88:	2343      	movs	r3, #67
  8a:	68a0      	ldr	r0, [r4, #8]
  8c:	f7ff fffe 	bl	0 <udp_sendto_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:694
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  90:	68a0      	ldr	r0, [r4, #8]
  92:	4909      	ldr	r1, [pc, #36]	(b8 <dhcp_inform+0xb8>)
  94:	2243      	movs	r2, #67
  96:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:695
    dhcp_delete_request(netif);
  9a:	4628      	mov	r0, r5
  9c:	f7ff fffe 	bl	0 <dhcp_inform>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:700
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp->pcb != NULL) {
  a0:	68a0      	ldr	r0, [r4, #8]
  a2:	b108      	cbz	r0, a8 <dhcp_inform+0xa8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:701
    udp_remove(dhcp->pcb);
  a4:	f7ff fffe 	bl	0 <udp_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:703
  }
  dhcp->pcb = NULL;
  a8:	2300      	movs	r3, #0
  aa:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:704
  mem_free((void *)dhcp);
  ac:	4620      	mov	r0, r4
  ae:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:705
  netif->dhcp = old_dhcp;
  b2:	622e      	str	r6, [r5, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:706
}
  b4:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
  b6:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_start:

00000000 <dhcp_start>:
dhcp_start():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:573
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:577
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
   2:	4606      	mov	r6, r0
   4:	b908      	cbnz	r0, a <dhcp_start+0xa>
   6:	30f6      	adds	r0, #246
   8:	e049      	b.n	9e <dhcp_start+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:582
  dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   a:	f890 302e 	ldrb.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:578
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
   e:	6a05      	ldr	r5, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:582
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  10:	f023 0308 	bic.w	r3, r3, #8	; 0x8
  14:	f880 302e 	strb.w	r3, [r0, #46]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:585

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
  18:	8d83      	ldrh	r3, [r0, #44]
  1a:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
  1e:	d33d      	bcc.n	9c <dhcp_start+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:591
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  20:	b93d      	cbnz	r5, 32 <dhcp_start+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:593
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  22:	2058      	movs	r0, #88
  24:	f7ff fffe 	bl	0 <mem_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:594
    if (dhcp == NULL) {
  28:	4605      	mov	r5, r0
  2a:	2800      	cmp	r0, #0
  2c:	d036      	beq.n	9c <dhcp_start+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:599
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  2e:	6230      	str	r0, [r6, #32]
  30:	e007      	b.n	42 <dhcp_start+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:604
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
  32:	68a8      	ldr	r0, [r5, #8]
  34:	b108      	cbz	r0, 3a <dhcp_start+0x3a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:605
      udp_remove(dhcp->pcb);
  36:	f7ff fffe 	bl	0 <udp_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:607
    }
    if (dhcp->p != NULL) {
  3a:	68e8      	ldr	r0, [r5, #12]
  3c:	b108      	cbz	r0, 42 <dhcp_start+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:608
      pbuf_free(dhcp->p);
  3e:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:613
    }
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  42:	2100      	movs	r1, #0
  44:	2258      	movs	r2, #88
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <memset>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:615
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  4c:	f7ff fffe 	bl	0 <udp_new>
  50:	4604      	mov	r4, r0
  52:	60a8      	str	r0, [r5, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:616
  if (dhcp->pcb == NULL) {
  54:	b920      	cbnz	r0, 60 <dhcp_start+0x60>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:618
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:619
    netif->dhcp = dhcp = NULL;
  5c:	6234      	str	r4, [r6, #32]
  5e:	e01d      	b.n	9c <dhcp_start+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:626
  }
#if IP_SOF_BROADCAST
  dhcp->pcb->so_options|=SOF_BROADCAST;
#endif /* IP_SOF_BROADCAST */
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  60:	4910      	ldr	r1, [pc, #64]	(a4 <dhcp_start+0xa4>)
  62:	2244      	movs	r2, #68
  64:	f7ff fffe 	bl	0 <udp_bind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:627
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  68:	490e      	ldr	r1, [pc, #56]	(a4 <dhcp_start+0xa4>)
  6a:	2243      	movs	r2, #67
  6c:	68a8      	ldr	r0, [r5, #8]
  6e:	f7ff fffe 	bl	0 <udp_connect>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:629
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  72:	68a8      	ldr	r0, [r5, #8]
  74:	490c      	ldr	r1, [pc, #48]	(a8 <dhcp_start+0xa8>)
  76:	4632      	mov	r2, r6
  78:	f7ff fffe 	bl	0 <udp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:632
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  7c:	4630      	mov	r0, r6
  7e:	f7ff fffe 	bl	0 <dhcp_start>
  82:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:633
  if (result != ERR_OK) {
  84:	b118      	cbz	r0, 8e <dhcp_start+0x8e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:635
    /* free resources allocated above */
    dhcp_stop(netif);
  86:	4630      	mov	r0, r6
  88:	f7ff fffe 	bl	0 <dhcp_start>
  8c:	e006      	b.n	9c <dhcp_start+0x9c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:639
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8e:	f896 302e 	ldrb.w	r3, [r6, #46]
  92:	f043 0308 	orr.w	r3, r3, #8	; 0x8
  96:	f886 302e 	strb.w	r3, [r6, #46]
  9a:	e000      	b.n	9e <dhcp_start+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:640
  return result;
  9c:	20ff      	movs	r0, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:641
}
  9e:	b240      	sxtb	r0, r0
  a0:	bd70      	pop	{r4, r5, r6, pc}
  a2:	46c0      	nop			(mov r8, r8)
	...
Disassembly of section .text.dhcp_check:

00000000 <dhcp_check>:
dhcp_check():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:189
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:190
  struct dhcp *dhcp = netif->dhcp;
   2:	6a04      	ldr	r4, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:189
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:195
  struct dhcp *dhcp = netif->dhcp;
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
   6:	2108      	movs	r1, #8
   8:	4620      	mov	r0, r4
   a:	f7ff fffe 	bl	0 <dhcp_check>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:198
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
   e:	4628      	mov	r0, r5
  10:	f104 0130 	add.w	r1, r4, #48	; 0x30
  14:	2200      	movs	r2, #0
  16:	f7ff fffe 	bl	0 <etharp_query>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:202
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  1a:	7863      	ldrb	r3, [r4, #1]
  1c:	3301      	adds	r3, #1
  1e:	7063      	strb	r3, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:204
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  20:	f04f 0301 	mov.w	r3, #1	; 0x1
  24:	84e3      	strh	r3, [r4, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:206
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
  26:	bd70      	pop	{r4, r5, r6, pc}
Disassembly of section .text.dhcp_bind:

00000000 <dhcp_bind>:
dhcp_bind():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:845
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:849
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
   2:	4606      	mov	r6, r0
   4:	2800      	cmp	r0, #0
   6:	d05c      	beq.n	c2 <dhcp_bind+0xc2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:850
  dhcp = netif->dhcp;
   8:	6a05      	ldr	r5, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:851
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
   a:	2d00      	cmp	r5, #0
   c:	d059      	beq.n	c2 <dhcp_bind+0xc2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:855
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
   e:	6d2b      	ldr	r3, [r5, #80]
  10:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
  14:	d00e      	beq.n	34 <dhcp_bind+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:858
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  16:	223c      	movs	r2, #60
  18:	331e      	adds	r3, #30
  1a:	fbb3 f3f2 	udiv	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:862
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  1e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  22:	4293      	cmp	r3, r2
  24:	bf28      	it	cs
  26:	4613      	movcs	r3, r2
  28:	b29b      	uxth	r3, r3
  2a:	852b      	strh	r3, [r5, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:863
    if (dhcp->t1_timeout == 0) {
  2c:	b913      	cbnz	r3, 34 <dhcp_bind+0x34>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:864
      dhcp->t1_timeout = 1;
  2e:	f04f 0301 	mov.w	r3, #1	; 0x1
  32:	852b      	strh	r3, [r5, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:869
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  34:	6d6b      	ldr	r3, [r5, #84]
  36:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
  3a:	d00e      	beq.n	5a <dhcp_bind+0x5a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:871
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  3c:	223c      	movs	r2, #60
  3e:	331e      	adds	r3, #30
  40:	fbb3 f3f2 	udiv	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:875
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  44:	f64f 72ff 	movw	r2, #65535	; 0xffff
  48:	4293      	cmp	r3, r2
  4a:	bf28      	it	cs
  4c:	4613      	movcs	r3, r2
  4e:	b29b      	uxth	r3, r3
  50:	856b      	strh	r3, [r5, #42]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:876
    if (dhcp->t2_timeout == 0) {
  52:	b913      	cbnz	r3, 5a <dhcp_bind+0x5a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:877
      dhcp->t2_timeout = 1;
  54:	f04f 0301 	mov.w	r3, #1	; 0x1
  58:	856b      	strh	r3, [r5, #42]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:882
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  5a:	6b68      	ldr	r0, [r5, #52]
  5c:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:886

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  5e:	b980      	cbnz	r0, 82 <dhcp_bind+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:888
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  60:	f7ff fffe 	bl	0 <ntohl>
  64:	0e00      	lsrs	r0, r0, #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:889
    if (first_octet <= 127) {
  66:	f010 0f80 	tst.w	r0, #128	; 0x80
  6a:	d102      	bne.n	72 <dhcp_bind+0x72>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:890
      sn_mask.addr = htonl(0xff000000);
  6c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
  70:	e004      	b.n	7c <dhcp_bind+0x7c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:891
    } else if (first_octet >= 192) {
  72:	28bf      	cmp	r0, #191
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:894
      sn_mask.addr = htonl(0xffffff00);
    } else {
      sn_mask.addr = htonl(0xffff0000);
  74:	bf94      	ite	ls
  76:	4813      	ldrls	r0, [pc, #76]	(c4 <dhcp_bind+0xc4>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:892
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
    if (first_octet <= 127) {
      sn_mask.addr = htonl(0xff000000);
    } else if (first_octet >= 192) {
      sn_mask.addr = htonl(0xffffff00);
  78:	f06f 00ff 	mvnhi.w	r0, #255	; 0xff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:894
    } else {
      sn_mask.addr = htonl(0xffff0000);
  7c:	f7ff fffe 	bl	0 <htonl>
  80:	9001      	str	r0, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:898
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  82:	6bab      	ldr	r3, [r5, #56]
  84:	9300      	str	r3, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:900
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  86:	b943      	cbnz	r3, 9a <dhcp_bind+0x9a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:902
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  88:	6b2b      	ldr	r3, [r5, #48]
  8a:	9c01      	ldr	r4, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:904
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  8c:	2001      	movs	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:902

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8e:	401c      	ands	r4, r3
  90:	9400      	str	r4, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:904
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  92:	f7ff fffe 	bl	0 <htonl>
  96:	4320      	orrs	r0, r4
  98:	9000      	str	r0, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:915
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  9a:	4630      	mov	r0, r6
  9c:	f105 0130 	add.w	r1, r5, #48	; 0x30
  a0:	f7ff fffe 	bl	0 <netif_set_ipaddr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:917
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  a4:	4630      	mov	r0, r6
  a6:	a901      	add	r1, sp, #4
  a8:	f7ff fffe 	bl	0 <netif_set_netmask>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:919
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  ac:	4669      	mov	r1, sp
  ae:	4630      	mov	r0, r6
  b0:	f7ff fffe 	bl	0 <netif_set_gw>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:921
  /* bring the interface up */
  netif_set_up(netif);
  b4:	4630      	mov	r0, r6
  b6:	f7ff fffe 	bl	0 <netif_set_up>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:923
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  ba:	4628      	mov	r0, r5
  bc:	210a      	movs	r1, #10
  be:	f7ff fffe 	bl	0 <dhcp_bind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:924
}
  c2:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
  c4:	ffff0000 	.word	0xffff0000
Disassembly of section .text.dhcp_recv:

00000000 <dhcp_recv>:
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1282

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1284
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
   4:	6a06      	ldr	r6, [r0, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1285
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
   6:	6854      	ldr	r4, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1298
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
   8:	60f2      	str	r2, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1300
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
   a:	7823      	ldrb	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1282

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
   c:	4607      	mov	r7, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1300
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
   e:	2b02      	cmp	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1282

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  10:	4691      	mov	r9, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1300
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  12:	f040 812d 	bne.w	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1305
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  16:	f890 5024 	ldrb.w	r5, [r0, #36]
  1a:	2100      	movs	r1, #0
  1c:	e008      	b.n	30 <dhcp_recv+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1306
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  1e:	1862      	adds	r2, r4, r1
  20:	f890 3025 	ldrb.w	r3, [r0, #37]
  24:	7f12      	ldrb	r2, [r2, #28]
  26:	3101      	adds	r1, #1
  28:	3001      	adds	r0, #1
  2a:	4293      	cmp	r3, r2
  2c:	f040 8120 	bne.w	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1305
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  30:	b2cb      	uxtb	r3, r1
  32:	42ab      	cmp	r3, r5
  34:	d3f3      	bcc.n	1e <dhcp_recv+0x1e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1313
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  36:	7963      	ldrb	r3, [r4, #5]
  38:	7920      	ldrb	r0, [r4, #4]
  3a:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  3e:	79a3      	ldrb	r3, [r4, #6]
  40:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  44:	79e3      	ldrb	r3, [r4, #7]
  46:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
  4a:	f7ff fffe 	bl	0 <ntohl>
  4e:	6873      	ldr	r3, [r6, #4]
  50:	4298      	cmp	r0, r3
  52:	f040 810d 	bne.w	270 <dhcp_recv+0x270>
dhcp_unfold_reply():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1221
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  56:	68f3      	ldr	r3, [r6, #12]
  58:	2b00      	cmp	r3, #0
  5a:	f000 8109 	beq.w	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1223
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  5e:	4630      	mov	r0, r6
  60:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1225
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  64:	68f3      	ldr	r3, [r6, #12]
  66:	8918      	ldrh	r0, [r3, #8]
  68:	28f0      	cmp	r0, #240
  6a:	d908      	bls.n	7e <dhcp_recv+0x7e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1226
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  6c:	38f0      	subs	r0, #240
  6e:	b280      	uxth	r0, r0
  70:	8330      	strh	r0, [r6, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1227
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  72:	f7ff fffe 	bl	0 <mem_malloc>
  76:	6170      	str	r0, [r6, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1228
    if (dhcp->options_in == NULL) {
  78:	2800      	cmp	r0, #0
  7a:	f000 80f9 	beq.w	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1233
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  7e:	20f0      	movs	r0, #240
  80:	f7ff fffe 	bl	0 <mem_malloc>
  84:	4604      	mov	r4, r0
  86:	6130      	str	r0, [r6, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1234
  if (dhcp->msg_in == NULL) {
  88:	b920      	cbnz	r0, 94 <dhcp_recv+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1236
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  8a:	6970      	ldr	r0, [r6, #20]
  8c:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1237
    dhcp->options_in = NULL;
  90:	6174      	str	r4, [r6, #20]
  92:	e0ed      	b.n	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1242
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  94:	4621      	mov	r1, r4
  96:	68f0      	ldr	r0, [r6, #12]
  98:	22f0      	movs	r2, #240
  9a:	2300      	movs	r3, #0
  9c:	f7ff fffe 	bl	0 <pbuf_copy_partial>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1247
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  a0:	6971      	ldr	r1, [r6, #20]
  a2:	b121      	cbz	r1, ae <dhcp_recv+0xae>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1249
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  a4:	68f0      	ldr	r0, [r6, #12]
  a6:	8b32      	ldrh	r2, [r6, #24]
  a8:	23f0      	movs	r3, #240
  aa:	f7ff fffe 	bl	0 <pbuf_copy_partial>
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1325
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  ae:	4630      	mov	r0, r6
  b0:	2135      	movs	r1, #53
  b2:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1326
  if (options_ptr == NULL) {
  b6:	2800      	cmp	r0, #0
  b8:	f000 80da 	beq.w	270 <dhcp_recv+0x270>
dhcp_get_option_byte():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1591
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  bc:	7880      	ldrb	r0, [r0, #2]
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1334
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  be:	2805      	cmp	r0, #5
  c0:	f040 808a 	bne.w	1d8 <dhcp_recv+0x1d8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1337
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  c4:	7833      	ldrb	r3, [r6, #0]
  c6:	2b01      	cmp	r3, #1
  c8:	d17b      	bne.n	1c2 <dhcp_recv+0x1c2>
dhcp_handle_ack():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:470
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  ca:	6a3c      	ldr	r4, [r7, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:473
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  cc:	3b01      	subs	r3, #1
  ce:	6363      	str	r3, [r4, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:474
  dhcp->offered_gw_addr.addr = 0;
  d0:	63a3      	str	r3, [r4, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:475
  dhcp->offered_bc_addr.addr = 0;
  d2:	63e3      	str	r3, [r4, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:478

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  d4:	4620      	mov	r0, r4
  d6:	2133      	movs	r1, #51
  d8:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:479
  if (option_ptr != NULL) {
  dc:	b118      	cbz	r0, e6 <dhcp_recv+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:481
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  de:	3002      	adds	r0, #2
  e0:	f7ff fffe 	bl	0 <dhcp_recv>
  e4:	64e0      	str	r0, [r4, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:484
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  e6:	4620      	mov	r0, r4
  e8:	213a      	movs	r1, #58
  ea:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:485
  if (option_ptr != NULL) {
  ee:	b120      	cbz	r0, fa <dhcp_recv+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:487
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  f0:	3002      	adds	r0, #2
  f2:	f7ff fffe 	bl	0 <dhcp_recv>
  f6:	6520      	str	r0, [r4, #80]
  f8:	e002      	b.n	100 <dhcp_recv+0x100>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:490
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  fa:	6ce3      	ldr	r3, [r4, #76]
  fc:	085b      	lsrs	r3, r3, #1
  fe:	6523      	str	r3, [r4, #80]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:494
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
 100:	4620      	mov	r0, r4
 102:	213b      	movs	r1, #59
 104:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:495
  if (option_ptr != NULL) {
 108:	b120      	cbz	r0, 114 <dhcp_recv+0x114>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:497
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
 10a:	3002      	adds	r0, #2
 10c:	f7ff fffe 	bl	0 <dhcp_recv>
 110:	6560      	str	r0, [r4, #84]
 112:	e001      	b.n	118 <dhcp_recv+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:500
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
 114:	6ce3      	ldr	r3, [r4, #76]
 116:	6563      	str	r3, [r4, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:504
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
 118:	6921      	ldr	r1, [r4, #16]
 11a:	f111 0310 	adds.w	r3, r1, #16	; 0x10
 11e:	d009      	beq.n	134 <dhcp_recv+0x134>
 120:	7c4a      	ldrb	r2, [r1, #17]
 122:	7c0b      	ldrb	r3, [r1, #16]
 124:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 128:	7c8a      	ldrb	r2, [r1, #18]
 12a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 12e:	7cca      	ldrb	r2, [r1, #19]
 130:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 134:	6323      	str	r3, [r4, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:521
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
 136:	4620      	mov	r0, r4
 138:	2101      	movs	r1, #1
 13a:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:523
  /* subnet mask given? */
  if (option_ptr != NULL) {
 13e:	b128      	cbz	r0, 14c <dhcp_recv+0x14c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:524
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
 140:	3002      	adds	r0, #2
 142:	f7ff fffe 	bl	0 <dhcp_recv>
 146:	f7ff fffe 	bl	0 <htonl>
 14a:	6360      	str	r0, [r4, #52]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:528
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
 14c:	4620      	mov	r0, r4
 14e:	2103      	movs	r1, #3
 150:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:529
  if (option_ptr != NULL) {
 154:	b128      	cbz	r0, 162 <dhcp_recv+0x162>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:530
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
 156:	3002      	adds	r0, #2
 158:	f7ff fffe 	bl	0 <dhcp_recv>
 15c:	f7ff fffe 	bl	0 <htonl>
 160:	63a0      	str	r0, [r4, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:534
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
 162:	4620      	mov	r0, r4
 164:	211c      	movs	r1, #28
 166:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:535
  if (option_ptr != NULL) {
 16a:	b128      	cbz	r0, 178 <dhcp_recv+0x178>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:536
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
 16c:	3002      	adds	r0, #2
 16e:	f7ff fffe 	bl	0 <dhcp_recv>
 172:	f7ff fffe 	bl	0 <htonl>
 176:	63e0      	str	r0, [r4, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:540
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
 178:	4620      	mov	r0, r4
 17a:	2106      	movs	r1, #6
 17c:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:541
  if (option_ptr != NULL) {
 180:	4680      	mov	r8, r0
 182:	b1b8      	cbz	r0, 1b4 <dhcp_recv+0x1b4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:543
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
 184:	7843      	ldrb	r3, [r0, #1]
 186:	089b      	lsrs	r3, r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:545
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
 188:	2b02      	cmp	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:543
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  if (option_ptr != NULL) {
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
 18a:	6423      	str	r3, [r4, #64]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:545
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
 18c:	d901      	bls.n	192 <dhcp_recv+0x192>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:546
      dhcp->dns_count = DHCP_MAX_DNS;
 18e:	2302      	movs	r3, #2
 190:	6423      	str	r3, [r4, #64]
 192:	2500      	movs	r5, #0
 194:	e00b      	b.n	1ae <dhcp_recv+0x1ae>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:548
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
 196:	eb08 0085 	add.w	r0, r8, r5, lsl #2
 19a:	3002      	adds	r0, #2
 19c:	f7ff fffe 	bl	0 <dhcp_recv>
 1a0:	f7ff fffe 	bl	0 <htonl>
 1a4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 1a8:	6458      	str	r0, [r3, #68]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:547
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
 1aa:	1c6b      	adds	r3, r5, #1
 1ac:	b2dd      	uxtb	r5, r3
 1ae:	6c23      	ldr	r3, [r4, #64]
 1b0:	429d      	cmp	r5, r3
 1b2:	d3f0      	bcc.n	196 <dhcp_recv+0x196>
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1339
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
 1b4:	f04f 0300 	mov.w	r3, #0	; 0x0
 1b8:	84f3      	strh	r3, [r6, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1342
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
 1ba:	4638      	mov	r0, r7
 1bc:	f7ff fffe 	bl	0 <dhcp_recv>
 1c0:	e056      	b.n	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1349
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
 1c2:	3b03      	subs	r3, #3
 1c4:	b2db      	uxtb	r3, r3
 1c6:	2b02      	cmp	r3, #2
 1c8:	d852      	bhi.n	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1350
      dhcp->request_timeout = 0;
 1ca:	f04f 0300 	mov.w	r3, #0	; 0x0
 1ce:	84f3      	strh	r3, [r6, #38]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1351
      dhcp_bind(netif);
 1d0:	4638      	mov	r0, r7
 1d2:	f7ff fffe 	bl	0 <dhcp_recv>
 1d6:	e04b      	b.n	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1355
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 1d8:	2806      	cmp	r0, #6
 1da:	d123      	bne.n	224 <dhcp_recv+0x224>
 1dc:	7833      	ldrb	r3, [r6, #0]
 1de:	2b03      	cmp	r3, #3
 1e0:	d005      	beq.n	1ee <dhcp_recv+0x1ee>
 1e2:	2b01      	cmp	r3, #1
 1e4:	d003      	beq.n	1ee <dhcp_recv+0x1ee>
 1e6:	2b04      	cmp	r3, #4
 1e8:	d001      	beq.n	1ee <dhcp_recv+0x1ee>
 1ea:	2b05      	cmp	r3, #5
 1ec:	d140      	bne.n	270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1359
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
 1ee:	f04f 0300 	mov.w	r3, #0	; 0x0
 1f2:	84f3      	strh	r3, [r6, #38]
dhcp_handle_nak():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:167
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
 1f4:	4638      	mov	r0, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:163
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
 1f6:	6a3c      	ldr	r4, [r7, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:167
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
 1f8:	f7ff fffe 	bl	0 <netif_set_down>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:169
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 1fc:	4638      	mov	r0, r7
 1fe:	4921      	ldr	r1, [pc, #132]	(284 <dhcp_recv+0x284>)
 200:	f7ff fffe 	bl	0 <netif_set_ipaddr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:170
  netif_set_gw(netif, IP_ADDR_ANY);
 204:	4638      	mov	r0, r7
 206:	491f      	ldr	r1, [pc, #124]	(284 <dhcp_recv+0x284>)
 208:	f7ff fffe 	bl	0 <netif_set_gw>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:171
  netif_set_netmask(netif, IP_ADDR_ANY); 
 20c:	4638      	mov	r0, r7
 20e:	491d      	ldr	r1, [pc, #116]	(284 <dhcp_recv+0x284>)
 210:	f7ff fffe 	bl	0 <netif_set_netmask>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:173
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 214:	4620      	mov	r0, r4
 216:	210c      	movs	r1, #12
 218:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:175
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 21c:	4638      	mov	r0, r7
 21e:	f7ff fffe 	bl	0 <dhcp_recv>
 222:	e025      	b.n	270 <dhcp_recv+0x270>
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1363
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
 224:	2802      	cmp	r0, #2
 226:	d123      	bne.n	270 <dhcp_recv+0x270>
 228:	7833      	ldrb	r3, [r6, #0]
 22a:	2b06      	cmp	r3, #6
 22c:	d120      	bne.n	270 <dhcp_recv+0x270>
dhcp_handle_offer():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:216
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
 22e:	6a3c      	ldr	r4, [r7, #32]
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1365
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
 230:	f04f 0300 	mov.w	r3, #0	; 0x0
 234:	84f3      	strh	r3, [r6, #38]
dhcp_handle_offer():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:218
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
 236:	4620      	mov	r0, r4
 238:	2136      	movs	r1, #54
 23a:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:221
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
 23e:	b1b8      	cbz	r0, 270 <dhcp_recv+0x270>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:222
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
 240:	3002      	adds	r0, #2
 242:	f7ff fffe 	bl	0 <dhcp_recv>
 246:	f7ff fffe 	bl	0 <htonl>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:225
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
 24a:	6921      	ldr	r1, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:222
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
 24c:	62e0      	str	r0, [r4, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:225
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
 24e:	f111 0310 	adds.w	r3, r1, #16	; 0x10
 252:	d009      	beq.n	268 <dhcp_recv+0x268>
 254:	7c4a      	ldrb	r2, [r1, #17]
 256:	7c0b      	ldrb	r3, [r1, #16]
 258:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 25c:	7c8a      	ldrb	r2, [r1, #18]
 25e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 262:	7cca      	ldrb	r2, [r1, #19]
 264:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 268:	6323      	str	r3, [r4, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:228
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
 26a:	4638      	mov	r0, r7
 26c:	f7ff fffe 	bl	0 <dhcp_recv>
dhcp_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1370
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp_free_reply(dhcp);
 270:	4630      	mov	r0, r6
 272:	f7ff fffe 	bl	0 <dhcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1371
  pbuf_free(p);
 276:	4648      	mov	r0, r9
 278:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1372
  dhcp->p = NULL;
 27c:	2300      	movs	r3, #0
 27e:	60f3      	str	r3, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:1373
}
 280:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 284:	00000000 	.word	0x00000000
Disassembly of section .text.dhcp_fine_tmr:

00000000 <dhcp_fine_tmr>:
dhcp_fine_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:347
 * 
 */
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
   0:	4b22      	ldr	r3, [pc, #136]	(8c <dhcp_fine_tmr+0x8c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:346
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:347
  struct netif *netif = netif_list;
   4:	681c      	ldr	r4, [r3, #0]
   6:	e03d      	b.n	84 <dhcp_fine_tmr+0x84>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:351
  /* loop through netif's */
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
   8:	6a22      	ldr	r2, [r4, #32]
   a:	2a00      	cmp	r2, #0
   c:	d039      	beq.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:353
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
   e:	8cd3      	ldrh	r3, [r2, #38]
  10:	2b01      	cmp	r3, #1
  12:	d902      	bls.n	1a <dhcp_fine_tmr+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:354
        netif->dhcp->request_timeout--;
  14:	3b01      	subs	r3, #1
  16:	84d3      	strh	r3, [r2, #38]
  18:	e033      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:356
      }
      else if (netif->dhcp->request_timeout == 1) {
  1a:	d132      	bne.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:357
        netif->dhcp->request_timeout--;
  1c:	f04f 0300 	mov.w	r3, #0	; 0x0
  20:	84d3      	strh	r3, [r2, #38]
dhcp_timeout():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:383
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  22:	7813      	ldrb	r3, [r2, #0]
  24:	2b0c      	cmp	r3, #12
  26:	d029      	beq.n	7c <dhcp_fine_tmr+0x7c>
  28:	2b06      	cmp	r3, #6
  2a:	d027      	beq.n	7c <dhcp_fine_tmr+0x7c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:387
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  2c:	2b01      	cmp	r3, #1
  2e:	d106      	bne.n	3e <dhcp_fine_tmr+0x3e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:389
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  30:	7853      	ldrb	r3, [r2, #1]
  32:	2b05      	cmp	r3, #5
  34:	d81f      	bhi.n	76 <dhcp_fine_tmr+0x76>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:390
      dhcp_select(netif);
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
  3c:	e021      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:397
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  3e:	2b08      	cmp	r3, #8
  40:	d10a      	bne.n	58 <dhcp_fine_tmr+0x58>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:399
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  42:	7853      	ldrb	r3, [r2, #1]
  44:	2b01      	cmp	r3, #1
  46:	d803      	bhi.n	50 <dhcp_fine_tmr+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:400
      dhcp_check(netif);
  48:	4620      	mov	r0, r4
  4a:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
  4e:	e018      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:405
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
  56:	e014      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:409
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  58:	2b05      	cmp	r3, #5
  5a:	d103      	bne.n	64 <dhcp_fine_tmr+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:413
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
  62:	e00e      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:415
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  64:	2b04      	cmp	r3, #4
  66:	d10c      	bne.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:417
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  68:	7853      	ldrb	r3, [r2, #1]
  6a:	2b08      	cmp	r3, #8
  6c:	d803      	bhi.n	76 <dhcp_fine_tmr+0x76>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:418
      dhcp_rebind(netif);
  6e:	4620      	mov	r0, r4
  70:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
  74:	e005      	b.n	82 <dhcp_fine_tmr+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:421
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:422
      dhcp_discover(netif);
  7c:	4620      	mov	r0, r4
  7e:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
dhcp_fine_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:365
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  82:	6824      	ldr	r4, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:349
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  84:	2c00      	cmp	r4, #0
  86:	d1bf      	bne.n	8 <dhcp_fine_tmr+0x8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/dhcp.c:367
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  88:	bd10      	pop	{r4, pc}
  8a:	46c0      	nop			(mov r8, r8)
  8c:	00000000 	.word	0x00000000
