
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\helloworld.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\helloworld.o

Disassembly of section .text.HelloWorld_init:

00000000 <HelloWorld_init>:
HelloWorld_init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:162
  * @brief  Initialize the hello application  
  * @param  None 
  * @retval None 
  */
void HelloWorld_init(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:166
  struct tcp_pcb *pcb;	            		
  
  /* Create a new TCP control block  */
  pcb = tcp_new();	                		 	
   2:	f7ff fffe 	bl	0 <tcp_new>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:170

  /* Assign to the new pcb a local IP address and a port number */
  /* Using IP_ADDR_ANY allow the pcb to be used by any local interface */
  tcp_bind(pcb, IP_ADDR_ANY, 23);       
   6:	2217      	movs	r2, #23
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:166
void HelloWorld_init(void)
{
  struct tcp_pcb *pcb;	            		
  
  /* Create a new TCP control block  */
  pcb = tcp_new();	                		 	
   8:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:170

  /* Assign to the new pcb a local IP address and a port number */
  /* Using IP_ADDR_ANY allow the pcb to be used by any local interface */
  tcp_bind(pcb, IP_ADDR_ANY, 23);       
   a:	4905      	ldr	r1, [pc, #20]	(20 <HelloWorld_init+0x20>)
   c:	f7ff fffe 	bl	0 <tcp_bind>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:174


  /* Set the connection to the LISTEN state */
  pcb = tcp_listen(pcb);				
  10:	21ff      	movs	r1, #255
  12:	4620      	mov	r0, r4
  14:	f7ff fffe 	bl	0 <tcp_listen_with_backlog>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:177

  /* Specify the function to be called when a connection is established */	
  tcp_accept(pcb, HelloWorld_accept);   
  18:	4902      	ldr	r1, [pc, #8]	(c <tcp_accept+0xc>)
  1a:	f7ff fffe 	bl	0 <tcp_accept>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:179
										
}
  1e:	bd10      	pop	{r4, pc}
	...
Disassembly of section .text.HelloWorld_accept:

00000000 <HelloWorld_accept>:
HelloWorld_accept():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:141
  * @param  pcb	 the tcp_pcb which accepted the connection
  * @param  err	 error value
  * @retval ERR_OK
  */
static err_t HelloWorld_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{     
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:144
  
  /* Tell LwIP to associate this structure with this connection. */
  tcp_arg(pcb, mem_calloc(sizeof(struct name), 1));	
   2:	2024      	movs	r0, #36
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:141
  * @param  pcb	 the tcp_pcb which accepted the connection
  * @param  err	 error value
  * @retval ERR_OK
  */
static err_t HelloWorld_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{     
   4:	460c      	mov	r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:144
  
  /* Tell LwIP to associate this structure with this connection. */
  tcp_arg(pcb, mem_calloc(sizeof(struct name), 1));	
   6:	2101      	movs	r1, #1
   8:	f7ff fffe 	bl	0 <mem_calloc>
   c:	4601      	mov	r1, r0
   e:	4620      	mov	r0, r4
  10:	f7ff fffe 	bl	0 <tcp_arg>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:147
  
  /* Configure LwIP to use our call back functions. */
  tcp_err(pcb, HelloWorld_conn_err);
  14:	4620      	mov	r0, r4
  16:	4907      	ldr	r1, [pc, #28]	(34 <HelloWorld_accept+0x34>)
  18:	f7ff fffe 	bl	0 <tcp_err>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:148
  tcp_recv(pcb, HelloWorld_recv);
  1c:	4620      	mov	r0, r4
  1e:	4906      	ldr	r1, [pc, #24]	(38 <HelloWorld_accept+0x38>)
  20:	f7ff fffe 	bl	0 <tcp_recv>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:151
  
  /* Send out the first message */  
  tcp_write(pcb, GREETING, strlen(GREETING), 1); 
  24:	4620      	mov	r0, r4
  26:	4905      	ldr	r1, [pc, #20]	(3c <HelloWorld_accept+0x3c>)
  28:	221b      	movs	r2, #27
  2a:	2301      	movs	r3, #1
  2c:	f7ff fffe 	bl	0 <tcp_write>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:154

  return ERR_OK;
}
  30:	2000      	movs	r0, #0
  32:	bd10      	pop	{r4, pc}
	...
Disassembly of section .text.HelloWorld_conn_err:

00000000 <HelloWorld_conn_err>:
HelloWorld_conn_err():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:188
  * @param  arg
  * @parm   err
  * @retval None 
  */
static void HelloWorld_conn_err(void *arg, err_t err)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:192
  struct name *name;
  name = (struct name *)arg;

  mem_free(name);
   2:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:193
}
   6:	bd10      	pop	{r4, pc}
Disassembly of section .text.HelloWorld_recv:

00000000 <HelloWorld_recv>:
HelloWorld_recv():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:57
  * @param  p	the packet buffer
  * @param  err	the error value linked with the received data
  * @retval error value
  */
static err_t HelloWorld_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   6:	460f      	mov	r7, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:66
  char *c;
  int i;
 

  /* We perform here any necessary processing on the pbuf */
  if (p != NULL) 
   8:	4616      	mov	r6, r2
   a:	2a00      	cmp	r2, #0
   c:	d062      	beq.n	d4 <HelloWorld_recv+0xd4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:70
  {        
	/* We call this function to tell the LwIp that we have processed the data */
	/* This lets the stack advertise a larger window, so more data can be received*/
	tcp_recved(pcb, p->tot_len);
   e:	4608      	mov	r0, r1
  10:	8911      	ldrh	r1, [r2, #8]
  12:	f7ff fffe 	bl	0 <tcp_recved>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:73

    /* Check the name if NULL, no data passed, return withh illegal argument error */
	if(!name) 
  16:	b924      	cbnz	r4, 22 <HelloWorld_recv+0x22>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:75
    {
      pbuf_free(p);
  18:	4630      	mov	r0, r6
  1a:	f7ff fffe 	bl	0 <pbuf_free>
  1e:	20f6      	movs	r0, #246
  20:	e061      	b.n	e6 <HelloWorld_recv+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:76
      return ERR_ARG;
  22:	4635      	mov	r5, r6
  24:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:82
    }

    done = 0;
    for(q=p; q != NULL; q = q->next) 
    {
      c = q->payload;
  26:	f8d5 c004 	ldr.w	ip, [r5, #4]
  2a:	2100      	movs	r1, #0
  2c:	e014      	b.n	58 <HelloWorld_recv+0x58>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:85
      for(i=0; i<q->len && !done; i++) 
	  {
        done = ((c[i] == '\r') || (c[i] == '\n'));
  2e:	f81c e001 	ldrb.w	lr, [ip, r1]
  32:	fa4f f38e 	sxtb.w	r3, lr
  36:	2b0d      	cmp	r3, #13
  38:	d101      	bne.n	3e <HelloWorld_recv+0x3e>
  3a:	2001      	movs	r0, #1
  3c:	e003      	b.n	46 <HelloWorld_recv+0x46>
  3e:	2b0a      	cmp	r3, #10
  40:	bf14      	ite	ne
  42:	2000      	movne	r0, #0
  44:	2001      	moveq	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:86
        if(name->length < MAX_NAME_SIZE) 
  46:	6822      	ldr	r2, [r4, #0]
  48:	2a1f      	cmp	r2, #31
  4a:	dc04      	bgt.n	56 <HelloWorld_recv+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:88
	    {
          name->bytes[name->length++] = c[i];
  4c:	18a3      	adds	r3, r4, r2
  4e:	f883 e004 	strb.w	lr, [r3, #4]
  52:	1c53      	adds	r3, r2, #1
  54:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:83

    done = 0;
    for(q=p; q != NULL; q = q->next) 
    {
      c = q->payload;
      for(i=0; i<q->len && !done; i++) 
  56:	3101      	adds	r1, #1
  58:	896b      	ldrh	r3, [r5, #10]
  5a:	4299      	cmp	r1, r3
  5c:	da01      	bge.n	62 <HelloWorld_recv+0x62>
  5e:	2800      	cmp	r0, #0
  60:	d0e5      	beq.n	2e <HelloWorld_recv+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:80
      pbuf_free(p);
      return ERR_ARG;
    }

    done = 0;
    for(q=p; q != NULL; q = q->next) 
  62:	682d      	ldr	r5, [r5, #0]
  64:	2d00      	cmp	r5, #0
  66:	d1de      	bne.n	26 <HelloWorld_recv+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:92
	    {
          name->bytes[name->length++] = c[i];
        }
      }
    }
    if(done) 
  68:	2800      	cmp	r0, #0
  6a:	d02e      	beq.n	ca <HelloWorld_recv+0xca>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:94
    {
      if(name->bytes[name->length-2] != '\r' || name->bytes[name->length-1] != '\n') 
  6c:	6822      	ldr	r2, [r4, #0]
  6e:	18a1      	adds	r1, r4, r2
  70:	f991 3002 	ldrsb.w	r3, [r1, #2]
  74:	2b0d      	cmp	r3, #13
  76:	d103      	bne.n	80 <HelloWorld_recv+0x80>
  78:	f991 3003 	ldrsb.w	r3, [r1, #3]
  7c:	2b0a      	cmp	r3, #10
  7e:	d016      	beq.n	ae <HelloWorld_recv+0xae>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:96
	  {
        if((name->bytes[name->length-1] == '\r' || name->bytes[name->length-1] == '\n') && (name->length+1 <= MAX_NAME_SIZE)) 
  80:	18a3      	adds	r3, r4, r2
  82:	f993 3003 	ldrsb.w	r3, [r3, #3]
  86:	2b0d      	cmp	r3, #13
  88:	d001      	beq.n	8e <HelloWorld_recv+0x8e>
  8a:	2b0a      	cmp	r3, #10
  8c:	d103      	bne.n	96 <HelloWorld_recv+0x96>
  8e:	2a1f      	cmp	r2, #31
  90:	dc05      	bgt.n	9e <HelloWorld_recv+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:98
	    {
	      name->length += 1;
  92:	1c53      	adds	r3, r2, #1
  94:	e004      	b.n	a0 <HelloWorld_recv+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:100
        } 
	    else if(name->length+2 <= MAX_NAME_SIZE) 
  96:	2a1e      	cmp	r2, #30
  98:	dc01      	bgt.n	9e <HelloWorld_recv+0x9e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:102
	    {
          name->length += 2;
  9a:	1c93      	adds	r3, r2, #2
  9c:	e000      	b.n	a0 <HelloWorld_recv+0xa0>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:106
        } 
	    else 
	    {
          name->length = MAX_NAME_SIZE;
  9e:	2320      	movs	r3, #32
  a0:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:109
        }

        name->bytes[name->length-2] = '\r';
  a2:	6823      	ldr	r3, [r4, #0]
  a4:	220d      	movs	r2, #13
  a6:	18e3      	adds	r3, r4, r3
  a8:	709a      	strb	r2, [r3, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:110
        name->bytes[name->length-1] = '\n';
  aa:	220a      	movs	r2, #10
  ac:	70da      	strb	r2, [r3, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:112
      }
      tcp_write(pcb, HELLO, strlen(HELLO), 1);
  ae:	490f      	ldr	r1, [pc, #60]	(ec <HelloWorld_recv+0xec>)
  b0:	2206      	movs	r2, #6
  b2:	2301      	movs	r3, #1
  b4:	4638      	mov	r0, r7
  b6:	f7ff fffe 	bl	0 <tcp_write>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:114

      tcp_write(pcb, name->bytes, name->length, TCP_WRITE_FLAG_COPY);
  ba:	2301      	movs	r3, #1
  bc:	4638      	mov	r0, r7
  be:	1d21      	adds	r1, r4, #4
  c0:	8822      	ldrh	r2, [r4, #0]
  c2:	f7ff fffe 	bl	0 <tcp_write>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:115
      name->length = 0;
  c6:	2300      	movs	r3, #0
  c8:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:119
    }
	
	/* End of processing, we free the pbuf */
    pbuf_free(p);
  ca:	4630      	mov	r0, r6
  cc:	f7ff fffe 	bl	0 <pbuf_free>
  d0:	2000      	movs	r0, #0
  d2:	e008      	b.n	e6 <HelloWorld_recv+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:121
  }  
  else if (err == ERR_OK) 
  d4:	b10b      	cbz	r3, da <HelloWorld_recv+0xda>
  d6:	4610      	mov	r0, r2
  d8:	e005      	b.n	e6 <HelloWorld_recv+0xe6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:125
  {
    /* When the pbuf is NULL and the err is ERR_OK, the remote end is closing the connection. */
    /* We free the allocated memory and we close the connection */
    mem_free(name);
  da:	f7ff fffe 	bl	0 <mem_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:126
    return tcp_close(pcb);
  de:	4638      	mov	r0, r7
  e0:	f7ff fffe 	bl	0 <tcp_close>
  e4:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\port/helloworld.c:131
  }
  return ERR_OK;


}
  e6:	b240      	sxtb	r0, r0
  e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  ec:	0000001c 	.word	0x0000001c
