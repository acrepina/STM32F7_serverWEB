
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\etharp.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\etharp.o

Disassembly of section .text.etharp_send_ip:

00000000 <etharp_send_ip>:
etharp_send_ip():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:429
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:430
  struct eth_hdr *ethhdr = p->payload;
   6:	684c      	ldr	r4, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:429
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   8:	4696      	mov	lr, r2
   a:	4618      	mov	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:430
  struct eth_hdr *ethhdr = p->payload;
   c:	2106      	movs	r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:437

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
   e:	1e4b      	subs	r3, r1, #1
  10:	b2d9      	uxtb	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:438
    ethhdr->dest.addr[k] = dst->addr[k];
  12:	5c43      	ldrb	r3, [r0, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:439
    ethhdr->src.addr[k]  = src->addr[k];
  14:	1862      	adds	r2, r4, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:438
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  16:	5463      	strb	r3, [r4, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:439
    ethhdr->src.addr[k]  = src->addr[k];
  18:	f81e 3001 	ldrb.w	r3, [lr, r1]
  1c:	7193      	strb	r3, [r2, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:436
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  1e:	2900      	cmp	r1, #0
  20:	d1f5      	bne.n	e <etharp_send_ip+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:441
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  22:	f44f 6000 	mov.w	r0, #2048	; 0x800
  26:	f7ff fffe 	bl	0 <htons>
  2a:	7320      	strb	r0, [r4, #12]
  2c:	f3c0 200f 	ubfx	r0, r0, #8, #16
  30:	7360      	strb	r0, [r4, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:444
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  32:	69ab      	ldr	r3, [r5, #24]
  34:	4628      	mov	r0, r5
  36:	4631      	mov	r1, r6
  38:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:445
}
  3a:	b240      	sxtb	r0, r0
  3c:	bd70      	pop	{r4, r5, r6, pc}
  3e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.etharp_request:

00000000 <etharp_request>:
etharp_request():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1110
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
etharp_raw():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1043
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, sizeof(struct etharp_hdr), PBUF_RAM);
   4:	2200      	movs	r2, #0
etharp_request():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1110
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
   6:	4605      	mov	r5, r0
   8:	4688      	mov	r8, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1112
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   a:	f100 0725 	add.w	r7, r0, #37	; 0x25
etharp_raw():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1043
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, sizeof(struct etharp_hdr), PBUF_RAM);
   e:	212a      	movs	r1, #42
  10:	2003      	movs	r0, #3
  12:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1045
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  16:	4606      	mov	r6, r0
  18:	b908      	cbnz	r0, 1e <etharp_request+0x1e>
  1a:	24ff      	movs	r4, #255
  1c:	e04b      	b.n	b6 <etharp_request+0xb6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1053
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  1e:	6844      	ldr	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1055
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  20:	2001      	movs	r0, #1
  22:	f7ff fffe 	bl	0 <htons>
  26:	7520      	strb	r0, [r4, #20]
  28:	f3c0 200f 	ubfx	r0, r0, #8, #16
  2c:	7560      	strb	r0, [r4, #21]
  2e:	2006      	movs	r0, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1067
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  30:	1e43      	subs	r3, r0, #1
  32:	b2d8      	uxtb	r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1069
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  34:	5c3b      	ldrb	r3, [r7, r0]
  36:	1821      	adds	r1, r4, r0
  38:	758b      	strb	r3, [r1, #22]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1070
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  3a:	4b20      	ldr	r3, [pc, #128]	(bc <etharp_request+0xbc>)
  3c:	5c1a      	ldrb	r2, [r3, r0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1075
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  3e:	181b      	adds	r3, r3, r0
  40:	799b      	ldrb	r3, [r3, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1070
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  42:	f881 2020 	strb.w	r2, [r1, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1075
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  46:	5423      	strb	r3, [r4, r0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1077
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  48:	5c3b      	ldrb	r3, [r7, r0]
  4a:	718b      	strb	r3, [r1, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1066
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  4c:	2800      	cmp	r0, #0
  4e:	d1ef      	bne.n	30 <etharp_request+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1079
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  50:	f104 001c 	add.w	r0, r4, #28	; 0x1c
  54:	1d29      	adds	r1, r5, #4
  56:	2204      	movs	r2, #4
  58:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1080
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  5c:	4641      	mov	r1, r8
  5e:	2204      	movs	r2, #4
  60:	f104 0026 	add.w	r0, r4, #38	; 0x26
  64:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1082

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  68:	2001      	movs	r0, #1
  6a:	f7ff fffe 	bl	0 <htons>
  6e:	73a0      	strb	r0, [r4, #14]
  70:	f3c0 200f 	ubfx	r0, r0, #8, #16
  74:	73e0      	strb	r0, [r4, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1083
  hdr->proto = htons(ETHTYPE_IP);
  76:	f44f 6000 	mov.w	r0, #2048	; 0x800
  7a:	f7ff fffe 	bl	0 <htons>
  7e:	7420      	strb	r0, [r4, #16]
  80:	f3c0 200f 	ubfx	r0, r0, #8, #16
  84:	7460      	strb	r0, [r4, #17]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1085
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  86:	f240 6004 	movw	r0, #1540	; 0x604
  8a:	f7ff fffe 	bl	0 <htons>
  8e:	74a0      	strb	r0, [r4, #18]
  90:	f3c0 200f 	ubfx	r0, r0, #8, #16
  94:	74e0      	strb	r0, [r4, #19]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1087

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  96:	f640 0006 	movw	r0, #2054	; 0x806
  9a:	f7ff fffe 	bl	0 <htons>
  9e:	7320      	strb	r0, [r4, #12]
  a0:	f3c0 200f 	ubfx	r0, r0, #8, #16
  a4:	7360      	strb	r0, [r4, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1089
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  a6:	69ab      	ldr	r3, [r5, #24]
  a8:	4628      	mov	r0, r5
  aa:	4631      	mov	r1, r6
  ac:	4798      	blx	r3
  ae:	b2c4      	uxtb	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1092
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  b0:	4630      	mov	r0, r6
  b2:	f7ff fffe 	bl	0 <pbuf_free>
etharp_request():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1115
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  b6:	b260      	sxtb	r0, r4
  b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bc:	00000000 	.word	0x00000000
Disassembly of section .text.free_etharp_q:

00000000 <free_etharp_q>:
free_etharp_q():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:144
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	e008      	b.n	18 <free_etharp_q+0x18>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:152
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
   6:	6868      	ldr	r0, [r5, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:150
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
   8:	682c      	ldr	r4, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:152
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
   a:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:153
    memp_free(MEMP_ARP_QUEUE, r);
   e:	4629      	mov	r1, r5
  10:	2006      	movs	r0, #6
  12:	f7ff fffe 	bl	0 <memp_free>
  16:	4625      	mov	r5, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:148
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  18:	2d00      	cmp	r5, #0
  1a:	d1f4      	bne.n	6 <memp_free+0x6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:155
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  1c:	bd70      	pop	{r4, r5, r6, pc}
  1e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.find_entry:

00000000 <find_entry>:
find_entry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:232
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:245
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
   4:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:232
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
   6:	9100      	str	r1, [sp, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:245
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
   8:	b138      	cbz	r0, 1a <find_entry+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:261
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
   a:	4b5e      	ldr	r3, [pc, #376]	(184 <find_entry+0x184>)
   c:	2214      	movs	r2, #20
   e:	7818      	ldrb	r0, [r3, #0]
  10:	fb02 3400 	mla	r4, r2, r0, r3
  14:	7ca3      	ldrb	r3, [r4, #18]
  16:	2b02      	cmp	r3, #2
  18:	d00b      	beq.n	32 <find_entry+0x32>
  1a:	f04f 090a 	mov.w	r9, #10	; 0xa
  1e:	2000      	movs	r0, #0
  20:	4959      	ldr	r1, [pc, #356]	(188 <find_entry+0x188>)
  22:	46cb      	mov	fp, r9
  24:	46ca      	mov	sl, r9
  26:	4684      	mov	ip, r0
  28:	4607      	mov	r7, r0
  2a:	f8cd 9004 	str.w	r9, [sp, #4]
  2e:	4680      	mov	r8, r0
  30:	e010      	b.n	54 <find_entry+0x54>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:263
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  32:	7872      	ldrb	r2, [r6, #1]
  34:	7833      	ldrb	r3, [r6, #0]
  36:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  3a:	78b2      	ldrb	r2, [r6, #2]
  3c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  40:	78f2      	ldrb	r2, [r6, #3]
  42:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  46:	68a2      	ldr	r2, [r4, #8]
  48:	4293      	cmp	r3, r2
  4a:	d1e6      	bne.n	1a <find_entry+0x1a>
  4c:	e097      	b.n	17e <find_entry+0x17e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:266
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  4e:	46ac      	mov	ip, r5
  50:	4627      	mov	r7, r4
  52:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:289
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  54:	fa4f f38a 	sxtb.w	r3, sl
  58:	2b0a      	cmp	r3, #10
  5a:	d103      	bne.n	64 <find_entry+0x64>
  5c:	7b8b      	ldrb	r3, [r1, #14]
  5e:	b90b      	cbnz	r3, 64 <find_entry+0x64>
  60:	4682      	mov	sl, r0
  62:	e037      	b.n	d4 <find_entry+0xd4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:295
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  64:	7b8b      	ldrb	r3, [r1, #14]
  66:	2b01      	cmp	r3, #1
  68:	d11b      	bne.n	a2 <find_entry+0xa2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:297
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  6a:	b166      	cbz	r6, 86 <find_entry+0x86>
  6c:	7872      	ldrb	r2, [r6, #1]
  6e:	7833      	ldrb	r3, [r6, #0]
  70:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  74:	78b2      	ldrb	r2, [r6, #2]
  76:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  7a:	78f2      	ldrb	r2, [r6, #3]
  7c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  80:	684a      	ldr	r2, [r1, #4]
  82:	4293      	cmp	r3, r2
  84:	d01d      	beq.n	c2 <find_entry+0xc2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:308
        etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  86:	680b      	ldr	r3, [r1, #0]
  88:	7bca      	ldrb	r2, [r1, #15]
  8a:	b12b      	cbz	r3, 98 <find_entry+0x98>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:309
        if (arp_table[i].ctime >= age_queue) {
  8c:	4542      	cmp	r2, r8
  8e:	d321      	bcc.n	d4 <find_entry+0xd4>
  90:	9001      	str	r0, [sp, #4]
  92:	4665      	mov	r5, ip
  94:	463c      	mov	r4, r7
  96:	e020      	b.n	da <find_entry+0xda>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:316
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  98:	4562      	cmp	r2, ip
  9a:	4615      	mov	r5, r2
  9c:	d31a      	bcc.n	d4 <find_entry+0xd4>
  9e:	4681      	mov	r9, r0
  a0:	e019      	b.n	d6 <find_entry+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:323
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  a2:	2b02      	cmp	r3, #2
  a4:	d116      	bne.n	d4 <find_entry+0xd4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:325
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  a6:	b17e      	cbz	r6, c8 <find_entry+0xc8>
  a8:	7872      	ldrb	r2, [r6, #1]
  aa:	7833      	ldrb	r3, [r6, #0]
  ac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  b0:	78b2      	ldrb	r2, [r6, #2]
  b2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  b6:	78f2      	ldrb	r2, [r6, #3]
  b8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  bc:	684a      	ldr	r2, [r1, #4]
  be:	4293      	cmp	r3, r2
  c0:	d102      	bne.n	c8 <find_entry+0xc8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:331
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  c2:	4b30      	ldr	r3, [pc, #192]	(184 <find_entry+0x184>)
  c4:	7018      	strb	r0, [r3, #0]
  c6:	e05a      	b.n	17e <find_entry+0x17e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:335
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  c8:	7bcc      	ldrb	r4, [r1, #15]
  ca:	42bc      	cmp	r4, r7
  cc:	d302      	bcc.n	d4 <find_entry+0xd4>
  ce:	4683      	mov	fp, r0
  d0:	4665      	mov	r5, ip
  d2:	e001      	b.n	d8 <find_entry+0xd8>
  d4:	4665      	mov	r5, ip
  d6:	463c      	mov	r4, r7
  d8:	4642      	mov	r2, r8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:287
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  da:	1c43      	adds	r3, r0, #1
  dc:	b2d8      	uxtb	r0, r3
  de:	3114      	adds	r1, #20
  e0:	280a      	cmp	r0, #10
  e2:	d1b4      	bne.n	4e <find_entry+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:344
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  e4:	fa4f f38a 	sxtb.w	r3, sl
  e8:	2b0a      	cmp	r3, #10
  ea:	d103      	bne.n	f4 <find_entry+0xf4>
  ec:	9a00      	ldr	r2, [sp, #0]
  ee:	f012 0f01 	tst.w	r2, #1	; 0x1
  f2:	d043      	beq.n	17c <find_entry+0x17c>
  f4:	9b00      	ldr	r3, [sp, #0]
  f6:	f013 0702 	ands.w	r7, r3, #2	; 0x2
  fa:	d13f      	bne.n	17c <find_entry+0x17c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:361
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  fc:	fa4f f38a 	sxtb.w	r3, sl
 100:	2b0a      	cmp	r3, #10
 102:	d002      	beq.n	10a <find_entry+0x10a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:362
    i = empty;
 104:	fa5f f58a 	uxtb.w	r5, sl
 108:	e01a      	b.n	140 <find_entry+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:366
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
 10a:	fa4f f38b 	sxtb.w	r3, fp
 10e:	2b0a      	cmp	r3, #10
 110:	d002      	beq.n	118 <find_entry+0x118>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:368
    /* recycle oldest stable*/
    i = old_stable;
 112:	fa5f f58b 	uxtb.w	r5, fp
 116:	e013      	b.n	140 <find_entry+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:375
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
 118:	fa4f f389 	sxtb.w	r3, r9
 11c:	2b0a      	cmp	r3, #10
 11e:	d002      	beq.n	126 <find_entry+0x126>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:377
    /* recycle oldest pending */
    i = old_pending;
 120:	fa5f f589 	uxtb.w	r5, r9
 124:	e00c      	b.n	140 <find_entry+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:381
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
 126:	9a01      	ldr	r2, [sp, #4]
 128:	b253      	sxtb	r3, r2
 12a:	2b0a      	cmp	r3, #10
 12c:	d026      	beq.n	17c <find_entry+0x17c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:385
    /* recycle oldest pending */
    i = old_queue;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 12e:	4b15      	ldr	r3, [pc, #84]	(184 <find_entry+0x184>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:383
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_queue;
 130:	b2d5      	uxtb	r5, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:385
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 132:	2414      	movs	r4, #20
 134:	fb04 3405 	mla	r4, r4, r5, r3
 138:	6860      	ldr	r0, [r4, #4]
 13a:	f7ff fffe 	bl	0 <find_entry>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:386
    arp_table[i].q = NULL;
 13e:	6067      	str	r7, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:401
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 140:	4b10      	ldr	r3, [pc, #64]	(184 <find_entry+0x184>)
 142:	2214      	movs	r2, #20
 144:	fb02 3105 	mla	r1, r2, r5, r3
 148:	2300      	movs	r3, #0
 14a:	f101 020c 	add.w	r2, r1, #12	; 0xc
 14e:	7193      	strb	r3, [r2, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:404

  /* IP address given? */
  if (ipaddr != NULL) {
 150:	b156      	cbz	r6, 168 <find_entry+0x168>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:406
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
 152:	7872      	ldrb	r2, [r6, #1]
 154:	7833      	ldrb	r3, [r6, #0]
 156:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 15a:	78b2      	ldrb	r2, [r6, #2]
 15c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 160:	78f2      	ldrb	r2, [r6, #3]
 162:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 166:	608b      	str	r3, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:408
  }
  arp_table[i].ctime = 0;
 168:	4b06      	ldr	r3, [pc, #24]	(184 <find_entry+0x184>)
 16a:	2214      	movs	r2, #20
 16c:	fb02 3205 	mla	r2, r2, r5, r3
 170:	2100      	movs	r1, #0
 172:	320c      	adds	r2, #12
 174:	71d1      	strb	r1, [r2, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:414
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
 176:	4628      	mov	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:412
  }
  arp_table[i].ctime = 0;
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
 178:	701d      	strb	r5, [r3, #0]
 17a:	e000      	b.n	17e <find_entry+0x17e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:414
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
 17c:	20ff      	movs	r0, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:415
}
 17e:	b240      	sxtb	r0, r0
 180:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 184:	00000000 	.word	0x00000000
 188:	00000004 	.word	0x00000004
Disassembly of section .text.etharp_query:

00000000 <etharp_query>:
etharp_query():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:875
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4681      	mov	r9, r0
   6:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:881
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   8:	4608      	mov	r0, r1
   a:	4649      	mov	r1, r9
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:875
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
   c:	4617      	mov	r7, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:881
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   e:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  12:	2800      	cmp	r0, #0
  14:	f040 8089 	bne.w	12a <etharp_query+0x12a>
  18:	7873      	ldrb	r3, [r6, #1]
  1a:	7834      	ldrb	r4, [r6, #0]
  1c:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
  20:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  24:	78b3      	ldrb	r3, [r6, #2]
  26:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  2a:	78f3      	ldrb	r3, [r6, #3]
  2c:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  30:	f7ff fffe 	bl	0 <ntohl>
  34:	4605      	mov	r5, r0
  36:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  3a:	f7ff fffe 	bl	0 <ntohl>
  3e:	4025      	ands	r5, r4
  40:	4285      	cmp	r5, r0
  42:	d072      	beq.n	12a <etharp_query+0x12a>
  44:	7872      	ldrb	r2, [r6, #1]
  46:	7833      	ldrb	r3, [r6, #0]
  48:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4c:	78b2      	ldrb	r2, [r6, #2]
  4e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  52:	78f2      	ldrb	r2, [r6, #3]
  54:	ea53 6202 	orrs.w	r2, r3, r2, lsl #24
  58:	d067      	beq.n	12a <etharp_query+0x12a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:892

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  5a:	2101      	movs	r1, #1
  5c:	4630      	mov	r0, r6
  5e:	f7ff fffe 	bl	0 <etharp_query>
  62:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:896
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  64:	fa4f f880 	sxtb.w	r8, r0
  68:	f1b8 0f00 	cmp.w	r8, #0	; 0x0
  6c:	db60      	blt.n	130 <etharp_query+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:906
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  6e:	4a34      	ldr	r2, [pc, #208]	(140 <etharp_query+0x140>)
  70:	2314      	movs	r3, #20
  72:	fb03 2308 	mla	r3, r3, r8, r2
  76:	f103 020c 	add.w	r2, r3, #12	; 0xc
  7a:	7993      	ldrb	r3, [r2, #6]
  7c:	b90b      	cbnz	r3, 82 <etharp_query+0x82>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:907
    arp_table[i].state = ETHARP_STATE_PENDING;
  7e:	3301      	adds	r3, #1
  80:	7193      	strb	r3, [r2, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:916
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  82:	4a2f      	ldr	r2, [pc, #188]	(140 <etharp_query+0x140>)
  84:	2314      	movs	r3, #20
  86:	fb03 2308 	mla	r3, r3, r8, r2
  8a:	7c9b      	ldrb	r3, [r3, #18]
  8c:	2b01      	cmp	r3, #1
  8e:	d002      	beq.n	96 <etharp_query+0x96>
  90:	b10f      	cbz	r7, 96 <etharp_query+0x96>
  92:	25ff      	movs	r5, #255
  94:	e006      	b.n	a4 <etharp_query+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:918
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  96:	4648      	mov	r0, r9
  98:	4631      	mov	r1, r6
  9a:	f7ff fffe 	bl	0 <etharp_query>
  9e:	b2c5      	uxtb	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:928
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  a0:	2f00      	cmp	r7, #0
  a2:	d044      	beq.n	12e <etharp_query+0x12e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:930
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  a4:	2314      	movs	r3, #20
  a6:	fb03 f208 	mul.w	r2, r3, r8
  aa:	4925      	ldr	r1, [pc, #148]	(140 <etharp_query+0x140>)
  ac:	188b      	adds	r3, r1, r2
  ae:	7c9b      	ldrb	r3, [r3, #18]
  b0:	2b02      	cmp	r3, #2
  b2:	d109      	bne.n	c8 <etharp_query+0xc8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:933
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  b4:	188b      	adds	r3, r1, r2
  b6:	4648      	mov	r0, r9
  b8:	4639      	mov	r1, r7
  ba:	f109 0225 	add.w	r2, r9, #37	; 0x25
  be:	330c      	adds	r3, #12
  c0:	f7ff fffe 	bl	0 <etharp_query>
  c4:	b2c0      	uxtb	r0, r0
  c6:	e033      	b.n	130 <etharp_query+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:935
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  c8:	2b01      	cmp	r3, #1
  ca:	d130      	bne.n	12e <etharp_query+0x12e>
  cc:	463a      	mov	r2, r7
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:945
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
        if(p->type != PBUF_ROM) {
  ce:	7b13      	ldrb	r3, [r2, #12]
  d0:	2b01      	cmp	r3, #1
  d2:	d103      	bne.n	dc <etharp_query+0xdc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:949
          copy_needed = 1;
          break;
        }
        p = p->next;
  d4:	6812      	ldr	r2, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:943
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  d6:	2a00      	cmp	r2, #0
  d8:	d1f9      	bne.n	ce <etharp_query+0xce>
  da:	e02c      	b.n	136 <etharp_query+0x136>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:953
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  dc:	8911      	ldrh	r1, [r2, #8]
  de:	2003      	movs	r0, #3
  e0:	2200      	movs	r2, #0
  e2:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:954
        if(p != NULL) {
  e6:	4604      	mov	r4, r0
  e8:	b308      	cbz	r0, 12e <etharp_query+0x12e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:955
          if (pbuf_copy(p, q) != ERR_OK) {
  ea:	4639      	mov	r1, r7
  ec:	f7ff fffe 	bl	0 <pbuf_copy>
  f0:	f010 0fff 	tst.w	r0, #255	; 0xff
  f4:	d115      	bne.n	122 <etharp_query+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:970
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  f6:	2006      	movs	r0, #6
  f8:	f7ff fffe 	bl	0 <memp_malloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:971
        if (new_entry != NULL) {
  fc:	4601      	mov	r1, r0
  fe:	b180      	cbz	r0, 122 <etharp_query+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:972
          new_entry->next = 0;
 100:	2300      	movs	r3, #0
 102:	6003      	str	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:974
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
 104:	4b0e      	ldr	r3, [pc, #56]	(140 <etharp_query+0x140>)
 106:	2214      	movs	r2, #20
 108:	fb02 3308 	mla	r3, r2, r8, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:973
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
          new_entry->p = p;
 10c:	6044      	str	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:974
          if(arp_table[i].q != NULL) {
 10e:	6858      	ldr	r0, [r3, #4]
 110:	b128      	cbz	r0, 11e <etharp_query+0x11e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:978
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
 112:	4603      	mov	r3, r0
 114:	6800      	ldr	r0, [r0, #0]
 116:	2800      	cmp	r0, #0
 118:	d1fb      	bne.n	112 <etharp_query+0x112>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:981
              r = r->next;
            }
            r->next = new_entry;
 11a:	6019      	str	r1, [r3, #0]
 11c:	e008      	b.n	130 <etharp_query+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:984
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
 11e:	6059      	str	r1, [r3, #4]
 120:	e006      	b.n	130 <etharp_query+0x130>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:990
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
 122:	4620      	mov	r0, r4
 124:	f7ff fffe 	bl	0 <pbuf_free>
 128:	e001      	b.n	12e <etharp_query+0x12e>
 12a:	20f6      	movs	r0, #246
 12c:	e000      	b.n	130 <etharp_query+0x130>
 12e:	b2e8      	uxtb	r0, r5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1007
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
 130:	b240      	sxtb	r0, r0
 132:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:963
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
 136:	4638      	mov	r0, r7
 138:	f7ff fffe 	bl	0 <pbuf_ref>
 13c:	463c      	mov	r4, r7
 13e:	e7da      	b.n	f6 <etharp_query+0xf6>
 140:	00000000 	.word	0x00000000
Disassembly of section .text.etharp_output:

00000000 <etharp_output>:
etharp_output():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:785
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4607      	mov	r7, r0
   6:	4689      	mov	r9, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:789
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   8:	4608      	mov	r0, r1
   a:	210e      	movs	r1, #14
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:785
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
   c:	4616      	mov	r6, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:789
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   e:	f7ff fffe 	bl	0 <pbuf_header>
  12:	b108      	cbz	r0, 18 <etharp_output+0x18>
  14:	20fe      	movs	r0, #254
  16:	e077      	b.n	108 <etharp_output+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:802
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  18:	4630      	mov	r0, r6
  1a:	4639      	mov	r1, r7
  1c:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  20:	4680      	mov	r8, r0
  22:	b108      	cbz	r0, 28 <etharp_output+0x28>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:804
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  24:	4b3a      	ldr	r3, [pc, #232]	(110 <etharp_output+0x110>)
  26:	e068      	b.n	fa <etharp_output+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:806
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  28:	7873      	ldrb	r3, [r6, #1]
  2a:	7834      	ldrb	r4, [r6, #0]
  2c:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
  30:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  34:	78b3      	ldrb	r3, [r6, #2]
  36:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  3a:	78f3      	ldrb	r3, [r6, #3]
  3c:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  40:	f7ff fffe 	bl	0 <ntohl>
  44:	4605      	mov	r5, r0
  46:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  4a:	f7ff fffe 	bl	0 <ntohl>
  4e:	4025      	ands	r5, r4
  50:	4285      	cmp	r5, r0
  52:	d137      	bne.n	c4 <etharp_output+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:808
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  54:	2301      	movs	r3, #1
  56:	f88d 3002 	strb.w	r3, [sp, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:810
    mcastaddr.addr[1] = 0x00;
    mcastaddr.addr[2] = 0x5e;
  5a:	335d      	adds	r3, #93
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:809
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
    mcastaddr.addr[1] = 0x00;
  5c:	f88d 8003 	strb.w	r8, [sp, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:810
    mcastaddr.addr[2] = 0x5e;
  60:	f88d 3004 	strb.w	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:811
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  64:	7873      	ldrb	r3, [r6, #1]
  66:	7830      	ldrb	r0, [r6, #0]
  68:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  6c:	78b3      	ldrb	r3, [r6, #2]
  6e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  72:	78f3      	ldrb	r3, [r6, #3]
  74:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
  78:	f7ff fffe 	bl	0 <ntohl>
  7c:	f3c0 4006 	ubfx	r0, r0, #16, #7
  80:	f88d 0005 	strb.w	r0, [sp, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:812
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  84:	7873      	ldrb	r3, [r6, #1]
  86:	7830      	ldrb	r0, [r6, #0]
  88:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  8c:	78b3      	ldrb	r3, [r6, #2]
  8e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  92:	78f3      	ldrb	r3, [r6, #3]
  94:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
  98:	f7ff fffe 	bl	0 <ntohl>
  9c:	0a00      	lsrs	r0, r0, #8
  9e:	f88d 0006 	strb.w	r0, [sp, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:813
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  a2:	7873      	ldrb	r3, [r6, #1]
  a4:	7830      	ldrb	r0, [r6, #0]
  a6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  aa:	78b3      	ldrb	r3, [r6, #2]
  ac:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
  b0:	78f3      	ldrb	r3, [r6, #3]
  b2:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
  b6:	f7ff fffe 	bl	0 <ntohl>
  ba:	f10d 0302 	add.w	r3, sp, #2	; 0x2
  be:	f88d 0007 	strb.w	r0, [sp, #7]
  c2:	e01a      	b.n	fa <etharp_output+0xfa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:819
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  c4:	7872      	ldrb	r2, [r6, #1]
  c6:	7833      	ldrb	r3, [r6, #0]
  c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  cc:	78b2      	ldrb	r2, [r6, #2]
  ce:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  d2:	78f2      	ldrb	r2, [r6, #3]
  d4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  d8:	687a      	ldr	r2, [r7, #4]
  da:	4053      	eors	r3, r2
  dc:	68ba      	ldr	r2, [r7, #8]
  de:	4213      	tst	r3, r2
  e0:	d005      	beq.n	ee <etharp_output+0xee>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:821
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  e2:	68fb      	ldr	r3, [r7, #12]
  e4:	b90b      	cbnz	r3, ea <etharp_output+0xea>
  e6:	20fc      	movs	r0, #252
  e8:	e00e      	b.n	108 <etharp_output+0x108>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:823
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  ea:	f107 060c 	add.w	r6, r7, #12	; 0xc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:831
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  ee:	4638      	mov	r0, r7
  f0:	4631      	mov	r1, r6
  f2:	464a      	mov	r2, r9
  f4:	f7ff fffe 	bl	0 <etharp_output>
  f8:	e005      	b.n	106 <etharp_output+0x106>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:837
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  fa:	4638      	mov	r0, r7
  fc:	4649      	mov	r1, r9
  fe:	f107 0225 	add.w	r2, r7, #37	; 0x25
 102:	f7ff fffe 	bl	0 <etharp_output>
 106:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:838
}
 108:	b240      	sxtb	r0, r0
 10a:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 10e:	46c0      	nop			(mov r8, r8)
 110:	00000006 	.word	0x00000006
Disassembly of section .text.etharp_find_addr:

00000000 <etharp_find_addr>:
etharp_find_addr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:546
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:554
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
   2:	4608      	mov	r0, r1
   4:	2102      	movs	r1, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:546
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
   6:	4614      	mov	r4, r2
   8:	461d      	mov	r5, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:554
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
   a:	f7ff fffe 	bl	0 <etharp_find_addr>
   e:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:556
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  10:	b241      	sxtb	r1, r0
  12:	2900      	cmp	r1, #0
  14:	db0f      	blt.n	36 <etharp_find_addr+0x36>
  16:	2314      	movs	r3, #20
  18:	4359      	muls	r1, r3
  1a:	4a08      	ldr	r2, [pc, #32]	(3c <etharp_find_addr+0x3c>)
  1c:	1853      	adds	r3, r2, r1
  1e:	7c9b      	ldrb	r3, [r3, #18]
  20:	2b02      	cmp	r3, #2
  22:	d108      	bne.n	36 <etharp_find_addr+0x36>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:557
      *eth_ret = &arp_table[i].ethaddr;
  24:	3204      	adds	r2, #4
  26:	f101 0308 	add.w	r3, r1, #8	; 0x8
  2a:	18d3      	adds	r3, r2, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:558
      *ip_ret = &arp_table[i].ipaddr;
  2c:	1852      	adds	r2, r2, r1
  2e:	3204      	adds	r2, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:557
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
      *eth_ret = &arp_table[i].ethaddr;
  30:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:558
      *ip_ret = &arp_table[i].ipaddr;
  32:	602a      	str	r2, [r5, #0]
  34:	e000      	b.n	38 <etharp_find_addr+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:559
      return i;
  36:	20ff      	movs	r0, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:562
  }
  return -1;
}
  38:	b240      	sxtb	r0, r0
  3a:	bd70      	pop	{r4, r5, r6, pc}
  3c:	00000000 	.word	0x00000000
Disassembly of section .text.etharp_tmr:

00000000 <etharp_tmr>:
etharp_tmr():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:166
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
   0:	b510      	push	{r4, lr}
   2:	4c0d      	ldr	r4, [pc, #52]	(38 <etharp_tmr+0x38>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:172
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
   4:	7be3      	ldrb	r3, [r4, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:173
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   6:	7ba2      	ldrb	r2, [r4, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:172
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
   8:	3301      	adds	r3, #1
   a:	b2db      	uxtb	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:173
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
   c:	2a02      	cmp	r2, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:172
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
   e:	73e3      	strb	r3, [r4, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:173
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  10:	d101      	bne.n	16 <etharp_tmr+0x16>
  12:	2bef      	cmp	r3, #239
  14:	e002      	b.n	1c <etharp_tmr+0x1c>
  16:	2a01      	cmp	r2, #1
  18:	d109      	bne.n	2e <etharp_tmr+0x2e>
  1a:	2b01      	cmp	r3, #1
  1c:	d907      	bls.n	2e <etharp_tmr+0x2e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:185
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  1e:	6820      	ldr	r0, [r4, #0]
  20:	b118      	cbz	r0, 2a <etharp_tmr+0x2a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:188
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  22:	f7ff fffe 	bl	0 <etharp_tmr>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:189
        arp_table[i].q = NULL;
  26:	2300      	movs	r3, #0
  28:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:193
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  2a:	2300      	movs	r3, #0
  2c:	73a3      	strb	r3, [r4, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:171
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  2e:	4b03      	ldr	r3, [pc, #12]	(3c <etharp_tmr+0x3c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:193
        free_etharp_q(arp_table[i].q);
        arp_table[i].q = NULL;
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  30:	3414      	adds	r4, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:171
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  32:	429c      	cmp	r4, r3
  34:	d1e6      	bne.n	4 <etharp_tmr+0x4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:202
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  36:	bd10      	pop	{r4, pc}
  38:	00000004 	.word	0x00000004
  3c:	000000cc 	.word	0x000000cc
Disassembly of section .text.update_arp_entry:

00000000 <update_arp_entry>:
update_arp_entry():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:468
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4680      	mov	r8, r0
   6:	4617      	mov	r7, r2
   8:	4699      	mov	r9, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:478
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   a:	460e      	mov	r6, r1
   c:	2900      	cmp	r1, #0
   e:	d061      	beq.n	d4 <update_arp_entry+0xd4>
  10:	784a      	ldrb	r2, [r1, #1]
  12:	780b      	ldrb	r3, [r1, #0]
  14:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  18:	788a      	ldrb	r2, [r1, #2]
  1a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  1e:	78ca      	ldrb	r2, [r1, #3]
  20:	ea53 6202 	orrs.w	r2, r3, r2, lsl #24
  24:	d056      	beq.n	d4 <update_arp_entry+0xd4>
  26:	4608      	mov	r0, r1
  28:	4641      	mov	r1, r8
  2a:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  2e:	4682      	mov	sl, r0
  30:	2800      	cmp	r0, #0
  32:	d14f      	bne.n	d4 <update_arp_entry+0xd4>
  34:	7873      	ldrb	r3, [r6, #1]
  36:	7834      	ldrb	r4, [r6, #0]
  38:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
  3c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  40:	78b3      	ldrb	r3, [r6, #2]
  42:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  46:	78f3      	ldrb	r3, [r6, #3]
  48:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  4c:	f7ff fffe 	bl	0 <ntohl>
  50:	4605      	mov	r5, r0
  52:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  56:	f7ff fffe 	bl	0 <ntohl>
  5a:	4025      	ands	r5, r4
  5c:	4285      	cmp	r5, r0
  5e:	d039      	beq.n	d4 <update_arp_entry+0xd4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:488
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  60:	4649      	mov	r1, r9
  62:	4630      	mov	r0, r6
  64:	f7ff fffe 	bl	0 <update_arp_entry>
  68:	b2c1      	uxtb	r1, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:491
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  6a:	b24d      	sxtb	r5, r1
  6c:	2d00      	cmp	r5, #0
  6e:	db32      	blt.n	d6 <update_arp_entry+0xd6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:495
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  70:	4b1a      	ldr	r3, [pc, #104]	(dc <update_arp_entry+0xdc>)
  72:	2214      	movs	r2, #20
  74:	fb02 3205 	mla	r2, r2, r5, r3
  78:	2302      	movs	r3, #2
  7a:	f102 010c 	add.w	r1, r2, #12	; 0xc
  7e:	718b      	strb	r3, [r1, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:497
  /* record network interface */
  arp_table[i].netif = netif;
  80:	f8c2 8014 	str.w	r8, [r2, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:507
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  84:	797b      	ldrb	r3, [r7, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:524
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  86:	f108 0625 	add.w	r6, r8, #37	; 0x25
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:507
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8a:	7453      	strb	r3, [r2, #17]
  8c:	793b      	ldrb	r3, [r7, #4]
  8e:	7413      	strb	r3, [r2, #16]
  90:	78fb      	ldrb	r3, [r7, #3]
  92:	73d3      	strb	r3, [r2, #15]
  94:	78bb      	ldrb	r3, [r7, #2]
  96:	7393      	strb	r3, [r2, #14]
  98:	787b      	ldrb	r3, [r7, #1]
  9a:	7353      	strb	r3, [r2, #13]
  9c:	783b      	ldrb	r3, [r7, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:510
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  9e:	f881 a007 	strb.w	sl, [r1, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:507
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  a2:	7313      	strb	r3, [r2, #12]
  a4:	e00e      	b.n	c4 <update_arp_entry+0xc4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:518
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  a6:	680b      	ldr	r3, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:520
    /* get the packet pointer */
    p = q->p;
  a8:	684c      	ldr	r4, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:518
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  aa:	6053      	str	r3, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:522
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  ac:	2006      	movs	r0, #6
  ae:	f7ff fffe 	bl	0 <memp_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:524
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  b2:	4640      	mov	r0, r8
  b4:	4621      	mov	r1, r4
  b6:	4632      	mov	r2, r6
  b8:	463b      	mov	r3, r7
  ba:	f7ff fffe 	bl	0 <update_arp_entry>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:526
    /* free the queued IP packet */
    pbuf_free(p);
  be:	4620      	mov	r0, r4
  c0:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:513
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  c4:	4b05      	ldr	r3, [pc, #20]	(dc <update_arp_entry+0xdc>)
  c6:	2214      	movs	r2, #20
  c8:	fb02 3205 	mla	r2, r2, r5, r3
  cc:	6851      	ldr	r1, [r2, #4]
  ce:	2900      	cmp	r1, #0
  d0:	d1e9      	bne.n	a6 <update_arp_entry+0xa6>
  d2:	e000      	b.n	d6 <update_arp_entry+0xd6>
  d4:	21f6      	movs	r1, #246
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:530
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  d6:	b248      	sxtb	r0, r1
  d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  dc:	00000000 	.word	0x00000000
Disassembly of section .text.etharp_ip_input:

00000000 <etharp_ip_input>:
etharp_ip_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:581
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:583
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   2:	4605      	mov	r5, r0
   4:	b1a0      	cbz	r0, 30 <etharp_ip_input+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:586
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
   6:	684c      	ldr	r4, [r1, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:588
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
   8:	7ee2      	ldrb	r2, [r4, #27]
   a:	7ea3      	ldrb	r3, [r4, #26]
   c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  10:	7f22      	ldrb	r2, [r4, #28]
  12:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  16:	7f62      	ldrb	r2, [r4, #29]
  18:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  1c:	6842      	ldr	r2, [r0, #4]
  1e:	4053      	eors	r3, r2
  20:	6882      	ldr	r2, [r0, #8]
  22:	4013      	ands	r3, r2
  24:	d104      	bne.n	30 <etharp_ip_input+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:597

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  26:	f104 011a 	add.w	r1, r4, #26	; 0x1a
  2a:	1da2      	adds	r2, r4, #6
  2c:	f7ff fffe 	bl	0 <etharp_ip_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:598
}
  30:	bd70      	pop	{r4, r5, r6, pc}
  32:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.etharp_arp_input:

00000000 <etharp_arp_input>:
etharp_arp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:618
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	468a      	mov	sl, r1
   6:	4617      	mov	r7, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:628
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   8:	4606      	mov	r6, r0
   a:	2800      	cmp	r0, #0
   c:	f000 808c 	beq.w	128 <etharp_arp_input+0x128>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:632
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  10:	8953      	ldrh	r3, [r2, #10]
  12:	2b29      	cmp	r3, #41
  14:	f240 8085 	bls.w	122 <etharp_arp_input+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:640
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  18:	6855      	ldr	r5, [r2, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:643

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  1a:	2001      	movs	r0, #1
  1c:	7bac      	ldrb	r4, [r5, #14]
  1e:	7beb      	ldrb	r3, [r5, #15]
  20:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  24:	f7ff fffe 	bl	0 <htons>
  28:	4284      	cmp	r4, r0
  2a:	d17a      	bne.n	122 <etharp_arp_input+0x122>
  2c:	7cac      	ldrb	r4, [r5, #18]
  2e:	7ceb      	ldrb	r3, [r5, #19]
  30:	f240 6004 	movw	r0, #1540	; 0x604
  34:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  38:	f7ff fffe 	bl	0 <htons>
  3c:	4284      	cmp	r4, r0
  3e:	d170      	bne.n	122 <etharp_arp_input+0x122>
  40:	7c2c      	ldrb	r4, [r5, #16]
  42:	7c6b      	ldrb	r3, [r5, #17]
  44:	f44f 6000 	mov.w	r0, #2048	; 0x800
  48:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  4c:	f7ff fffe 	bl	0 <htons>
  50:	4284      	cmp	r4, r0
  52:	d166      	bne.n	122 <etharp_arp_input+0x122>
  54:	7b2c      	ldrb	r4, [r5, #12]
  56:	7b6b      	ldrb	r3, [r5, #13]
  58:	f640 0006 	movw	r0, #2054	; 0x806
  5c:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  60:	f7ff fffe 	bl	0 <htons>
  64:	4284      	cmp	r4, r0
  66:	d15c      	bne.n	122 <etharp_arp_input+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:666
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  68:	f105 091c 	add.w	r9, r5, #28	; 0x1c
  6c:	f10d 0804 	add.w	r8, sp, #4	; 0x4
  70:	4649      	mov	r1, r9
  72:	2204      	movs	r2, #4
  74:	4640      	mov	r0, r8
  76:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:667
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  7a:	2204      	movs	r2, #4
  7c:	4668      	mov	r0, sp
  7e:	f105 0126 	add.w	r1, r5, #38	; 0x26
  82:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:670

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  86:	6872      	ldr	r2, [r6, #4]
  88:	b15a      	cbz	r2, a2 <etharp_arp_input+0xa2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:674
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  8a:	9b00      	ldr	r3, [sp, #0]
  8c:	4293      	cmp	r3, r2
  8e:	bf14      	ite	ne
  90:	2400      	movne	r4, #0
  92:	2401      	moveq	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:678
  }

  /* ARP message directed to us? */
  if (for_us) {
  94:	b134      	cbz	r4, a4 <etharp_arp_input+0xa4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:681
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  96:	4630      	mov	r0, r6
  98:	4641      	mov	r1, r8
  9a:	f105 0216 	add.w	r2, r5, #22	; 0x16
  9e:	2301      	movs	r3, #1
  a0:	e005      	b.n	ae <etharp_arp_input+0xae>
  a2:	4614      	mov	r4, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:685
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  a4:	4630      	mov	r0, r6
  a6:	a901      	add	r1, sp, #4
  a8:	f105 0216 	add.w	r2, r5, #22	; 0x16
  ac:	2300      	movs	r3, #0
  ae:	f7ff fffe 	bl	0 <etharp_arp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:689
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  b2:	7d2b      	ldrb	r3, [r5, #20]
  b4:	7d68      	ldrb	r0, [r5, #21]
  b6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  ba:	f7ff fffe 	bl	0 <htons>
  be:	2801      	cmp	r0, #1
  c0:	d002      	beq.n	c8 <etharp_arp_input+0xc8>
  c2:	2802      	cmp	r0, #2
  c4:	d12d      	bne.n	122 <etharp_arp_input+0x122>
  c6:	e028      	b.n	11a <etharp_arp_input+0x11a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:698
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  c8:	b35c      	cbz	r4, 122 <etharp_arp_input+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:704

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  ca:	2002      	movs	r0, #2
  cc:	f7ff fffe 	bl	0 <htons>
  d0:	7528      	strb	r0, [r5, #20]
  d2:	f3c0 200f 	ubfx	r0, r0, #8, #16
  d6:	7568      	strb	r0, [r5, #21]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:706

      hdr->dipaddr = hdr->sipaddr;
  d8:	f105 011c 	add.w	r1, r5, #28	; 0x1c
  dc:	2204      	movs	r2, #4
  de:	f105 0026 	add.w	r0, r5, #38	; 0x26
  e2:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:707
      SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
  e6:	1d31      	adds	r1, r6, #4
  e8:	4648      	mov	r0, r9
  ea:	2204      	movs	r2, #4
  ec:	f7ff fffe 	bl	0 <memcpy>
  f0:	2106      	movs	r1, #6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:719
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  f2:	1e4b      	subs	r3, r1, #1
  f4:	b2d9      	uxtb	r1, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:720
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  f6:	186a      	adds	r2, r5, r1
  f8:	7d93      	ldrb	r3, [r2, #22]
  fa:	f882 3020 	strb.w	r3, [r2, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:724
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  fe:	546b      	strb	r3, [r5, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:726
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
 100:	f81a 3001 	ldrb.w	r3, [sl, r1]
 104:	7593      	strb	r3, [r2, #22]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:727
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
 106:	f81a 3001 	ldrb.w	r3, [sl, r1]
 10a:	7193      	strb	r3, [r2, #6]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:718
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
 10c:	2900      	cmp	r1, #0
 10e:	d1f0      	bne.n	f2 <etharp_arp_input+0xf2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:734

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 110:	69b3      	ldr	r3, [r6, #24]
 112:	4630      	mov	r0, r6
 114:	4639      	mov	r1, r7
 116:	4798      	blx	r3
 118:	e003      	b.n	122 <etharp_arp_input+0x122>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:753
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
 11a:	4630      	mov	r0, r6
 11c:	a901      	add	r1, sp, #4
 11e:	f7ff fffe 	bl	0 <dhcp_arp_reply>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:762
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
 122:	4638      	mov	r0, r7
 124:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:763
}
 128:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
Disassembly of section .text.ethernet_input:

00000000 <ethernet_input>:
ethernet_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1127
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1140
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
   2:	6843      	ldr	r3, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1127
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   4:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1140
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
   6:	7b1a      	ldrb	r2, [r3, #12]
   8:	7b58      	ldrb	r0, [r3, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1127
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   a:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1140
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
   c:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  10:	f7ff fffe 	bl	0 <htons>
  14:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
  18:	d004      	beq.n	24 <ethernet_input+0x24>
  1a:	f640 0306 	movw	r3, #2054	; 0x806
  1e:	4298      	cmp	r0, r3
  20:	d116      	bne.n	50 <ethernet_input+0x50>
  22:	e00e      	b.n	42 <ethernet_input+0x42>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1145
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  24:	4628      	mov	r0, r5
  26:	4621      	mov	r1, r4
  28:	f7ff fffe 	bl	0 <ethernet_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1148
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  2c:	4620      	mov	r0, r4
  2e:	f06f 010d 	mvn.w	r1, #13	; 0xd
  32:	f7ff fffe 	bl	0 <pbuf_header>
  36:	b958      	cbnz	r0, 50 <ethernet_input+0x50>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1154
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  38:	4620      	mov	r0, r4
  3a:	4629      	mov	r1, r5
  3c:	f7ff fffe 	bl	0 <ip_input>
  40:	e009      	b.n	56 <ethernet_input+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1160
      }
      break;
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  42:	4628      	mov	r0, r5
  44:	f105 0125 	add.w	r1, r5, #37	; 0x25
  48:	4622      	mov	r2, r4
  4a:	f7ff fffe 	bl	0 <ethernet_input>
  4e:	e002      	b.n	56 <ethernet_input+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1176
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\netif/etharp.c:1184
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  56:	2000      	movs	r0, #0
  58:	bd70      	pop	{r4, r5, r6, pc}
  5a:	46c0      	nop			(mov r8, r8)
