
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\tcp_in.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\tcp_in.o

Disassembly of section .text.tcp_parseopt:

00000000 <tcp_parseopt>:
tcp_parseopt():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1343
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   0:	b570      	push	{r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1351
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   2:	4c25      	ldr	r4, [pc, #148]	(98 <tcp_parseopt+0x98>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1343
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   4:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1351
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   6:	6823      	ldr	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1354

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
   8:	7b1a      	ldrb	r2, [r3, #12]
   a:	7b58      	ldrb	r0, [r3, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1351
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   c:	f103 0514 	add.w	r5, r3, #20	; 0x14
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1354

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  10:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  14:	f7ff fffe 	bl	0 <ntohs>
  18:	f3c0 300f 	ubfx	r0, r0, #12, #16
  1c:	2805      	cmp	r0, #5
  1e:	d939      	bls.n	94 <tcp_parseopt+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1355
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
  20:	6823      	ldr	r3, [r4, #0]
  22:	7b1a      	ldrb	r2, [r3, #12]
  24:	7b58      	ldrb	r0, [r3, #13]
  26:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  2a:	f7ff fffe 	bl	0 <ntohs>
  2e:	0b00      	lsrs	r0, r0, #12
  30:	3805      	subs	r0, #5
  32:	0080      	lsls	r0, r0, #2
  34:	b284      	uxth	r4, r0
  36:	f04f 0e00 	mov.w	lr, #0	; 0x0
  3a:	e029      	b.n	90 <tcp_parseopt+0x90>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1358
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
  3c:	f815 300e 	ldrb.w	r3, [r5, lr]
  40:	2b01      	cmp	r3, #1
  42:	d005      	beq.n	50 <tcp_parseopt+0x50>
  44:	d326      	bcc.n	94 <tcp_parseopt+0x94>
  46:	2b02      	cmp	r3, #2
  48:	eb05 010e 	add.w	r1, r5, lr
  4c:	d11b      	bne.n	86 <tcp_parseopt+0x86>
  4e:	e002      	b.n	56 <tcp_parseopt+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1365
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
  50:	f10e 0301 	add.w	r3, lr, #1	; 0x1
  54:	e01a      	b.n	8c <tcp_parseopt+0x8c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1370
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
  56:	784b      	ldrb	r3, [r1, #1]
  58:	2b04      	cmp	r3, #4
  5a:	d11b      	bne.n	94 <tcp_parseopt+0x94>
  5c:	f10e 0303 	add.w	r3, lr, #3	; 0x3
  60:	42a3      	cmp	r3, r4
  62:	da17      	bge.n	94 <tcp_parseopt+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1376
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  64:	788a      	ldrb	r2, [r1, #2]
  66:	78cb      	ldrb	r3, [r1, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1378
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  68:	f240 50b4 	movw	r0, #1460	; 0x5b4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1376
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1378
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  70:	1e5a      	subs	r2, r3, #1
  72:	b292      	uxth	r2, r2
  74:	f240 51b3 	movw	r1, #1459	; 0x5b3
  78:	428a      	cmp	r2, r1
  7a:	bf88      	it	hi
  7c:	4603      	movhi	r3, r0
  7e:	8733      	strh	r3, [r6, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1380
        /* Advance to next option */
        c += 0x04;
  80:	f10e 0304 	add.w	r3, lr, #4	; 0x4
  84:	e002      	b.n	8c <tcp_parseopt+0x8c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1405
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
  86:	784b      	ldrb	r3, [r1, #1]
  88:	b123      	cbz	r3, 94 <tcp_parseopt+0x94>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1413
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  8a:	4473      	add	r3, lr
  8c:	fa1f fe83 	uxth.w	lr, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1356
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
  90:	45a6      	cmp	lr, r4
  92:	d3d3      	bcc.n	3c <tcp_parseopt+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1417
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  94:	bd70      	pop	{r4, r5, r6, pc}
  96:	46c0      	nop			(mov r8, r8)
  98:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_receive:

00000000 <tcp_receive>:
tcp_receive():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:728
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:740
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
   6:	4890      	ldr	r0, [pc, #576]	(248 <tcp_receive+0x248>)
   8:	7903      	ldrb	r3, [r0, #4]
   a:	f013 0f10 	tst.w	r3, #16	; 0x10
   e:	f000 818d 	beq.w	32c <tcp_receive+0x32c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:744
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  12:	6e31      	ldr	r1, [r6, #96]
  14:	6882      	ldr	r2, [r0, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:741
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
  16:	f8b6 505c 	ldrh.w	r5, [r6, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:744

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  1a:	1a8b      	subs	r3, r1, r2
  1c:	2b00      	cmp	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:741
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
  1e:	6e74      	ldr	r4, [r6, #100]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:744

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  20:	db10      	blt.n	44 <tcp_receive+0x44>
  22:	4291      	cmp	r1, r2
  24:	d103      	bne.n	2e <tcp_receive+0x2e>
  26:	68c3      	ldr	r3, [r0, #12]
  28:	1ae3      	subs	r3, r4, r3
  2a:	2b00      	cmp	r3, #0
  2c:	db0a      	blt.n	44 <tcp_receive+0x44>
  2e:	4a86      	ldr	r2, [pc, #536]	(248 <tcp_receive+0x248>)
  30:	68d3      	ldr	r3, [r2, #12]
  32:	429c      	cmp	r4, r3
  34:	d11b      	bne.n	6e <tcp_receive+0x6e>
  36:	6813      	ldr	r3, [r2, #0]
  38:	7b9a      	ldrb	r2, [r3, #14]
  3a:	7bdb      	ldrb	r3, [r3, #15]
  3c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
  40:	42aa      	cmp	r2, r5
  42:	d914      	bls.n	6e <tcp_receive+0x6e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:747
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  44:	4980      	ldr	r1, [pc, #512]	(248 <tcp_receive+0x248>)
  46:	680a      	ldr	r2, [r1, #0]
  48:	7b93      	ldrb	r3, [r2, #14]
  4a:	7bd2      	ldrb	r2, [r2, #15]
  4c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  50:	f8a6 305c 	strh.w	r3, [r6, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:748
      pcb->snd_wl1 = seqno;
  54:	688b      	ldr	r3, [r1, #8]
  56:	6633      	str	r3, [r6, #96]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:749
      pcb->snd_wl2 = ackno;
  58:	68cb      	ldr	r3, [r1, #12]
  5a:	6673      	str	r3, [r6, #100]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:750
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  5c:	f8b6 305c 	ldrh.w	r3, [r6, #92]
  60:	b12b      	cbz	r3, 6e <tcp_receive+0x6e>
  62:	f896 309c 	ldrb.w	r3, [r6, #156]
  66:	b113      	cbz	r3, 6e <tcp_receive+0x6e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:751
          pcb->persist_backoff = 0;
  68:	2300      	movs	r3, #0
  6a:	f886 309c 	strb.w	r3, [r6, #156]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:765
                     pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  6e:	4b76      	ldr	r3, [pc, #472]	(248 <tcp_receive+0x248>)
  70:	6cf1      	ldr	r1, [r6, #76]
  72:	68da      	ldr	r2, [r3, #12]
  74:	4291      	cmp	r1, r2
  76:	d14d      	bne.n	114 <tcp_receive+0x114>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:766
      pcb->acked = 0;
  78:	f04f 0200 	mov.w	r2, #0	; 0x0
  7c:	f8a6 206c 	strh.w	r2, [r6, #108]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:768

      if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
  80:	f8b6 305c 	ldrh.w	r3, [r6, #92]
  84:	6e72      	ldr	r2, [r6, #100]
  86:	189b      	adds	r3, r3, r2
  88:	192a      	adds	r2, r5, r4
  8a:	4293      	cmp	r3, r2
  8c:	f040 80ef 	bne.w	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:769
        ++pcb->dupacks;
  90:	f896 3050 	ldrb.w	r3, [r6, #80]
  94:	3301      	adds	r3, #1
  96:	b2db      	uxtb	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:770
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  98:	2b02      	cmp	r3, #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:769

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
        ++pcb->dupacks;
  9a:	f886 3050 	strb.w	r3, [r6, #80]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:770
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  9e:	f240 80e6 	bls.w	26e <tcp_receive+0x26e>
  a2:	6fb3      	ldr	r3, [r6, #120]
  a4:	2b00      	cmp	r3, #0
  a6:	f000 80e2 	beq.w	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:771
          if (!(pcb->flags & TF_INFR)) {
  aa:	f896 3022 	ldrb.w	r3, [r6, #34]
  ae:	f013 0f04 	tst.w	r3, #4	; 0x4
  b2:	d124      	bne.n	fe <tcp_receive+0xfe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:776
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  b4:	4630      	mov	r0, r6
  b6:	f7ff fffe 	bl	0 <tcp_rexmit>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:782
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  ba:	f8b6 2052 	ldrh.w	r2, [r6, #82]
  be:	f8b6 305c 	ldrh.w	r3, [r6, #92]
  c2:	429a      	cmp	r2, r3
  c4:	d901      	bls.n	ca <tcp_receive+0xca>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:783
              pcb->ssthresh = pcb->snd_wnd / 2;
  c6:	085b      	lsrs	r3, r3, #1
  c8:	e000      	b.n	cc <tcp_receive+0xcc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:785
            else
              pcb->ssthresh = pcb->cwnd / 2;
  ca:	0853      	lsrs	r3, r2, #1
  cc:	f8a6 3054 	strh.w	r3, [r6, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:788

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  d0:	8f33      	ldrh	r3, [r6, #56]
  d2:	005a      	lsls	r2, r3, #1
  d4:	f8b6 3054 	ldrh.w	r3, [r6, #84]
  d8:	4293      	cmp	r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:790
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  da:	bfb8      	it	lt
  dc:	f8a6 2054 	strhlt.w	r2, [r6, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:793
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  e0:	8f33      	ldrh	r3, [r6, #56]
  e2:	f8b6 1054 	ldrh.w	r1, [r6, #84]
  e6:	2203      	movs	r2, #3
  e8:	fb02 1303 	mla	r3, r2, r3, r1
  ec:	f8a6 3052 	strh.w	r3, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:794
            pcb->flags |= TF_INFR;
  f0:	f896 3022 	ldrb.w	r3, [r6, #34]
  f4:	f043 0304 	orr.w	r3, r3, #4	; 0x4
  f8:	f886 3022 	strb.w	r3, [r6, #34]
  fc:	e0b7      	b.n	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:798
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  fe:	f8b6 2052 	ldrh.w	r2, [r6, #82]
 102:	8f33      	ldrh	r3, [r6, #56]
 104:	18d3      	adds	r3, r2, r3
 106:	b29b      	uxth	r3, r3
 108:	4293      	cmp	r3, r2
 10a:	f240 80b0 	bls.w	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:799
              pcb->cwnd += pcb->mss;
 10e:	f8a6 3052 	strh.w	r3, [r6, #82]
 112:	e0ac      	b.n	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:807
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl2 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 114:	43cb      	mvns	r3, r1
 116:	42d3      	cmn	r3, r2
 118:	f100 8091 	bmi.w	23e <tcp_receive+0x23e>
 11c:	6db3      	ldr	r3, [r6, #88]
 11e:	1ad3      	subs	r3, r2, r3
 120:	2b00      	cmp	r3, #0
 122:	f300 808c 	bgt.w	23e <tcp_receive+0x23e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:813
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 126:	f896 3022 	ldrb.w	r3, [r6, #34]
 12a:	f013 0f04 	tst.w	r3, #4	; 0x4
 12e:	d007      	beq.n	140 <tcp_receive+0x140>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:814
        pcb->flags &= ~TF_INFR;
 130:	f023 0304 	bic.w	r3, r3, #4	; 0x4
 134:	f886 3022 	strb.w	r3, [r6, #34]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:815
        pcb->cwnd = pcb->ssthresh;
 138:	f8b6 3054 	ldrh.w	r3, [r6, #84]
 13c:	f8a6 3052 	strh.w	r3, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:822

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 140:	f9b6 2044 	ldrsh.w	r2, [r6, #68]
 144:	f8b6 3046 	ldrh.w	r3, [r6, #70]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:819
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 148:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:825

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 14a:	493f      	ldr	r1, [pc, #252]	(248 <tcp_receive+0x248>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:822

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 14c:	eb03 03e2 	add.w	r3, r3, r2, asr #3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:819
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 150:	f886 004a 	strb.w	r0, [r6, #74]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:825

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 154:	6cf2      	ldr	r2, [r6, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:822

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 156:	f8a6 3048 	strh.w	r3, [r6, #72]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:825

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 15a:	68cb      	ldr	r3, [r1, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:830

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 15c:	f886 0050 	strb.w	r0, [r6, #80]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:825

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 160:	1a9b      	subs	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:827

      pcb->snd_buf += pcb->acked;
 162:	f8b6 206e 	ldrh.w	r2, [r6, #110]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:825

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 166:	b29b      	uxth	r3, r3
 168:	f8a6 306c 	strh.w	r3, [r6, #108]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:827

      pcb->snd_buf += pcb->acked;
 16c:	189b      	adds	r3, r3, r2
 16e:	f8a6 306e 	strh.w	r3, [r6, #110]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:831

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
      pcb->lastack = ackno;
 172:	68cb      	ldr	r3, [r1, #12]
 174:	64f3      	str	r3, [r6, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:835

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 176:	7c33      	ldrb	r3, [r6, #16]
 178:	2b03      	cmp	r3, #3
 17a:	d923      	bls.n	1c4 <tcp_receive+0x1c4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:836
        if (pcb->cwnd < pcb->ssthresh) {
 17c:	f8b6 2052 	ldrh.w	r2, [r6, #82]
 180:	f8b6 3054 	ldrh.w	r3, [r6, #84]
 184:	4293      	cmp	r3, r2
 186:	d901      	bls.n	18c <tcp_receive+0x18c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:837
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 188:	8f33      	ldrh	r3, [r6, #56]
 18a:	e003      	b.n	194 <tcp_receive+0x194>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:842
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 18c:	8f33      	ldrh	r3, [r6, #56]
 18e:	435b      	muls	r3, r3
 190:	fb93 f3f2 	sdiv	r3, r3, r2
 194:	18d3      	adds	r3, r2, r3
 196:	b29b      	uxth	r3, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:843
          if (new_cwnd > pcb->cwnd) {
 198:	4293      	cmp	r3, r2
 19a:	d913      	bls.n	1c4 <tcp_receive+0x1c4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:844
            pcb->cwnd = new_cwnd;
 19c:	f8a6 3052 	strh.w	r3, [r6, #82]
 1a0:	e010      	b.n	1c4 <tcp_receive+0x1c4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:866
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 1a2:	6fb4      	ldr	r4, [r6, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:867
        pcb->unacked = pcb->unacked->next;
 1a4:	6823      	ldr	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:870

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 1a6:	6860      	ldr	r0, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:867
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
 1a8:	67b3      	str	r3, [r6, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:870

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 1aa:	f7ff fffe 	bl	0 <pbuf_clen>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:871
        pcb->snd_queuelen -= pbuf_clen(next->p);
 1ae:	6860      	ldr	r0, [r4, #4]
 1b0:	f8b6 5070 	ldrh.w	r5, [r6, #112]
 1b4:	f7ff fffe 	bl	0 <pbuf_clen>
 1b8:	1a2d      	subs	r5, r5, r0
 1ba:	f8a6 5070 	strh.w	r5, [r6, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:872
        tcp_seg_free(next);
 1be:	4620      	mov	r0, r4
 1c0:	f7ff fffe 	bl	0 <tcp_seg_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:858
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 1c4:	6fb3      	ldr	r3, [r6, #120]
 1c6:	2b00      	cmp	r3, #0
 1c8:	d02c      	beq.n	224 <tcp_receive+0x224>
 1ca:	691a      	ldr	r2, [r3, #16]
 1cc:	7953      	ldrb	r3, [r2, #5]
 1ce:	7910      	ldrb	r0, [r2, #4]
 1d0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 1d4:	7993      	ldrb	r3, [r2, #6]
 1d6:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 1da:	79d3      	ldrb	r3, [r2, #7]
 1dc:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 1e0:	f7ff fffe 	bl	0 <ntohl>
 1e4:	6fb3      	ldr	r3, [r6, #120]
 1e6:	4605      	mov	r5, r0
 1e8:	899c      	ldrh	r4, [r3, #12]
 1ea:	691b      	ldr	r3, [r3, #16]
 1ec:	7b1a      	ldrb	r2, [r3, #12]
 1ee:	7b58      	ldrb	r0, [r3, #13]
 1f0:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 1f4:	f7ff fffe 	bl	0 <ntohs>
 1f8:	f010 0f01 	tst.w	r0, #1	; 0x1
 1fc:	d10a      	bne.n	214 <tcp_receive+0x214>
 1fe:	6fb3      	ldr	r3, [r6, #120]
 200:	691b      	ldr	r3, [r3, #16]
 202:	7b1a      	ldrb	r2, [r3, #12]
 204:	7b58      	ldrb	r0, [r3, #13]
 206:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 20a:	f7ff fffe 	bl	0 <ntohs>
 20e:	f010 0002 	ands.w	r0, r0, #2	; 0x2
 212:	d000      	beq.n	216 <tcp_receive+0x216>
 214:	2001      	movs	r0, #1
 216:	4b0c      	ldr	r3, [pc, #48]	(248 <tcp_receive+0x248>)
 218:	1902      	adds	r2, r0, r4
 21a:	68db      	ldr	r3, [r3, #12]
 21c:	1aeb      	subs	r3, r5, r3
 21e:	189b      	adds	r3, r3, r2
 220:	2b00      	cmp	r3, #0
 222:	ddbe      	ble.n	1a2 <tcp_receive+0x1a2>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:883
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 224:	6fb3      	ldr	r3, [r6, #120]
 226:	b91b      	cbnz	r3, 230 <tcp_receive+0x230>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:884
        pcb->rtime = -1;
 228:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 22c:	86f2      	strh	r2, [r6, #54]
 22e:	e002      	b.n	236 <tcp_receive+0x236>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:886
      else
        pcb->rtime = 0;
 230:	f04f 0300 	mov.w	r3, #0	; 0x0
 234:	86f3      	strh	r3, [r6, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:888

      pcb->polltmr = 0;
 236:	2300      	movs	r3, #0
 238:	f886 3034 	strb.w	r3, [r6, #52]
 23c:	e017      	b.n	26e <tcp_receive+0x26e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:891
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 23e:	f04f 0200 	mov.w	r2, #0	; 0x0
 242:	f8a6 206c 	strh.w	r2, [r6, #108]
 246:	e012      	b.n	28 <tcp_receive+0x28>
 248:	00000000 	.word	0x00000000
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:907
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 24c:	6f74      	ldr	r4, [r6, #116]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:908
      pcb->unsent = pcb->unsent->next;
 24e:	6823      	ldr	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:910
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 250:	6860      	ldr	r0, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:908
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
 252:	6773      	str	r3, [r6, #116]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:910
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 254:	f7ff fffe 	bl	0 <pbuf_clen>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:911
      pcb->snd_queuelen -= pbuf_clen(next->p);
 258:	6860      	ldr	r0, [r4, #4]
 25a:	f8b6 5070 	ldrh.w	r5, [r6, #112]
 25e:	f7ff fffe 	bl	0 <pbuf_clen>
 262:	1a2d      	subs	r5, r5, r0
 264:	f8a6 5070 	strh.w	r5, [r6, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:912
      tcp_seg_free(next);
 268:	4620      	mov	r0, r4
 26a:	f7ff fffe 	bl	0 <tcp_seg_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:900
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 26e:	6f72      	ldr	r2, [r6, #116]
 270:	2a00      	cmp	r2, #0
 272:	d032      	beq.n	2da <tcp_receive+0x2da>
 274:	6912      	ldr	r2, [r2, #16]
 276:	4b4b      	ldr	r3, [pc, #300]	(3a4 <tcp_receive+0x3a4>)
 278:	7910      	ldrb	r0, [r2, #4]
 27a:	68df      	ldr	r7, [r3, #12]
 27c:	7953      	ldrb	r3, [r2, #5]
 27e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 282:	7993      	ldrb	r3, [r2, #6]
 284:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 288:	79d3      	ldrb	r3, [r2, #7]
 28a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 28e:	f7ff fffe 	bl	0 <ntohl>
 292:	6f73      	ldr	r3, [r6, #116]
 294:	4605      	mov	r5, r0
 296:	899c      	ldrh	r4, [r3, #12]
 298:	691b      	ldr	r3, [r3, #16]
 29a:	7b1a      	ldrb	r2, [r3, #12]
 29c:	7b58      	ldrb	r0, [r3, #13]
 29e:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 2a2:	f7ff fffe 	bl	0 <ntohs>
 2a6:	f010 0f01 	tst.w	r0, #1	; 0x1
 2aa:	d10a      	bne.n	2c2 <tcp_receive+0x2c2>
 2ac:	6f73      	ldr	r3, [r6, #116]
 2ae:	691b      	ldr	r3, [r3, #16]
 2b0:	7b1a      	ldrb	r2, [r3, #12]
 2b2:	7b58      	ldrb	r0, [r3, #13]
 2b4:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 2b8:	f7ff fffe 	bl	0 <ntohs>
 2bc:	f010 0002 	ands.w	r0, r0, #2	; 0x2
 2c0:	d000      	beq.n	2c4 <tcp_receive+0x2c4>
 2c2:	2001      	movs	r0, #1
 2c4:	1b7b      	subs	r3, r7, r5
 2c6:	1902      	adds	r2, r0, r4
 2c8:	1a9b      	subs	r3, r3, r2
 2ca:	2b00      	cmp	r3, #0
 2cc:	db05      	blt.n	2da <tcp_receive+0x2da>
 2ce:	4b35      	ldr	r3, [pc, #212]	(3a4 <tcp_receive+0x3a4>)
 2d0:	6db2      	ldr	r2, [r6, #88]
 2d2:	68db      	ldr	r3, [r3, #12]
 2d4:	1a9b      	subs	r3, r3, r2
 2d6:	2b00      	cmp	r3, #0
 2d8:	ddb8      	ble.n	24c <tcp_receive+0x24c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:927
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 2da:	6bf0      	ldr	r0, [r6, #60]
 2dc:	b330      	cbz	r0, 32c <tcp_receive+0x32c>
 2de:	4a31      	ldr	r2, [pc, #196]	(3a4 <tcp_receive+0x3a4>)
 2e0:	6c33      	ldr	r3, [r6, #64]
 2e2:	68d2      	ldr	r2, [r2, #12]
 2e4:	1a9b      	subs	r3, r3, r2
 2e6:	2b00      	cmp	r3, #0
 2e8:	da20      	bge.n	32c <tcp_receive+0x32c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:936

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 2ea:	4b2f      	ldr	r3, [pc, #188]	(3a8 <tcp_receive+0x3a8>)
 2ec:	f8b6 1044 	ldrh.w	r1, [r6, #68]
 2f0:	681a      	ldr	r2, [r3, #0]
 2f2:	f341 03cc 	sbfx	r3, r1, #3, #13
 2f6:	1a12      	subs	r2, r2, r0
 2f8:	1ad2      	subs	r2, r2, r3
 2fa:	b292      	uxth	r2, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:941
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
 2fc:	f8b6 3046 	ldrh.w	r3, [r6, #70]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:937
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 300:	1851      	adds	r1, r2, r1
 302:	f8a6 1044 	strh.w	r1, [r6, #68]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:942
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 306:	b212      	sxth	r2, r2
 308:	f343 018d 	sbfx	r1, r3, #2, #14
 30c:	1a5b      	subs	r3, r3, r1
 30e:	2a00      	cmp	r2, #0
 310:	bfb8      	it	lt
 312:	4252      	neglt	r2, r2
 314:	189b      	adds	r3, r3, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:943
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 316:	f9b6 2044 	ldrsh.w	r2, [r6, #68]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:942
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 31a:	b29b      	uxth	r3, r3
 31c:	f8a6 3046 	strh.w	r3, [r6, #70]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:943
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 320:	eb03 03e2 	add.w	r3, r3, r2, asr #3
 324:	f8a6 3048 	strh.w	r3, [r6, #72]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:948

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 328:	2300      	movs	r3, #0
 32a:	63f3      	str	r3, [r6, #60]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:954
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
 32c:	481d      	ldr	r0, [pc, #116]	(3a4 <tcp_receive+0x3a4>)
 32e:	6a72      	ldr	r2, [r6, #36]
 330:	8a04      	ldrh	r4, [r0, #16]
 332:	2c00      	cmp	r4, #0
 334:	f000 80fe 	beq.w	534 <tcp_receive+0x534>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:985
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 338:	6881      	ldr	r1, [r0, #8]
 33a:	43cb      	mvns	r3, r1
 33c:	42d3      	cmn	r3, r2
 33e:	d435      	bmi.n	3ac <tcp_receive+0x3ac>
 340:	1c53      	adds	r3, r2, #1
 342:	1a5b      	subs	r3, r3, r1
 344:	1b1b      	subs	r3, r3, r4
 346:	2b00      	cmp	r3, #0
 348:	dc30      	bgt.n	3ac <tcp_receive+0x3ac>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1007
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
 34a:	6984      	ldr	r4, [r0, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1006

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 34c:	1a51      	subs	r1, r2, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1010
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 34e:	8963      	ldrh	r3, [r4, #10]
 350:	428b      	cmp	r3, r1
 352:	da0c      	bge.n	36e <tcp_receive+0x36e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1012
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 354:	8923      	ldrh	r3, [r4, #8]
 356:	1a5b      	subs	r3, r3, r1
 358:	b29b      	uxth	r3, r3
 35a:	e005      	b.n	368 <tcp_receive+0x368>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1014
        while (p->len < off) {
          off -= p->len;
 35c:	1a89      	subs	r1, r1, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1019
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 35e:	f04f 0200 	mov.w	r2, #0	; 0x0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1018
        while (p->len < off) {
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 362:	8123      	strh	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1019
          p->len = 0;
 364:	8162      	strh	r2, [r4, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1020
          p = p->next;
 366:	6824      	ldr	r4, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1013
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 368:	8962      	ldrh	r2, [r4, #10]
 36a:	428a      	cmp	r2, r1
 36c:	dbf6      	blt.n	35c <tcp_receive+0x35c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1027
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 36e:	4249      	negs	r1, r1
 370:	b209      	sxth	r1, r1
 372:	4620      	mov	r0, r4
 374:	f7ff fffe 	bl	0 <pbuf_header>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1034
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
 378:	490a      	ldr	r1, [pc, #40]	(3a4 <tcp_receive+0x3a4>)
 37a:	6863      	ldr	r3, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1035
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 37c:	688a      	ldr	r2, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1034
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
 37e:	61cb      	str	r3, [r1, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1035
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 380:	8c0b      	ldrh	r3, [r1, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1036
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 382:	6a48      	ldr	r0, [r1, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1035
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 384:	18d2      	adds	r2, r2, r3
 386:	6a73      	ldr	r3, [r6, #36]
 388:	1ad2      	subs	r2, r2, r3
 38a:	840a      	strh	r2, [r1, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1036
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 38c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 390:	608b      	str	r3, [r1, #8]
 392:	7103      	strb	r3, [r0, #4]
 394:	7142      	strb	r2, [r0, #5]
 396:	f3c3 4207 	ubfx	r2, r3, #16, #8
 39a:	0e1b      	lsrs	r3, r3, #24
 39c:	7182      	strb	r2, [r0, #6]
 39e:	71c3      	strb	r3, [r0, #7]
 3a0:	e010      	b.n	3c4 <tcp_receive+0x3c4>
 3a2:	46c0      	nop			(mov r8, r8)
	...
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1039
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 3ac:	1a8b      	subs	r3, r1, r2
 3ae:	2b00      	cmp	r3, #0
 3b0:	da08      	bge.n	3c4 <tcp_receive+0x3c4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1044
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 3b2:	f896 3022 	ldrb.w	r3, [r6, #34]
 3b6:	4630      	mov	r0, r6
 3b8:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 3bc:	f886 3022 	strb.w	r3, [r6, #34]
 3c0:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1051
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 3c4:	4c67      	ldr	r4, [pc, #412]	(564 <tcp_receive+0x564>)
 3c6:	6a71      	ldr	r1, [r6, #36]
 3c8:	68a0      	ldr	r0, [r4, #8]
 3ca:	1a43      	subs	r3, r0, r1
 3cc:	2b00      	cmp	r3, #0
 3ce:	f2c0 80bd 	blt.w	54c <tcp_receive+0x54c>
 3d2:	1c43      	adds	r3, r0, #1
 3d4:	8d32      	ldrh	r2, [r6, #40]
 3d6:	1a5b      	subs	r3, r3, r1
 3d8:	1a9b      	subs	r3, r3, r2
 3da:	2b00      	cmp	r3, #0
 3dc:	f300 80b6 	bgt.w	54c <tcp_receive+0x54c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1053
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 3e0:	4281      	cmp	r1, r0
 3e2:	f040 80b3 	bne.w	54c <tcp_receive+0x54c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1058
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 3e6:	6a63      	ldr	r3, [r4, #36]
 3e8:	8c25      	ldrh	r5, [r4, #32]
 3ea:	7b1a      	ldrb	r2, [r3, #12]
 3ec:	7b58      	ldrb	r0, [r3, #13]
 3ee:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 3f2:	f7ff fffe 	bl	0 <ntohs>
 3f6:	f010 0f01 	tst.w	r0, #1	; 0x1
 3fa:	d109      	bne.n	410 <tcp_receive+0x410>
 3fc:	6a63      	ldr	r3, [r4, #36]
 3fe:	7b1a      	ldrb	r2, [r3, #12]
 400:	7b58      	ldrb	r0, [r3, #13]
 402:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 406:	f7ff fffe 	bl	0 <ntohs>
 40a:	f010 0002 	ands.w	r0, r0, #2	; 0x2
 40e:	d000      	beq.n	412 <tcp_receive+0x412>
 410:	2001      	movs	r0, #1
 412:	182b      	adds	r3, r5, r0
 414:	4d53      	ldr	r5, [pc, #332]	(564 <tcp_receive+0x564>)
 416:	b29b      	uxth	r3, r3
 418:	822b      	strh	r3, [r5, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1060

        if (tcplen > pcb->rcv_wnd) {
 41a:	8d32      	ldrh	r2, [r6, #40]
 41c:	429a      	cmp	r2, r3
 41e:	d252      	bcs.n	4c6 <tcp_receive+0x4c6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1065
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U32_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 420:	6a6b      	ldr	r3, [r5, #36]
 422:	7b1a      	ldrb	r2, [r3, #12]
 424:	7b58      	ldrb	r0, [r3, #13]
 426:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 42a:	f7ff fffe 	bl	0 <ntohs>
 42e:	f010 0f01 	tst.w	r0, #1	; 0x1
 432:	d01a      	beq.n	46a <tcp_receive+0x46a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1068
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 434:	6a6b      	ldr	r3, [r5, #36]
 436:	7b1a      	ldrb	r2, [r3, #12]
 438:	7b58      	ldrb	r0, [r3, #13]
 43a:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 43e:	f7ff fffe 	bl	0 <ntohs>
 442:	6a6d      	ldr	r5, [r5, #36]
 444:	4604      	mov	r4, r0
 446:	7b2b      	ldrb	r3, [r5, #12]
 448:	7b68      	ldrb	r0, [r5, #13]
 44a:	f024 043f 	bic.w	r4, r4, #63	; 0x3f
 44e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 452:	f7ff fffe 	bl	0 <ntohs>
 456:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 45a:	4320      	orrs	r0, r4
 45c:	b280      	uxth	r0, r0
 45e:	f7ff fffe 	bl	0 <htons>
 462:	7328      	strb	r0, [r5, #12]
 464:	f3c0 200f 	ubfx	r0, r0, #8, #16
 468:	7368      	strb	r0, [r5, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1071
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 46a:	8d33      	ldrh	r3, [r6, #40]
 46c:	4c3d      	ldr	r4, [pc, #244]	(564 <tcp_receive+0x564>)
 46e:	8423      	strh	r3, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1072
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 470:	6a63      	ldr	r3, [r4, #36]
 472:	7b1a      	ldrb	r2, [r3, #12]
 474:	7b58      	ldrb	r0, [r3, #13]
 476:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 47a:	f7ff fffe 	bl	0 <ntohs>
 47e:	f010 0f02 	tst.w	r0, #2	; 0x2
 482:	d002      	beq.n	48a <tcp_receive+0x48a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1073
            inseg.len -= 1;
 484:	8c23      	ldrh	r3, [r4, #32]
 486:	3b01      	subs	r3, #1
 488:	8423      	strh	r3, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1075
          }
          pbuf_realloc(inseg.p, inseg.len);
 48a:	4c36      	ldr	r4, [pc, #216]	(564 <tcp_receive+0x564>)
 48c:	69a0      	ldr	r0, [r4, #24]
 48e:	8c21      	ldrh	r1, [r4, #32]
 490:	f7ff fffe 	bl	0 <pbuf_realloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1076
          tcplen = TCP_TCPLEN(&inseg);
 494:	6a63      	ldr	r3, [r4, #36]
 496:	8c25      	ldrh	r5, [r4, #32]
 498:	7b1a      	ldrb	r2, [r3, #12]
 49a:	7b58      	ldrb	r0, [r3, #13]
 49c:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 4a0:	f7ff fffe 	bl	0 <ntohs>
 4a4:	f010 0f01 	tst.w	r0, #1	; 0x1
 4a8:	d109      	bne.n	4be <tcp_receive+0x4be>
 4aa:	6a63      	ldr	r3, [r4, #36]
 4ac:	7b1a      	ldrb	r2, [r3, #12]
 4ae:	7b58      	ldrb	r0, [r3, #13]
 4b0:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 4b4:	f7ff fffe 	bl	0 <ntohs>
 4b8:	f010 0002 	ands.w	r0, r0, #2	; 0x2
 4bc:	d000      	beq.n	4c0 <tcp_receive+0x4c0>
 4be:	2001      	movs	r0, #1
 4c0:	4b28      	ldr	r3, [pc, #160]	(564 <tcp_receive+0x564>)
 4c2:	182a      	adds	r2, r5, r0
 4c4:	821a      	strh	r2, [r3, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1120
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 4c6:	4c27      	ldr	r4, [pc, #156]	(564 <tcp_receive+0x564>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1126

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;

        tcp_update_rcv_ann_wnd(pcb);
 4c8:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1120
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 4ca:	8a22      	ldrh	r2, [r4, #16]
 4cc:	68a3      	ldr	r3, [r4, #8]
 4ce:	18d3      	adds	r3, r2, r3
 4d0:	6273      	str	r3, [r6, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1124

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 4d2:	8d33      	ldrh	r3, [r6, #40]
 4d4:	1a9b      	subs	r3, r3, r2
 4d6:	8533      	strh	r3, [r6, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1126

        tcp_update_rcv_ann_wnd(pcb);
 4d8:	f7ff fffe 	bl	0 <tcp_update_rcv_ann_wnd>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1137
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 4dc:	69a2      	ldr	r2, [r4, #24]
 4de:	8913      	ldrh	r3, [r2, #8]
 4e0:	b113      	cbz	r3, 4e8 <tcp_receive+0x4e8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1142
          recv_data = inseg.p;
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 4e2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1138

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
          recv_data = inseg.p;
 4e4:	62a2      	str	r2, [r4, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1142
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 4e6:	61a3      	str	r3, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1144
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 4e8:	4c1e      	ldr	r4, [pc, #120]	(564 <tcp_receive+0x564>)
 4ea:	6a63      	ldr	r3, [r4, #36]
 4ec:	7b1a      	ldrb	r2, [r3, #12]
 4ee:	7b58      	ldrb	r0, [r3, #13]
 4f0:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 4f4:	f7ff fffe 	bl	0 <ntohs>
 4f8:	f010 0f01 	tst.w	r0, #1	; 0x1
 4fc:	d005      	beq.n	50a <tcp_receive+0x50a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1146
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 4fe:	f894 302c 	ldrb.w	r3, [r4, #44]
 502:	f043 0320 	orr.w	r3, r3, #32	; 0x20
 506:	f884 302c 	strb.w	r3, [r4, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1191
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 50a:	f896 3022 	ldrb.w	r3, [r6, #34]
 50e:	f013 0f01 	tst.w	r3, #1	; 0x1
 512:	d009      	beq.n	528 <tcp_receive+0x528>
 514:	f023 0301 	bic.w	r3, r3, #1	; 0x1
 518:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 51c:	f886 3022 	strb.w	r3, [r6, #34]
 520:	4630      	mov	r0, r6
 522:	f7ff fffe 	bl	0 <tcp_output>
 526:	e003      	b.n	530 <tcp_receive+0x530>
 528:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 52c:	f886 3022 	strb.w	r3, [r6, #34]
 530:	2001      	movs	r0, #1
 532:	e015      	b.n	560 <tcp_receive+0x560>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1326
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 534:	6880      	ldr	r0, [r0, #8]
 536:	1a83      	subs	r3, r0, r2
 538:	2b00      	cmp	r3, #0
 53a:	db07      	blt.n	54c <tcp_receive+0x54c>
 53c:	1c43      	adds	r3, r0, #1
 53e:	1a9b      	subs	r3, r3, r2
 540:	8d32      	ldrh	r2, [r6, #40]
 542:	1a9b      	subs	r3, r3, r2
 544:	2b00      	cmp	r3, #0
 546:	dc01      	bgt.n	54c <tcp_receive+0x54c>
 548:	4620      	mov	r0, r4
 54a:	e009      	b.n	560 <tcp_receive+0x560>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1327
      tcp_ack_now(pcb);
 54c:	f896 3022 	ldrb.w	r3, [r6, #34]
 550:	4630      	mov	r0, r6
 552:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 556:	f886 3022 	strb.w	r3, [r6, #34]
 55a:	f7ff fffe 	bl	0 <tcp_output>
 55e:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:1331
    }
  }
  return accepted_inseq;
}
 560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 564:	00000000 	.word	0x00000000
Disassembly of section .text.tcp_input:

00000000 <tcp_input>:
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:94
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:105
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
   4:	6844      	ldr	r4, [r0, #4]
   6:	f8df 83fc 	ldr.w	r8, [pc, #1020]	; 404 <tcp_input+0x404>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:94
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
   a:	4681      	mov	r9, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:105
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
   c:	f8c8 4030 	str.w	r4, [r8, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:106
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  10:	7823      	ldrb	r3, [r4, #0]
  12:	7860      	ldrb	r0, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:94
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  14:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:106

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  16:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  1a:	f7ff fffe 	bl	0 <ntohs>
  1e:	f3c0 2003 	ubfx	r0, r0, #8, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:113
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  22:	f8d8 3030 	ldr.w	r3, [r8, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:106

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  26:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  2a:	f8c8 4000 	str.w	r4, [r8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:113
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  2e:	781a      	ldrb	r2, [r3, #0]
  30:	7858      	ldrb	r0, [r3, #1]
  32:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  36:	f7ff fffe 	bl	0 <ntohs>
  3a:	f3c0 2103 	ubfx	r1, r0, #8, #4
  3e:	0089      	lsls	r1, r1, #2
  40:	4648      	mov	r0, r9
  42:	4249      	negs	r1, r1
  44:	f7ff fffe 	bl	0 <pbuf_header>
  48:	2800      	cmp	r0, #0
  4a:	f040 8466 	bne.w	91a <tcp_input+0x91a>
  4e:	f8b9 3008 	ldrh.w	r3, [r9, #8]
  52:	2b13      	cmp	r3, #19
  54:	f240 8461 	bls.w	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:124
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  58:	f8d8 0030 	ldr.w	r0, [r8, #48]
  5c:	4629      	mov	r1, r5
  5e:	3010      	adds	r0, #16
  60:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  64:	2800      	cmp	r0, #0
  66:	f040 8458 	bne.w	91a <tcp_input+0x91a>
  6a:	f8d8 2030 	ldr.w	r2, [r8, #48]
  6e:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
  72:	7c53      	ldrb	r3, [r2, #17]
  74:	7c14      	ldrb	r4, [r2, #16]
  76:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  7a:	7c93      	ldrb	r3, [r2, #18]
  7c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
  80:	7cd3      	ldrb	r3, [r2, #19]
  82:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  86:	f7ff fffe 	bl	0 <ntohl>
  8a:	4605      	mov	r5, r0
  8c:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  90:	f7ff fffe 	bl	0 <ntohl>
  94:	4025      	ands	r5, r4
  96:	4285      	cmp	r5, r0
  98:	f000 843f 	beq.w	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:154
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  9c:	f8d8 3000 	ldr.w	r3, [r8]
  a0:	7b1a      	ldrb	r2, [r3, #12]
  a2:	7b58      	ldrb	r0, [r3, #13]
  a4:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  a8:	f7ff fffe 	bl	0 <ntohs>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:155
  if(pbuf_header(p, -(hdrlen * 4))){
  ac:	f06f 0103 	mvn.w	r1, #3	; 0x3
  b0:	f3c0 3307 	ubfx	r3, r0, #12, #8
  b4:	4359      	muls	r1, r3
  b6:	4648      	mov	r0, r9
  b8:	f7ff fffe 	bl	0 <pbuf_header>
  bc:	4605      	mov	r5, r0
  be:	2800      	cmp	r0, #0
  c0:	f040 842b 	bne.w	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:166
    pbuf_free(p);
    return;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  c4:	f8d8 4000 	ldr.w	r4, [r8]
  c8:	7823      	ldrb	r3, [r4, #0]
  ca:	7860      	ldrb	r0, [r4, #1]
  cc:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  d0:	f7ff fffe 	bl	0 <ntohs>
  d4:	7020      	strb	r0, [r4, #0]
  d6:	f3c0 200f 	ubfx	r0, r0, #8, #16
  da:	7060      	strb	r0, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:167
  tcphdr->dest = ntohs(tcphdr->dest);
  dc:	f8d8 4000 	ldr.w	r4, [r8]
  e0:	78a3      	ldrb	r3, [r4, #2]
  e2:	78e0      	ldrb	r0, [r4, #3]
  e4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  e8:	f7ff fffe 	bl	0 <ntohs>
  ec:	70a0      	strb	r0, [r4, #2]
  ee:	f3c0 200f 	ubfx	r0, r0, #8, #16
  f2:	70e0      	strb	r0, [r4, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:168
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  f4:	f8d8 4000 	ldr.w	r4, [r8]
  f8:	7963      	ldrb	r3, [r4, #5]
  fa:	7920      	ldrb	r0, [r4, #4]
  fc:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 100:	79a3      	ldrb	r3, [r4, #6]
 102:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 106:	79e3      	ldrb	r3, [r4, #7]
 108:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 10c:	f7ff fffe 	bl	0 <ntohl>
 110:	f3c0 2307 	ubfx	r3, r0, #8, #8
 114:	7163      	strb	r3, [r4, #5]
 116:	f3c0 4307 	ubfx	r3, r0, #16, #8
 11a:	71a3      	strb	r3, [r4, #6]
 11c:	0e03      	lsrs	r3, r0, #24
 11e:	7120      	strb	r0, [r4, #4]
 120:	71e3      	strb	r3, [r4, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:169
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 122:	f8d8 4000 	ldr.w	r4, [r8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:168
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 126:	f8c8 0008 	str.w	r0, [r8, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:169
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 12a:	7a63      	ldrb	r3, [r4, #9]
 12c:	7a20      	ldrb	r0, [r4, #8]
 12e:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 132:	7aa3      	ldrb	r3, [r4, #10]
 134:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 138:	7ae3      	ldrb	r3, [r4, #11]
 13a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 13e:	f7ff fffe 	bl	0 <ntohl>
 142:	f3c0 2307 	ubfx	r3, r0, #8, #8
 146:	7263      	strb	r3, [r4, #9]
 148:	f3c0 4307 	ubfx	r3, r0, #16, #8
 14c:	72a3      	strb	r3, [r4, #10]
 14e:	0e03      	lsrs	r3, r0, #24
 150:	7220      	strb	r0, [r4, #8]
 152:	72e3      	strb	r3, [r4, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:170
  tcphdr->wnd = ntohs(tcphdr->wnd);
 154:	f8d8 4000 	ldr.w	r4, [r8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:169

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 158:	f8c8 000c 	str.w	r0, [r8, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:170
  tcphdr->wnd = ntohs(tcphdr->wnd);
 15c:	7ba3      	ldrb	r3, [r4, #14]
 15e:	7be0      	ldrb	r0, [r4, #15]
 160:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 164:	f7ff fffe 	bl	0 <ntohs>
 168:	73a0      	strb	r0, [r4, #14]
 16a:	f3c0 200f 	ubfx	r0, r0, #8, #16
 16e:	73e0      	strb	r0, [r4, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:172

  flags = TCPH_FLAGS(tcphdr);
 170:	f8d8 3000 	ldr.w	r3, [r8]
 174:	7b1a      	ldrb	r2, [r3, #12]
 176:	7b58      	ldrb	r0, [r3, #13]
 178:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 17c:	f7ff fffe 	bl	0 <ntohs>
 180:	b2c0      	uxtb	r0, r0
 182:	f000 033f 	and.w	r3, r0, #63	; 0x3f
 186:	f888 3004 	strb.w	r3, [r8, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:173
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 18a:	f8b9 3008 	ldrh.w	r3, [r9, #8]
 18e:	f010 0003 	ands.w	r0, r0, #3	; 0x3
 192:	bf18      	it	ne
 194:	2001      	movne	r0, #1
 196:	18c0      	adds	r0, r0, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:180
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 198:	4b99      	ldr	r3, [pc, #612]	(400 <tcp_input+0x400>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:173
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 19a:	fa1f fe80 	uxth.w	lr, r0
 19e:	f8a8 e010 	strh.w	lr, [r8, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:180
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 1a2:	681e      	ldr	r6, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:184
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 1a4:	f8d8 7000 	ldr.w	r7, [r8]
 1a8:	f8d8 4030 	ldr.w	r4, [r8, #48]
 1ac:	4628      	mov	r0, r5
 1ae:	e033      	b.n	218 <tcp_input+0x218>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:180
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 1b0:	783b      	ldrb	r3, [r7, #0]
 1b2:	787a      	ldrb	r2, [r7, #1]
 1b4:	8c31      	ldrh	r1, [r6, #32]
 1b6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 1ba:	4299      	cmp	r1, r3
 1bc:	d12a      	bne.n	214 <tcp_input+0x214>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:184
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 1be:	78bb      	ldrb	r3, [r7, #2]
 1c0:	78fa      	ldrb	r2, [r7, #3]
 1c2:	8b31      	ldrh	r1, [r6, #24]
 1c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 1c8:	4299      	cmp	r1, r3
 1ca:	d123      	bne.n	214 <tcp_input+0x214>
 1cc:	7b62      	ldrb	r2, [r4, #13]
 1ce:	7b23      	ldrb	r3, [r4, #12]
 1d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 1d4:	7ba2      	ldrb	r2, [r4, #14]
 1d6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 1da:	7be2      	ldrb	r2, [r4, #15]
 1dc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 1e0:	6872      	ldr	r2, [r6, #4]
 1e2:	429a      	cmp	r2, r3
 1e4:	d116      	bne.n	214 <tcp_input+0x214>
 1e6:	7c62      	ldrb	r2, [r4, #17]
 1e8:	7c23      	ldrb	r3, [r4, #16]
 1ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 1ee:	7ca2      	ldrb	r2, [r4, #18]
 1f0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 1f4:	7ce2      	ldrb	r2, [r4, #19]
 1f6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 1fa:	6832      	ldr	r2, [r6, #0]
 1fc:	429a      	cmp	r2, r3
 1fe:	d109      	bne.n	214 <tcp_input+0x214>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:193

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 200:	2800      	cmp	r0, #0
 202:	f000 8103 	beq.w	40c <tcp_input+0x40c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:194
        prev->next = pcb->next;
 206:	68f3      	ldr	r3, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:195
        pcb->next = tcp_active_pcbs;
 208:	4a7d      	ldr	r2, [pc, #500]	(400 <tcp_input+0x400>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:194
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
 20a:	60c3      	str	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:195
        pcb->next = tcp_active_pcbs;
 20c:	6813      	ldr	r3, [r2, #0]
 20e:	60f3      	str	r3, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:196
        tcp_active_pcbs = pcb;
 210:	6016      	str	r6, [r2, #0]
 212:	e0fb      	b.n	40c <tcp_input+0x40c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:180
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 214:	4630      	mov	r0, r6
 216:	68f6      	ldr	r6, [r6, #12]
 218:	2e00      	cmp	r6, #0
 21a:	d1c9      	bne.n	1b0 <tcp_input+0x1b0>
 21c:	e392      	b.n	944 <tcp_input+0x944>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:209
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 21e:	783b      	ldrb	r3, [r7, #0]
 220:	787a      	ldrb	r2, [r7, #1]
 222:	8c29      	ldrh	r1, [r5, #32]
 224:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 228:	4299      	cmp	r1, r3
 22a:	d137      	bne.n	29c <tcp_input+0x29c>
 22c:	78bb      	ldrb	r3, [r7, #2]
 22e:	78fa      	ldrb	r2, [r7, #3]
 230:	8b29      	ldrh	r1, [r5, #24]
 232:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 236:	4299      	cmp	r1, r3
 238:	d130      	bne.n	29c <tcp_input+0x29c>
 23a:	7b62      	ldrb	r2, [r4, #13]
 23c:	7b23      	ldrb	r3, [r4, #12]
 23e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 242:	7ba2      	ldrb	r2, [r4, #14]
 244:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 248:	7be2      	ldrb	r2, [r4, #15]
 24a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 24e:	686a      	ldr	r2, [r5, #4]
 250:	429a      	cmp	r2, r3
 252:	d123      	bne.n	29c <tcp_input+0x29c>
 254:	7c62      	ldrb	r2, [r4, #17]
 256:	7c23      	ldrb	r3, [r4, #16]
 258:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 25c:	7ca2      	ldrb	r2, [r4, #18]
 25e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 262:	7ce2      	ldrb	r2, [r4, #19]
 264:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 268:	682a      	ldr	r2, [r5, #0]
 26a:	429a      	cmp	r2, r3
 26c:	d116      	bne.n	29c <tcp_input+0x29c>
tcp_timewait_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:484
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
 26e:	4b65      	ldr	r3, [pc, #404]	(404 <tcp_input+0x404>)
 270:	689b      	ldr	r3, [r3, #8]
 272:	eb0e 0003 	add.w	r0, lr, r3
 276:	6a6b      	ldr	r3, [r5, #36]
 278:	1ac3      	subs	r3, r0, r3
 27a:	2b00      	cmp	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:487
    pcb->rcv_nxt = seqno + tcplen;
  }
  if (tcplen > 0) {
 27c:	4b61      	ldr	r3, [pc, #388]	(404 <tcp_input+0x404>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:485
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
    pcb->rcv_nxt = seqno + tcplen;
 27e:	bfc8      	it	gt
 280:	6268      	strgt	r0, [r5, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:487
  }
  if (tcplen > 0) {
 282:	8a1b      	ldrh	r3, [r3, #16]
 284:	b143      	cbz	r3, 298 <tcp_input+0x298>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:488
    tcp_ack_now(pcb);
 286:	f895 3022 	ldrb.w	r3, [r5, #34]
 28a:	4628      	mov	r0, r5
 28c:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 290:	f885 3022 	strb.w	r3, [r5, #34]
 294:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:490
  }
  return tcp_output(pcb);
 298:	4628      	mov	r0, r5
 29a:	e0a8      	b.n	3ee <tcp_input+0x3ee>
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:207
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 29c:	68ed      	ldr	r5, [r5, #12]
 29e:	2d00      	cmp	r5, #0
 2a0:	d1bd      	bne.n	21e <tcp_input+0x21e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:226
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2a2:	4b59      	ldr	r3, [pc, #356]	(408 <tcp_input+0x408>)
 2a4:	4628      	mov	r0, r5
 2a6:	681e      	ldr	r6, [r3, #0]
 2a8:	e0a6      	b.n	3f8 <tcp_input+0x3f8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:227
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
 2aa:	6831      	ldr	r1, [r6, #0]
 2ac:	b161      	cbz	r1, 2c8 <tcp_input+0x2c8>
 2ae:	7c62      	ldrb	r2, [r4, #17]
 2b0:	7c23      	ldrb	r3, [r4, #16]
 2b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 2b6:	7ca2      	ldrb	r2, [r4, #18]
 2b8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 2bc:	7ce2      	ldrb	r2, [r4, #19]
 2be:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 2c2:	4299      	cmp	r1, r3
 2c4:	f040 8096 	bne.w	3f4 <tcp_input+0x3f4>
 2c8:	78bb      	ldrb	r3, [r7, #2]
 2ca:	78fa      	ldrb	r2, [r7, #3]
 2cc:	8b31      	ldrh	r1, [r6, #24]
 2ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 2d2:	4299      	cmp	r1, r3
 2d4:	f040 808e 	bne.w	3f4 <tcp_input+0x3f4>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:233
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
 2d8:	b128      	cbz	r0, 2e6 <tcp_input+0x2e6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:234
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 2da:	68f3      	ldr	r3, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:236
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
 2dc:	4a4a      	ldr	r2, [pc, #296]	(408 <tcp_input+0x408>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:234
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 2de:	60c3      	str	r3, [r0, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:236
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
 2e0:	6813      	ldr	r3, [r2, #0]
 2e2:	60f3      	str	r3, [r6, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:238
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
 2e4:	6016      	str	r6, [r2, #0]
tcp_listen_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:400
  struct tcp_pcb *npcb;
  err_t rc;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 2e6:	4f47      	ldr	r7, [pc, #284]	(404 <tcp_input+0x404>)
 2e8:	793b      	ldrb	r3, [r7, #4]
 2ea:	f013 0f10 	tst.w	r3, #16	; 0x10
 2ee:	d010      	beq.n	312 <tcp_input+0x312>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:404
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 2f0:	683d      	ldr	r5, [r7, #0]
 2f2:	68f8      	ldr	r0, [r7, #12]
 2f4:	78ec      	ldrb	r4, [r5, #3]
 2f6:	78aa      	ldrb	r2, [r5, #2]
 2f8:	6b3b      	ldr	r3, [r7, #48]
 2fa:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 2fe:	8a3e      	ldrh	r6, [r7, #16]
 300:	68b9      	ldr	r1, [r7, #8]
 302:	9200      	str	r2, [sp, #0]
 304:	782a      	ldrb	r2, [r5, #0]
 306:	786c      	ldrb	r4, [r5, #1]
 308:	3001      	adds	r0, #1
 30a:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 30e:	9201      	str	r2, [sp, #4]
 310:	e2fd      	b.n	90e <tcp_input+0x90e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:407
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 312:	f013 0f02 	tst.w	r3, #2	; 0x2
 316:	f000 8300 	beq.w	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:415
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 31a:	7c70      	ldrb	r0, [r6, #17]
 31c:	f7ff fffe 	bl	0 <tcp_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:419
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 320:	4604      	mov	r4, r0
 322:	2800      	cmp	r0, #0
 324:	f000 82f9 	beq.w	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:428
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
 328:	6b3d      	ldr	r5, [r7, #48]
 32a:	f115 0310 	adds.w	r3, r5, #16	; 0x10
 32e:	d101      	bne.n	334 <tcp_input+0x334>
 330:	461d      	mov	r5, r3
 332:	e009      	b.n	348 <tcp_input+0x348>
 334:	7c6a      	ldrb	r2, [r5, #17]
 336:	7c2b      	ldrb	r3, [r5, #16]
 338:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 33c:	7caa      	ldrb	r2, [r5, #18]
 33e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 342:	7cea      	ldrb	r2, [r5, #19]
 344:	ea43 6502 	orr.w	r5, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:430
    npcb->local_port = pcb->local_port;
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 348:	4b2e      	ldr	r3, [pc, #184]	(404 <tcp_input+0x404>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:429
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    npcb->local_port = pcb->local_port;
 34a:	8b32      	ldrh	r2, [r6, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:430
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 34c:	6b19      	ldr	r1, [r3, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:428
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
 34e:	6025      	str	r5, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:430
    npcb->local_port = pcb->local_port;
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 350:	f111 030c 	adds.w	r3, r1, #12	; 0xc
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:429
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    npcb->local_port = pcb->local_port;
 354:	8322      	strh	r2, [r4, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:430
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 356:	d009      	beq.n	36c <tcp_input+0x36c>
 358:	7b4a      	ldrb	r2, [r1, #13]
 35a:	7b0b      	ldrb	r3, [r1, #12]
 35c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 360:	7b8a      	ldrb	r2, [r1, #14]
 362:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 366:	7bca      	ldrb	r2, [r1, #15]
 368:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:431
    npcb->remote_port = tcphdr->src;
 36c:	4925      	ldr	r1, [pc, #148]	(404 <tcp_input+0x404>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:430
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    npcb->local_port = pcb->local_port;
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 36e:	6063      	str	r3, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:431
    npcb->remote_port = tcphdr->src;
 370:	6808      	ldr	r0, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:433
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 372:	6889      	ldr	r1, [r1, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:431
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    npcb->local_port = pcb->local_port;
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
    npcb->remote_port = tcphdr->src;
 374:	7842      	ldrb	r2, [r0, #1]
 376:	7803      	ldrb	r3, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:457
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
 378:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:431
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
    npcb->local_port = pcb->local_port;
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
    npcb->remote_port = tcphdr->src;
 37a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 37e:	8423      	strh	r3, [r4, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:432
    npcb->state = SYN_RCVD;
 380:	2303      	movs	r3, #3
 382:	7423      	strb	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:433
    npcb->rcv_nxt = seqno + 1;
 384:	1c4b      	adds	r3, r1, #1
 386:	6263      	str	r3, [r4, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:434
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 388:	62e3      	str	r3, [r4, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:435
    npcb->snd_wnd = tcphdr->wnd;
 38a:	7bc2      	ldrb	r2, [r0, #15]
 38c:	7b83      	ldrb	r3, [r0, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:437
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 38e:	3901      	subs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:435
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 390:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 394:	f8a4 305c 	strh.w	r3, [r4, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:436
    npcb->ssthresh = npcb->snd_wnd;
 398:	f8a4 3054 	strh.w	r3, [r4, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:438
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
 39c:	6973      	ldr	r3, [r6, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:446
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
 39e:	4a18      	ldr	r2, [pc, #96]	(400 <tcp_input+0x400>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:438
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
 3a0:	6163      	str	r3, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:440
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 3a2:	69f3      	ldr	r3, [r6, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:437
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 3a4:	6621      	str	r1, [r4, #96]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:440
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 3a6:	61e3      	str	r3, [r4, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:443
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
 3a8:	8933      	ldrh	r3, [r6, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:449
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 3aa:	4620      	mov	r0, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:443
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
 3ac:	f023 0366 	bic.w	r3, r3, #102	; 0x66
 3b0:	05db      	lsls	r3, r3, #23
 3b2:	0ddb      	lsrs	r3, r3, #23
 3b4:	8123      	strh	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:446
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
 3b6:	6813      	ldr	r3, [r2, #0]
 3b8:	60e3      	str	r3, [r4, #12]
 3ba:	6014      	str	r4, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:449

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 3bc:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:451
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 3c0:	1d21      	adds	r1, r4, #4
 3c2:	8f20      	ldrh	r0, [r4, #56]
 3c4:	f7ff fffe 	bl	0 <tcp_eff_send_mss>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:457
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
 3c8:	2301      	movs	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:451
    TCP_REG(&tcp_active_pcbs, npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 3ca:	8720      	strh	r0, [r4, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:457
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
 3cc:	4629      	mov	r1, r5
 3ce:	9301      	str	r3, [sp, #4]
 3d0:	4620      	mov	r0, r4
 3d2:	3311      	adds	r3, #17
 3d4:	462a      	mov	r2, r5
 3d6:	9500      	str	r5, [sp, #0]
 3d8:	f7ff fffe 	bl	0 <tcp_enqueue>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:463
#if LWIP_TCP_TIMESTAMPS
      /* and maybe include the TIMESTAMP option */
     | (npcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0)
#endif
      );
    if (rc != ERR_OK) {
 3dc:	f010 0fff 	tst.w	r0, #255	; 0xff
 3e0:	d004      	beq.n	3ec <tcp_input+0x3ec>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:464
      tcp_abandon(npcb, 0);
 3e2:	4620      	mov	r0, r4
 3e4:	4629      	mov	r1, r5
 3e6:	f7ff fffe 	bl	0 <tcp_abandon>
 3ea:	e296      	b.n	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:467
      return rc;
    }
    return tcp_output(npcb);
 3ec:	4620      	mov	r0, r4
 3ee:	f7ff fffe 	bl	0 <tcp_output>
 3f2:	e292      	b.n	91a <tcp_input+0x91a>
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:246
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
 3f4:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:226
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 3f6:	68f6      	ldr	r6, [r6, #12]
 3f8:	2e00      	cmp	r6, #0
 3fa:	f47f af56 	bne.w	2aa <tcp_input+0x2aa>
 3fe:	e26d      	b.n	4de <tcp_active_pcbs+0x4de>
	...
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:266
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 40c:	4b9c      	ldr	r3, [pc, #624]	(680 <tcp_input+0x680>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:267
    inseg.len = p->tot_len;
 40e:	f8b9 2008 	ldrh.w	r2, [r9, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:266
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 412:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:267
    inseg.len = p->tot_len;
 414:	841a      	strh	r2, [r3, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:268
    inseg.dataptr = p->payload;
 416:	f8d9 2004 	ldr.w	r2, [r9, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:269
    inseg.p = p;
 41a:	f8c3 9018 	str.w	r9, [r3, #24]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:268
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
    inseg.dataptr = p->payload;
 41e:	61da      	str	r2, [r3, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:270
    inseg.p = p;
    inseg.tcphdr = tcphdr;
 420:	681a      	ldr	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:272

    recv_data = NULL;
 422:	629d      	str	r5, [r3, #40]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:273
    recv_flags = 0;
 424:	f883 502c 	strb.w	r5, [r3, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:270
    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
    inseg.dataptr = p->payload;
    inseg.p = p;
    inseg.tcphdr = tcphdr;
 428:	625a      	str	r2, [r3, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:276

    recv_data = NULL;
    recv_flags = 0;

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 42a:	6ff2      	ldr	r2, [r6, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:266
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 42c:	615d      	str	r5, [r3, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:276

    recv_data = NULL;
    recv_flags = 0;

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 42e:	b17a      	cbz	r2, 450 <tcp_input+0x450>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:279
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 430:	f8d6 4084 	ldr.w	r4, [r6, #132]
 434:	b13c      	cbz	r4, 446 <tcp_input+0x446>
 436:	6970      	ldr	r0, [r6, #20]
 438:	4631      	mov	r1, r6
 43a:	462b      	mov	r3, r5
 43c:	47a0      	blx	r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:280
      if (err == ERR_OK) {
 43e:	f010 0fff 	tst.w	r0, #255	; 0xff
 442:	d003      	beq.n	44c <tcp_input+0x44c>
 444:	e269      	b.n	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:279

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 446:	4610      	mov	r0, r2
 448:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:281
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
 44c:	2300      	movs	r3, #0
 44e:	67f3      	str	r3, [r6, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:292
        pbuf_free(p);
        return;
      }
    }

    tcp_input_pcb = pcb;
 450:	4b8c      	ldr	r3, [pc, #560]	(684 <tcp_input+0x684>)
tcp_process():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:514
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 452:	4a8b      	ldr	r2, [pc, #556]	(680 <tcp_input+0x680>)
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:292
        pbuf_free(p);
        return;
      }
    }

    tcp_input_pcb = pcb;
 454:	601e      	str	r6, [r3, #0]
tcp_process():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:514
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 456:	7913      	ldrb	r3, [r2, #4]
 458:	f013 0404 	ands.w	r4, r3, #4	; 0x4
 45c:	d013      	beq.n	486 <tcp_input+0x486>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:516
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 45e:	7c33      	ldrb	r3, [r6, #16]
 460:	2b02      	cmp	r3, #2
 462:	d105      	bne.n	470 <tcp_input+0x470>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:517
      if (ackno == pcb->snd_nxt) {
 464:	68d2      	ldr	r2, [r2, #12]
 466:	6db3      	ldr	r3, [r6, #88]
 468:	429a      	cmp	r2, r3
 46a:	f040 81c6 	bne.w	7fa <tcp_input+0x7fa>
 46e:	e258      	b.n	922 <tcp_input+0x922>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:521
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 470:	6892      	ldr	r2, [r2, #8]
 472:	6a73      	ldr	r3, [r6, #36]
 474:	1ad2      	subs	r2, r2, r3
 476:	f100 81c0 	bmi.w	7fa <tcp_input+0x7fa>
 47a:	8d33      	ldrh	r3, [r6, #40]
 47c:	1ad3      	subs	r3, r2, r3
 47e:	2b00      	cmp	r3, #0
 480:	f300 81bb 	bgt.w	7fa <tcp_input+0x7fa>
 484:	e24d      	b.n	922 <tcp_input+0x922>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:542
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 486:	f013 0f02 	tst.w	r3, #2	; 0x2
 48a:	d00e      	beq.n	4aa <tcp_input+0x4aa>
 48c:	7c33      	ldrb	r3, [r6, #16]
 48e:	3b02      	subs	r3, #2
 490:	b2db      	uxtb	r3, r3
 492:	2b01      	cmp	r3, #1
 494:	d909      	bls.n	4aa <tcp_input+0x4aa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:544
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 496:	f896 3022 	ldrb.w	r3, [r6, #34]
 49a:	4630      	mov	r0, r6
 49c:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 4a0:	f886 3022 	strb.w	r3, [r6, #34]
 4a4:	f7ff fffe 	bl	0 <tcp_output>
 4a8:	e0e7      	b.n	67a <tcp_input+0x67a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:549
    return ERR_OK;
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
 4aa:	4b77      	ldr	r3, [pc, #476]	(688 <tcp_input+0x688>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:552
  pcb->keep_cnt_sent = 0;

  tcp_parseopt(pcb);
 4ac:	4630      	mov	r0, r6
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:549
    tcp_ack_now(pcb);
    return ERR_OK;
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
 4ae:	681b      	ldr	r3, [r3, #0]
 4b0:	4c73      	ldr	r4, [pc, #460]	(680 <tcp_input+0x680>)
 4b2:	6333      	str	r3, [r6, #48]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:550
  pcb->keep_cnt_sent = 0;
 4b4:	2300      	movs	r3, #0
 4b6:	f886 309d 	strb.w	r3, [r6, #157]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:552

  tcp_parseopt(pcb);
 4ba:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:555

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 4be:	7c33      	ldrb	r3, [r6, #16]
 4c0:	3b02      	subs	r3, #2
 4c2:	2b07      	cmp	r3, #7
 4c4:	f200 8199 	bhi.w	7fa <tcp_input+0x7fa>
 4c8:	e8df f013 	tbh	[pc, r3, lsl #1]
 4cc:	00840008 	.word	0x00840008
 4d0:	00f400e0 	.word	0x00f400e0
 4d4:	00e00137 	.word	0x00e00137
 4d8:	0185015b 	.word	0x0185015b
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:560
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 4dc:	7923      	ldrb	r3, [r4, #4]
 4de:	4d68      	ldr	r5, [pc, #416]	(680 <tcp_input+0x680>)
 4e0:	f013 0f10 	tst.w	r3, #16	; 0x10
 4e4:	d060      	beq.n	5a8 <tcp_input+0x5a8>
 4e6:	f013 0f02 	tst.w	r3, #2	; 0x2
 4ea:	d05d      	beq.n	5a8 <tcp_input+0x5a8>
 4ec:	6fb3      	ldr	r3, [r6, #120]
 4ee:	68ec      	ldr	r4, [r5, #12]
 4f0:	691a      	ldr	r2, [r3, #16]
 4f2:	7953      	ldrb	r3, [r2, #5]
 4f4:	7910      	ldrb	r0, [r2, #4]
 4f6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 4fa:	7993      	ldrb	r3, [r2, #6]
 4fc:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 500:	79d3      	ldrb	r3, [r2, #7]
 502:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 506:	f7ff fffe 	bl	0 <ntohl>
 50a:	3001      	adds	r0, #1
 50c:	4284      	cmp	r4, r0
 50e:	d14b      	bne.n	5a8 <tcp_input+0x5a8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:562
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 510:	f8b6 306e 	ldrh.w	r3, [r6, #110]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:563
      pcb->rcv_nxt = seqno + 1;
 514:	68a9      	ldr	r1, [r5, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:562
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 516:	3301      	adds	r3, #1
 518:	f8a6 306e 	strh.w	r3, [r6, #110]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:563
      pcb->rcv_nxt = seqno + 1;
 51c:	1c4b      	adds	r3, r1, #1
 51e:	6273      	str	r3, [r6, #36]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:564
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 520:	62f3      	str	r3, [r6, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:565
      pcb->lastack = ackno;
 522:	68eb      	ldr	r3, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:566
      pcb->snd_wnd = tcphdr->wnd;
 524:	682a      	ldr	r2, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:565
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
 526:	64f3      	str	r3, [r6, #76]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:566
      pcb->snd_wnd = tcphdr->wnd;
 528:	7b93      	ldrb	r3, [r2, #14]
 52a:	7bd2      	ldrb	r2, [r2, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:567
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 52c:	3901      	subs	r1, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:566
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 52e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 532:	f8a6 305c 	strh.w	r3, [r6, #92]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:568
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;
 536:	2304      	movs	r3, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:567
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 538:	6631      	str	r1, [r6, #96]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:568
      pcb->state = ESTABLISHED;
 53a:	7433      	strb	r3, [r6, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:571

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 53c:	18f1      	adds	r1, r6, r3
 53e:	8f30      	ldrh	r0, [r6, #56]
 540:	f7ff fffe 	bl	0 <tcp_eff_send_mss>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:576
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 544:	230a      	movs	r3, #10
 546:	4343      	muls	r3, r0
 548:	f8a6 3054 	strh.w	r3, [r6, #84]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:578

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 54c:	f8b6 3052 	ldrh.w	r3, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:571
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 550:	8730      	strh	r0, [r6, #56]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:578

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 552:	2b01      	cmp	r3, #1
 554:	b283      	uxth	r3, r0
 556:	d101      	bne.n	55c <tcp_input+0x55c>
 558:	005b      	lsls	r3, r3, #1
 55a:	b29b      	uxth	r3, r3
 55c:	f8a6 3052 	strh.w	r3, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:580
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 560:	f8b6 3070 	ldrh.w	r3, [r6, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:582
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 564:	6fb0      	ldr	r0, [r6, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:580
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 566:	3b01      	subs	r3, #1
 568:	f8a6 3070 	strh.w	r3, [r6, #112]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:583
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
 56c:	6803      	ldr	r3, [r0, #0]
 56e:	67b3      	str	r3, [r6, #120]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:587

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 570:	b91b      	cbnz	r3, 57a <tcp_input+0x57a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:588
        pcb->rtime = -1;
 572:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 576:	86f3      	strh	r3, [r6, #54]
 578:	e003      	b.n	582 <tcp_input+0x582>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:590
      else {
        pcb->rtime = 0;
 57a:	2300      	movs	r3, #0
 57c:	86f3      	strh	r3, [r6, #54]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:591
        pcb->nrtx = 0;
 57e:	f886 304a 	strb.w	r3, [r6, #74]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:594
      }

      tcp_seg_free(rseg);
 582:	f7ff fffe 	bl	0 <tcp_seg_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:598

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 586:	f8d6 3088 	ldr.w	r3, [r6, #136]
 58a:	b11b      	cbz	r3, 594 <tcp_input+0x594>
 58c:	6970      	ldr	r0, [r6, #20]
 58e:	4631      	mov	r1, r6
 590:	2200      	movs	r2, #0
 592:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:599
      tcp_ack_now(pcb);
 594:	f896 3022 	ldrb.w	r3, [r6, #34]
 598:	4630      	mov	r0, r6
 59a:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 59e:	f886 3022 	strb.w	r3, [r6, #34]
 5a2:	f7ff fffe 	bl	0 <tcp_output>
 5a6:	e128      	b.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:602
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 5a8:	4f35      	ldr	r7, [pc, #212]	(680 <tcp_input+0x680>)
 5aa:	793b      	ldrb	r3, [r7, #4]
 5ac:	f013 0f10 	tst.w	r3, #16	; 0x10
 5b0:	f000 8123 	beq.w	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:604
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 5b4:	683c      	ldr	r4, [r7, #0]
 5b6:	6b3b      	ldr	r3, [r7, #48]
 5b8:	78e0      	ldrb	r0, [r4, #3]
 5ba:	78a2      	ldrb	r2, [r4, #2]
 5bc:	8a3d      	ldrh	r5, [r7, #16]
 5be:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 5c2:	68b9      	ldr	r1, [r7, #8]
 5c4:	9200      	str	r2, [sp, #0]
 5c6:	7860      	ldrb	r0, [r4, #1]
 5c8:	7822      	ldrb	r2, [r4, #0]
 5ca:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 5ce:	9201      	str	r2, [sp, #4]
 5d0:	68f8      	ldr	r0, [r7, #12]
 5d2:	e03e      	b.n	652 <tcp_input+0x652>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:609
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 5d4:	7923      	ldrb	r3, [r4, #4]
 5d6:	482a      	ldr	r0, [pc, #168]	(680 <tcp_input+0x680>)
 5d8:	f013 0410 	ands.w	r4, r3, #16	; 0x10
 5dc:	d040      	beq.n	660 <tcp_input+0x660>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:611
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 5de:	6cf3      	ldr	r3, [r6, #76]
 5e0:	68c7      	ldr	r7, [r0, #12]
 5e2:	43db      	mvns	r3, r3
 5e4:	42fb      	cmn	r3, r7
 5e6:	d424      	bmi.n	632 <tcp_input+0x632>
 5e8:	6db3      	ldr	r3, [r6, #88]
 5ea:	1afb      	subs	r3, r7, r3
 5ec:	2b00      	cmp	r3, #0
 5ee:	dc20      	bgt.n	632 <tcp_input+0x632>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:613
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 5f0:	2304      	movs	r3, #4
 5f2:	7433      	strb	r3, [r6, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:619
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 5f4:	69f3      	ldr	r3, [r6, #28]
 5f6:	b163      	cbz	r3, 612 <tcp_input+0x612>
 5f8:	2200      	movs	r2, #0
 5fa:	6970      	ldr	r0, [r6, #20]
 5fc:	4631      	mov	r1, r6
 5fe:	4798      	blx	r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:620
        if (err != ERR_OK) {
 600:	f010 0fff 	tst.w	r0, #255	; 0xff
 604:	d005      	beq.n	612 <tcp_input+0x612>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:623
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
 606:	2101      	movs	r1, #1
 608:	4630      	mov	r0, r6
 60a:	f7ff fffe 	bl	0 <tcp_abandon>
 60e:	21fb      	movs	r1, #251
 610:	e0f4      	b.n	7fc <tcp_input+0x7fc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:626
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
 612:	f8b6 4052 	ldrh.w	r4, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:629
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 616:	4630      	mov	r0, r6
 618:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:631

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 61c:	2c01      	cmp	r4, #1
 61e:	8f33      	ldrh	r3, [r6, #56]
 620:	d101      	bne.n	626 <tcp_input+0x626>
 622:	005b      	lsls	r3, r3, #1
 624:	b29b      	uxth	r3, r3
 626:	f8a6 3052 	strh.w	r3, [r6, #82]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:633

        if (recv_flags & TF_GOT_FIN) {
 62a:	4b15      	ldr	r3, [pc, #84]	(680 <tcp_input+0x680>)
 62c:	f893 302c 	ldrb.w	r3, [r3, #44]
 630:	e031      	b.n	696 <tcp_input+0x696>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:641
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 632:	4a13      	ldr	r2, [pc, #76]	(680 <tcp_input+0x680>)
 634:	6814      	ldr	r4, [r2, #0]
 636:	6b13      	ldr	r3, [r2, #48]
 638:	78e0      	ldrb	r0, [r4, #3]
 63a:	8a15      	ldrh	r5, [r2, #16]
 63c:	6891      	ldr	r1, [r2, #8]
 63e:	78a2      	ldrb	r2, [r4, #2]
 640:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 644:	9200      	str	r2, [sp, #0]
 646:	7860      	ldrb	r0, [r4, #1]
 648:	7822      	ldrb	r2, [r4, #0]
 64a:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 64e:	9201      	str	r2, [sp, #4]
 650:	4638      	mov	r0, r7
 652:	f103 0210 	add.w	r2, r3, #16	; 0x10
 656:	1869      	adds	r1, r5, r1
 658:	330c      	adds	r3, #12
 65a:	f7ff fffe 	bl	0 <tcp_rst>
 65e:	e0cc      	b.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:644
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 660:	f013 0f02 	tst.w	r3, #2	; 0x2
 664:	f000 80c9 	beq.w	7fa <tcp_input+0x7fa>
 668:	6a73      	ldr	r3, [r6, #36]
 66a:	6882      	ldr	r2, [r0, #8]
 66c:	3b01      	subs	r3, #1
 66e:	429a      	cmp	r2, r3
 670:	f040 80c3 	bne.w	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:646
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 674:	4630      	mov	r0, r6
 676:	f7ff fffe 	bl	0 <tcp_rexmit>
 67a:	4621      	mov	r1, r4
 67c:	e0be      	b.n	7fc <tcp_input+0x7fc>
 67e:	46c0      	nop			(mov r8, r8)
	...
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:652
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 68c:	4630      	mov	r0, r6
 68e:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:653
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 692:	f894 302c 	ldrb.w	r3, [r4, #44]
 696:	f013 0f20 	tst.w	r3, #32	; 0x20
 69a:	f000 80ae 	beq.w	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:654
      tcp_ack_now(pcb);
 69e:	f896 3022 	ldrb.w	r3, [r6, #34]
 6a2:	4630      	mov	r0, r6
 6a4:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 6a8:	f886 3022 	strb.w	r3, [r6, #34]
 6ac:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:655
      pcb->state = CLOSE_WAIT;
 6b0:	2307      	movs	r3, #7
 6b2:	e036      	b.n	722 <tcp_input+0x722>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:659
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
 6b4:	4630      	mov	r0, r6
 6b6:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:660
    if (recv_flags & TF_GOT_FIN) {
 6ba:	f894 302c 	ldrb.w	r3, [r4, #44]
 6be:	4a82      	ldr	r2, [pc, #520]	(8c8 <tcp_input+0x8c8>)
 6c0:	f013 0120 	ands.w	r1, r3, #32	; 0x20
 6c4:	7923      	ldrb	r3, [r4, #4]
 6c6:	d02e      	beq.n	726 <tcp_input+0x726>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:661
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 6c8:	f013 0f10 	tst.w	r3, #16	; 0x10
 6cc:	d01f      	beq.n	70e <tcp_input+0x70e>
 6ce:	68d2      	ldr	r2, [r2, #12]
 6d0:	6db3      	ldr	r3, [r6, #88]
 6d2:	429a      	cmp	r2, r3
 6d4:	d11b      	bne.n	70e <tcp_input+0x70e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:664
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 6d6:	f896 3022 	ldrb.w	r3, [r6, #34]
 6da:	4630      	mov	r0, r6
 6dc:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 6e0:	f886 3022 	strb.w	r3, [r6, #34]
 6e4:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:665
        tcp_pcb_purge(pcb);
 6e8:	4630      	mov	r0, r6
 6ea:	f7ff fffe 	bl	0 <tcp_pcb_purge>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:666
        TCP_RMV(&tcp_active_pcbs, pcb);
 6ee:	4977      	ldr	r1, [pc, #476]	(8cc <tcp_input+0x8cc>)
 6f0:	680a      	ldr	r2, [r1, #0]
 6f2:	42b2      	cmp	r2, r6
 6f4:	d104      	bne.n	700 <tcp_input+0x700>
 6f6:	e057      	b.n	7a8 <tcp_input+0x7a8>
 6f8:	68ca      	ldr	r2, [r1, #12]
 6fa:	b10a      	cbz	r2, 700 <tcp_input+0x700>
 6fc:	42b2      	cmp	r2, r6
 6fe:	d05a      	beq.n	7b6 <tcp_input+0x7b6>
 700:	4b73      	ldr	r3, [pc, #460]	(8d0 <tcp_input+0x8d0>)
 702:	601a      	str	r2, [r3, #0]
 704:	4b72      	ldr	r3, [pc, #456]	(8d0 <tcp_input+0x8d0>)
 706:	6819      	ldr	r1, [r3, #0]
 708:	2900      	cmp	r1, #0
 70a:	d1f5      	bne.n	6f8 <tcp_input+0x6f8>
 70c:	e05c      	b.n	7c8 <tcp_input+0x7c8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:670
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 70e:	f896 3022 	ldrb.w	r3, [r6, #34]
 712:	4630      	mov	r0, r6
 714:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 718:	f886 3022 	strb.w	r3, [r6, #34]
 71c:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:671
        pcb->state = CLOSING;
 720:	2308      	movs	r3, #8
 722:	7433      	strb	r3, [r6, #16]
 724:	e069      	b.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:673
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 726:	f013 0f10 	tst.w	r3, #16	; 0x10
 72a:	d066      	beq.n	7fa <tcp_input+0x7fa>
 72c:	68d2      	ldr	r2, [r2, #12]
 72e:	6db3      	ldr	r3, [r6, #88]
 730:	429a      	cmp	r2, r3
 732:	d162      	bne.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:674
      pcb->state = FIN_WAIT_2;
 734:	2306      	movs	r3, #6
 736:	7433      	strb	r3, [r6, #16]
 738:	e060      	b.n	7fc <tcp_input+0x7fc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:678
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
 73a:	4630      	mov	r0, r6
 73c:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:679
    if (recv_flags & TF_GOT_FIN) {
 740:	f894 302c 	ldrb.w	r3, [r4, #44]
 744:	f013 0f20 	tst.w	r3, #32	; 0x20
 748:	d057      	beq.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:681
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 74a:	f896 3022 	ldrb.w	r3, [r6, #34]
 74e:	4630      	mov	r0, r6
 750:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 754:	f886 3022 	strb.w	r3, [r6, #34]
 758:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:682
      tcp_pcb_purge(pcb);
 75c:	4630      	mov	r0, r6
 75e:	f7ff fffe 	bl	0 <tcp_pcb_purge>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:683
      TCP_RMV(&tcp_active_pcbs, pcb);
 762:	495a      	ldr	r1, [pc, #360]	(8cc <tcp_input+0x8cc>)
 764:	680a      	ldr	r2, [r1, #0]
 766:	42b2      	cmp	r2, r6
 768:	d104      	bne.n	774 <tcp_input+0x774>
 76a:	e01d      	b.n	7a8 <tcp_input+0x7a8>
 76c:	68ca      	ldr	r2, [r1, #12]
 76e:	b10a      	cbz	r2, 774 <tcp_input+0x774>
 770:	42b2      	cmp	r2, r6
 772:	d020      	beq.n	7b6 <tcp_input+0x7b6>
 774:	4b56      	ldr	r3, [pc, #344]	(8d0 <tcp_input+0x8d0>)
 776:	601a      	str	r2, [r3, #0]
 778:	4b55      	ldr	r3, [pc, #340]	(8d0 <tcp_input+0x8d0>)
 77a:	6819      	ldr	r1, [r3, #0]
 77c:	2900      	cmp	r1, #0
 77e:	d1f5      	bne.n	76c <tcp_input+0x76c>
 780:	e022      	b.n	7c8 <tcp_input+0x7c8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:689
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
 782:	4630      	mov	r0, r6
 784:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:690
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 788:	7923      	ldrb	r3, [r4, #4]
 78a:	f013 0f10 	tst.w	r3, #16	; 0x10
 78e:	d034      	beq.n	7fa <tcp_input+0x7fa>
 790:	4b4d      	ldr	r3, [pc, #308]	(8c8 <tcp_input+0x8c8>)
 792:	68da      	ldr	r2, [r3, #12]
 794:	6db3      	ldr	r3, [r6, #88]
 796:	429a      	cmp	r2, r3
 798:	d12f      	bne.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:692
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 79a:	4630      	mov	r0, r6
 79c:	f7ff fffe 	bl	0 <tcp_pcb_purge>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:693
      TCP_RMV(&tcp_active_pcbs, pcb);
 7a0:	494a      	ldr	r1, [pc, #296]	(8cc <tcp_input+0x8cc>)
 7a2:	680a      	ldr	r2, [r1, #0]
 7a4:	42b2      	cmp	r2, r6
 7a6:	d109      	bne.n	7bc <tcp_input+0x7bc>
 7a8:	68f3      	ldr	r3, [r6, #12]
 7aa:	600b      	str	r3, [r1, #0]
 7ac:	e00c      	b.n	7c8 <tcp_input+0x7c8>
 7ae:	68ca      	ldr	r2, [r1, #12]
 7b0:	b122      	cbz	r2, 7bc <tcp_input+0x7bc>
 7b2:	42b2      	cmp	r2, r6
 7b4:	d102      	bne.n	7bc <tcp_input+0x7bc>
 7b6:	68f3      	ldr	r3, [r6, #12]
 7b8:	60cb      	str	r3, [r1, #12]
 7ba:	e005      	b.n	7c8 <tcp_input+0x7c8>
 7bc:	4b44      	ldr	r3, [pc, #272]	(8d0 <tcp_input+0x8d0>)
 7be:	601a      	str	r2, [r3, #0]
 7c0:	4b43      	ldr	r3, [pc, #268]	(8d0 <tcp_input+0x8d0>)
 7c2:	6819      	ldr	r1, [r3, #0]
 7c4:	2900      	cmp	r1, #0
 7c6:	d1f2      	bne.n	7ae <tcp_input+0x7ae>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:695
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 7c8:	4a42      	ldr	r2, [pc, #264]	(8d4 <tcp_input+0x8d4>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:694
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
 7ca:	230a      	movs	r3, #10
 7cc:	7433      	strb	r3, [r6, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:695
      TCP_REG(&tcp_tw_pcbs, pcb);
 7ce:	6813      	ldr	r3, [r2, #0]
 7d0:	60f3      	str	r3, [r6, #12]
 7d2:	6016      	str	r6, [r2, #0]
 7d4:	e011      	b.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:699
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
 7d6:	4630      	mov	r0, r6
 7d8:	f7ff fffe 	bl	0 <tcp_input>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:700
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 7dc:	7923      	ldrb	r3, [r4, #4]
 7de:	493a      	ldr	r1, [pc, #232]	(8c8 <tcp_input+0x8c8>)
 7e0:	f013 0f10 	tst.w	r3, #16	; 0x10
 7e4:	d009      	beq.n	7fa <tcp_input+0x7fa>
 7e6:	68ca      	ldr	r2, [r1, #12]
 7e8:	6db3      	ldr	r3, [r6, #88]
 7ea:	429a      	cmp	r2, r3
 7ec:	d105      	bne.n	7fa <tcp_input+0x7fa>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:703
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 7ee:	f891 302c 	ldrb.w	r3, [r1, #44]
 7f2:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 7f6:	f881 302c 	strb.w	r3, [r1, #44]
 7fa:	2100      	movs	r1, #0
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:294
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
 7fc:	4b36      	ldr	r3, [pc, #216]	(8d8 <tcp_input+0x8d8>)
 7fe:	2200      	movs	r2, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:297
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800:	29fb      	cmp	r1, #251
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:294
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
 802:	601a      	str	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:297
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 804:	d057      	beq.n	8b6 <tcp_input+0x8b6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:298
      if (recv_flags & TF_RESET) {
 806:	4b30      	ldr	r3, [pc, #192]	(8c8 <tcp_input+0x8c8>)
 808:	f893 302c 	ldrb.w	r3, [r3, #44]
 80c:	f013 0f08 	tst.w	r3, #8	; 0x8
 810:	d007      	beq.n	822 <tcp_input+0x822>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:303
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 812:	f8d6 3090 	ldr.w	r3, [r6, #144]
 816:	b13b      	cbz	r3, 828 <tcp_input+0x828>
 818:	6970      	ldr	r0, [r6, #20]
 81a:	f06f 0105 	mvn.w	r1, #5	; 0x5
 81e:	4798      	blx	r3
 820:	e002      	b.n	828 <tcp_input+0x828>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:306
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else if (recv_flags & TF_CLOSED) {
 822:	f013 0f10 	tst.w	r3, #16	; 0x10
 826:	d008      	beq.n	83a <tcp_input+0x83a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:309
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 828:	4631      	mov	r1, r6
 82a:	4828      	ldr	r0, [pc, #160]	(8cc <tcp_input+0x8cc>)
 82c:	f7ff fffe 	bl	0 <tcp_pcb_remove>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:310
        memp_free(MEMP_TCP_PCB, pcb);
 830:	2002      	movs	r0, #2
 832:	4631      	mov	r1, r6
 834:	f7ff fffe 	bl	0 <memp_free>
 838:	e03d      	b.n	8b6 <tcp_input+0x8b6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:316
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 83a:	f8b6 206c 	ldrh.w	r2, [r6, #108]
 83e:	b13a      	cbz	r2, 850 <tcp_input+0x850>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:317
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 840:	f8d6 3080 	ldr.w	r3, [r6, #128]
 844:	b123      	cbz	r3, 850 <tcp_input+0x850>
 846:	6970      	ldr	r0, [r6, #20]
 848:	4631      	mov	r1, r6
 84a:	4798      	blx	r3
 84c:	b2c0      	uxtb	r0, r0
 84e:	e000      	b.n	852 <tcp_input+0x852>
 850:	2000      	movs	r0, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:320
        }
      
        if (recv_data != NULL) {
 852:	4b1d      	ldr	r3, [pc, #116]	(8c8 <tcp_input+0x8c8>)
 854:	6a9a      	ldr	r2, [r3, #40]
 856:	b1da      	cbz	r2, 890 <tcp_input+0x890>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:321
          if(flags & TCP_PSH) {
 858:	791b      	ldrb	r3, [r3, #4]
 85a:	f013 0f08 	tst.w	r3, #8	; 0x8
 85e:	d003      	beq.n	868 <tcp_input+0x868>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:322
            recv_data->flags |= PBUF_FLAG_PUSH;
 860:	7b53      	ldrb	r3, [r2, #13]
 862:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 866:	7353      	strb	r3, [r2, #13]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:326
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 868:	f8d6 5084 	ldr.w	r5, [r6, #132]
 86c:	4c16      	ldr	r4, [pc, #88]	(8c8 <tcp_input+0x8c8>)
 86e:	b13d      	cbz	r5, 880 <tcp_input+0x880>
 870:	6970      	ldr	r0, [r6, #20]
 872:	4631      	mov	r1, r6
 874:	6aa2      	ldr	r2, [r4, #40]
 876:	2300      	movs	r3, #0
 878:	47a8      	blx	r5
 87a:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:329

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 87c:	b930      	cbnz	r0, 88c <tcp_input+0x88c>
 87e:	e007      	b.n	890 <tcp_input+0x890>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:326
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 880:	6aa0      	ldr	r0, [r4, #40]
 882:	2800      	cmp	r0, #0
 884:	d05c      	beq.n	940 <tcp_input+0x940>
 886:	f7ff fffe 	bl	0 <pbuf_free>
 88a:	e059      	b.n	940 <tcp_input+0x940>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:330

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
 88c:	6aa3      	ldr	r3, [r4, #40]
 88e:	67f3      	str	r3, [r6, #124]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:337
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 890:	4b0d      	ldr	r3, [pc, #52]	(8c8 <tcp_input+0x8c8>)
 892:	f893 302c 	ldrb.w	r3, [r3, #44]
 896:	f013 0f20 	tst.w	r3, #32	; 0x20
 89a:	d008      	beq.n	8ae <tcp_input+0x8ae>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:338
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
 89c:	f8d6 4084 	ldr.w	r4, [r6, #132]
 8a0:	b134      	cbz	r4, 8b0 <tcp_input+0x8b0>
 8a2:	2200      	movs	r2, #0
 8a4:	6970      	ldr	r0, [r6, #20]
 8a6:	4631      	mov	r1, r6
 8a8:	4613      	mov	r3, r2
 8aa:	47a0      	blx	r4
 8ac:	b2c0      	uxtb	r0, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:342
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
 8ae:	b910      	cbnz	r0, 8b6 <tcp_input+0x8b6>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:343
          tcp_output(pcb);
 8b0:	4630      	mov	r0, r6
 8b2:	f7ff fffe 	bl	0 <tcp_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:350
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 8b6:	4c04      	ldr	r4, [pc, #16]	(8c8 <tcp_input+0x8c8>)
 8b8:	69a0      	ldr	r0, [r4, #24]
 8ba:	2800      	cmp	r0, #0
 8bc:	d045      	beq.n	94a <tcp_input+0x94a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:352
    {
      pbuf_free(inseg.p);
 8be:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:353
      inseg.p = NULL;
 8c2:	2300      	movs	r3, #0
 8c4:	61a3      	str	r3, [r4, #24]
 8c6:	e040      	b.n	94a <tcp_input+0x94a>
	...
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:366
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 8dc:	7b3b      	ldrb	r3, [r7, #12]
 8de:	7b78      	ldrb	r0, [r7, #13]
 8e0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8e4:	f7ff fffe 	bl	0 <ntohs>
 8e8:	f010 0f04 	tst.w	r0, #4	; 0x4
 8ec:	d115      	bne.n	91a <tcp_input+0x91a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:369
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8ee:	4d18      	ldr	r5, [pc, #96]	(950 <tcp_input+0x950>)
 8f0:	682c      	ldr	r4, [r5, #0]
 8f2:	6b2b      	ldr	r3, [r5, #48]
 8f4:	78e0      	ldrb	r0, [r4, #3]
 8f6:	78a2      	ldrb	r2, [r4, #2]
 8f8:	8a2e      	ldrh	r6, [r5, #16]
 8fa:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8fe:	68a9      	ldr	r1, [r5, #8]
 900:	9200      	str	r2, [sp, #0]
 902:	7860      	ldrb	r0, [r4, #1]
 904:	7822      	ldrb	r2, [r4, #0]
 906:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 90a:	9201      	str	r2, [sp, #4]
 90c:	68e8      	ldr	r0, [r5, #12]
 90e:	f103 0210 	add.w	r2, r3, #16	; 0x10
 912:	1871      	adds	r1, r6, r1
 914:	330c      	adds	r3, #12
 916:	f7ff fffe 	bl	0 <tcp_rst>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:373
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
 91a:	4648      	mov	r0, r9
 91c:	f7ff fffe 	bl	0 <pbuf_free>
 920:	e013      	b.n	94a <tcp_input+0x94a>
tcp_process():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:530
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 922:	4b0b      	ldr	r3, [pc, #44]	(950 <tcp_input+0x950>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:531
      pcb->flags &= ~TF_ACK_DELAY;
 924:	21fa      	movs	r1, #250
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:530
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 926:	f893 202c 	ldrb.w	r2, [r3, #44]
 92a:	f042 0208 	orr.w	r2, r2, #8	; 0x8
 92e:	f883 202c 	strb.w	r2, [r3, #44]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:531
      pcb->flags &= ~TF_ACK_DELAY;
 932:	f896 3022 	ldrb.w	r3, [r6, #34]
 936:	f023 0301 	bic.w	r3, r3, #1	; 0x1
 93a:	f886 3022 	strb.w	r3, [r6, #34]
 93e:	e75d      	b.n	7fc <tcp_input+0x7fc>
 940:	2000      	movs	r0, #0
 942:	e7a5      	b.n	890 <tcp_input+0x890>
tcp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:207
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 944:	4b03      	ldr	r3, [pc, #12]	(954 <tcp_input+0x954>)
 946:	681d      	ldr	r5, [r3, #0]
 948:	e4a9      	b.n	29e <tcp_input+0x29e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/tcp_in.c:378
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
 94a:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
 94e:	46c0      	nop			(mov r8, r8)
	...
