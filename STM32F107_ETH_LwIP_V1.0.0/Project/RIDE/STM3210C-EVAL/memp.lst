
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\memp.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\memp.o

Disassembly of section .text.memp_init:

00000000 <memp_init>:
memp_init():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:272
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
   0:	4b0f      	ldr	r3, [pc, #60]	(40 <memp_init+0x40>)
   2:	2100      	movs	r1, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:261
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
   4:	b530      	push	{r4, r5, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:272
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
   6:	468c      	mov	ip, r1
   8:	f023 0403 	bic.w	r4, r3, #3	; 0x3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:275
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
   c:	4a0d      	ldr	r2, [pc, #52]	(44 <memp_init+0x44>)
   e:	2300      	movs	r3, #0
  10:	5053      	str	r3, [r2, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:277
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  12:	4a0d      	ldr	r2, [pc, #52]	(48 <memp_init+0x48>)
  14:	4618      	mov	r0, r3
  16:	f832 500c 	ldrh.w	r5, [r2, ip]
  1a:	e009      	b.n	30 <memp_init+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:278
      memp->next = memp_tab[i];
  1c:	4a09      	ldr	r2, [pc, #36]	(44 <memp_init+0x44>)
  1e:	5853      	ldr	r3, [r2, r1]
  20:	6023      	str	r3, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:280
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
  22:	4b0a      	ldr	r3, [pc, #40]	(4c <memp_init+0x4c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:279
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
  24:	5054      	str	r4, [r2, r1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:280
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
  26:	f833 300c 	ldrh.w	r3, [r3, ip]
  2a:	18e4      	adds	r4, r4, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:277
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  2c:	1c43      	adds	r3, r0, #1
  2e:	b298      	uxth	r0, r3
  30:	42a8      	cmp	r0, r5
  32:	d3f3      	bcc.n	1c <memp_init+0x1c>
  34:	3104      	adds	r1, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:274
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  36:	2924      	cmp	r1, #36
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:277
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  38:	f10c 0c02 	add.w	ip, ip, #2	; 0x2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:274
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  3c:	d1e6      	bne.n	c <memp_init+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:292
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  3e:	bd30      	pop	{r4, r5, pc}
  40:	00000003 	.word	0x00000003
  44:	0000468c 	.word	0x0000468c
  48:	00000000 	.word	0x00000000
  4c:	00000012 	.word	0x00000012
Disassembly of section .text.memp_malloc:

00000000 <memp_malloc>:
memp_malloc():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:315
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
   0:	2808      	cmp	r0, #8
   2:	d901      	bls.n	8 <memp_malloc+0x8>
   4:	2000      	movs	r0, #0
   6:	e008      	b.n	1a <memp_malloc+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:322
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
   8:	4b04      	ldr	r3, [pc, #16]	(1c <memp_malloc+0x1c>)
   a:	eb03 0280 	add.w	r2, r3, r0, lsl #2
   e:	f8d2 02ac 	ldr.w	r0, [r2, #684]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:324
  
  if (memp != NULL) {
  12:	b110      	cbz	r0, 1a <memp_malloc+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:325
    memp_tab[type] = memp->next;
  14:	6803      	ldr	r3, [r0, #0]
  16:	f8c2 32ac 	str.w	r3, [r2, #684]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:343
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  1a:	4770      	bx	lr
  1c:	000043e0 	.word	0x000043e0
Disassembly of section .text.memp_free:

00000000 <memp_free>:
memp_free():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:353
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
   0:	4602      	mov	r2, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:357
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
   2:	b139      	cbz	r1, 14 <memp_free+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:376
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
   4:	4b04      	ldr	r3, [pc, #16]	(18 <memp_free+0x18>)
   6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   a:	f8d3 22ac 	ldr.w	r2, [r3, #684]
   e:	600a      	str	r2, [r1, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:377
  memp_tab[type] = memp;
  10:	f8c3 12ac 	str.w	r1, [r3, #684]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core/memp.c:384
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  14:	4770      	bx	lr
  16:	46c0      	nop			(mov r8, r8)
  18:	000043e0 	.word	0x000043e0
