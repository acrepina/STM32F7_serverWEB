
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\icmp.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\icmp.o

Disassembly of section .text.icmp_send_response:

00000000 <icmp_send_response>:
icmp_send_response():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:295
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4606      	mov	r6, r0
   6:	460d      	mov	r5, r1
   8:	4690      	mov	r8, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:302
  struct ip_hdr *iphdr;
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
   a:	2001      	movs	r0, #1
   c:	2124      	movs	r1, #36
   e:	2200      	movs	r2, #0
  10:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:304
                 PBUF_RAM);
  if (q == NULL) {
  14:	4607      	mov	r7, r0
  16:	b338      	cbz	r0, 68 <icmp_send_response+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:318
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = q->payload;
  18:	6844      	ldr	r4, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:311
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  1a:	f8d6 9004 	ldr.w	r9, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:319
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = q->payload;
  icmphdr->type = type;
  1e:	7025      	strb	r5, [r4, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:321
  icmphdr->code = code;
  icmphdr->id = 0;
  20:	2500      	movs	r5, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:320
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  22:	f884 8001 	strb.w	r8, [r4, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:321
  icmphdr->id = 0;
  26:	7125      	strb	r5, [r4, #4]
  28:	7165      	strb	r5, [r4, #5]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:322
  icmphdr->seqno = 0;
  2a:	71a5      	strb	r5, [r4, #6]
  2c:	71e5      	strb	r5, [r4, #7]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:325

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
  2e:	6840      	ldr	r0, [r0, #4]
  30:	221c      	movs	r2, #28
  32:	6871      	ldr	r1, [r6, #4]
  34:	3008      	adds	r0, #8
  36:	f7ff fffe 	bl	0 <memcpy>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:329
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  3a:	70a5      	strb	r5, [r4, #2]
  3c:	70e5      	strb	r5, [r4, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:330
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
  3e:	8979      	ldrh	r1, [r7, #10]
  40:	4620      	mov	r0, r4
  42:	f7ff fffe 	bl	0 <inet_chksum>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:336
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  46:	2301      	movs	r3, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:330
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
  48:	70a0      	strb	r0, [r4, #2]
  4a:	f3c0 200f 	ubfx	r0, r0, #8, #16
  4e:	70e0      	strb	r0, [r4, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:336
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  50:	4629      	mov	r1, r5
  52:	9301      	str	r3, [sp, #4]
  54:	4638      	mov	r0, r7
  56:	f109 020c 	add.w	r2, r9, #12	; 0xc
  5a:	33fe      	adds	r3, #254
  5c:	9500      	str	r5, [sp, #0]
  5e:	f7ff fffe 	bl	0 <ip_output>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:337
  pbuf_free(q);
  62:	4638      	mov	r0, r7
  64:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:338
}
  68:	e8bd 83fe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, pc}
Disassembly of section .text.icmp_time_exceeded:

00000000 <icmp_time_exceeded>:
icmp_time_exceeded():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:279
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
   0:	460a      	mov	r2, r1
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:280
  icmp_send_response(p, ICMP_TE, t);
   4:	210b      	movs	r1, #11
   6:	f7ff fffe 	bl	0 <icmp_time_exceeded>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:281
}
   a:	bd10      	pop	{r4, pc}
Disassembly of section .text.icmp_dest_unreach:

00000000 <icmp_dest_unreach>:
icmp_dest_unreach():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:265
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
   0:	460a      	mov	r2, r1
   2:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:266
  icmp_send_response(p, ICMP_DUR, t);
   4:	2103      	movs	r1, #3
   6:	f7ff fffe 	bl	0 <icmp_dest_unreach>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:267
}
   a:	bd10      	pop	{r4, pc}
Disassembly of section .text.icmp_input:

00000000 <icmp_input>:
icmp_input():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:79
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:93

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
   4:	6845      	ldr	r5, [r0, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:79
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
   6:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:94
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
   8:	782b      	ldrb	r3, [r5, #0]
   a:	7868      	ldrb	r0, [r5, #1]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:79
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
   c:	b085      	sub	sp, #20
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:94
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
   e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:79
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  12:	468b      	mov	fp, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:94
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
  14:	f7ff fffe 	bl	0 <ntohs>
  18:	f3c0 2003 	ubfx	r0, r0, #8, #4
  1c:	ea4f 0980 	mov.w	r9, r0, lsl #2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:95
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  20:	f1c9 0300 	rsb	r3, r9, #0	; 0x0
  24:	fa1f fa83 	uxth.w	sl, r3
  28:	4630      	mov	r0, r6
  2a:	fa0f f18a 	sxth.w	r1, sl
  2e:	f7ff fffe 	bl	0 <pbuf_header>
  32:	2800      	cmp	r0, #0
  34:	f040 80af 	bne.w	196 <icmp_input+0x196>
  38:	8933      	ldrh	r3, [r6, #8]
  3a:	2b03      	cmp	r3, #3
  3c:	f240 80ab 	bls.w	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:104

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  40:	6873      	ldr	r3, [r6, #4]
  42:	781b      	ldrb	r3, [r3, #0]
  44:	2b08      	cmp	r3, #8
  46:	f040 80a6 	bne.w	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:111
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&iphdr->dest)) {
  4a:	7c6a      	ldrb	r2, [r5, #17]
  4c:	7c2b      	ldrb	r3, [r5, #16]
  4e:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
  52:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  56:	7caa      	ldrb	r2, [r5, #18]
  58:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  5c:	7cea      	ldrb	r2, [r5, #19]
  5e:	ea43 6802 	orr.w	r8, r3, r2, lsl #24
  62:	f7ff fffe 	bl	0 <ntohl>
  66:	4607      	mov	r7, r0
  68:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
  6c:	f7ff fffe 	bl	0 <ntohl>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:117
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
  70:	4659      	mov	r1, fp
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:111
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&iphdr->dest)) {
  72:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:117
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&iphdr->dest, inp)) {
  74:	f105 0010 	add.w	r0, r5, #16	; 0x10
  78:	f7ff fffe 	bl	0 <ip_addr_isbroadcast>
  7c:	2800      	cmp	r0, #0
  7e:	f040 808a 	bne.w	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:122
        accepted = 0;
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
  82:	ea07 0308 	and.w	r3, r7, r8
  86:	42a3      	cmp	r3, r4
  88:	f000 8085 	beq.w	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:131
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8c:	8933      	ldrh	r3, [r6, #8]
  8e:	2b07      	cmp	r3, #7
  90:	f240 8081 	bls.w	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:135
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  94:	4630      	mov	r0, r6
  96:	f7ff fffe 	bl	0 <inet_chksum_pbuf>
  9a:	2800      	cmp	r0, #0
  9c:	d17b      	bne.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:143
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  9e:	4630      	mov	r0, r6
  a0:	2122      	movs	r1, #34
  a2:	f7ff fffe 	bl	0 <pbuf_header>
  a6:	b300      	cbz	r0, ea <icmp_input+0xea>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:149
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  a8:	4630      	mov	r0, r6
  aa:	4649      	mov	r1, r9
  ac:	f7ff fffe 	bl	0 <pbuf_header>
  b0:	4602      	mov	r2, r0
  b2:	2800      	cmp	r0, #0
  b4:	d16f      	bne.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:154
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  b6:	3002      	adds	r0, #2
  b8:	8931      	ldrh	r1, [r6, #8]
  ba:	f7ff fffe 	bl	0 <pbuf_alloc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:155
      if (r == NULL) {
  be:	4604      	mov	r4, r0
  c0:	2800      	cmp	r0, #0
  c2:	d068      	beq.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:162
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  c4:	4631      	mov	r1, r6
  c6:	f7ff fffe 	bl	0 <pbuf_copy>
  ca:	f010 0fff 	tst.w	r0, #255	; 0xff
  ce:	d162      	bne.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:168
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  d0:	4620      	mov	r0, r4
  d2:	fa0f f18a 	sxth.w	r1, sl
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:166
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
  d6:	6865      	ldr	r5, [r4, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:168
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  d8:	f7ff fffe 	bl	0 <pbuf_header>
  dc:	2800      	cmp	r0, #0
  de:	d15a      	bne.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:173
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  e0:	4630      	mov	r0, r6
  e2:	f7ff fffe 	bl	0 <pbuf_free>
  e6:	4626      	mov	r6, r4
  e8:	e006      	b.n	f8 <icmp_input+0xf8>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:178
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  ea:	4630      	mov	r0, r6
  ec:	f06f 0121 	mvn.w	r1, #33	; 0x21
  f0:	f7ff fffe 	bl	0 <pbuf_header>
  f4:	2800      	cmp	r0, #0
  f6:	d14e      	bne.n	196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:188
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    tmpaddr.addr = iphdr->src.addr;
  f8:	7b6b      	ldrb	r3, [r5, #13]
  fa:	7b29      	ldrb	r1, [r5, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:189
    iphdr->src.addr = iphdr->dest.addr;
  fc:	7c6a      	ldrb	r2, [r5, #17]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:188
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    tmpaddr.addr = iphdr->src.addr;
  fe:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 102:	7bab      	ldrb	r3, [r5, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:187
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
 104:	6870      	ldr	r0, [r6, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:188
    tmpaddr.addr = iphdr->src.addr;
 106:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 10a:	7beb      	ldrb	r3, [r5, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:189
    iphdr->src.addr = iphdr->dest.addr;
 10c:	2400      	movs	r4, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:188
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    tmpaddr.addr = iphdr->src.addr;
 10e:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:189
    iphdr->src.addr = iphdr->dest.addr;
 112:	7c2b      	ldrb	r3, [r5, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:190
    iphdr->dest.addr = tmpaddr.addr;
 114:	7429      	strb	r1, [r5, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:189
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    tmpaddr.addr = iphdr->src.addr;
    iphdr->src.addr = iphdr->dest.addr;
 116:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 11a:	7caa      	ldrb	r2, [r5, #18]
 11c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 120:	7cea      	ldrb	r2, [r5, #19]
 122:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 126:	f3c3 2207 	ubfx	r2, r3, #8, #8
 12a:	732b      	strb	r3, [r5, #12]
 12c:	736a      	strb	r2, [r5, #13]
 12e:	f3c3 4207 	ubfx	r2, r3, #16, #8
 132:	0e1b      	lsrs	r3, r3, #24
 134:	73eb      	strb	r3, [r5, #15]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:190
    iphdr->dest.addr = tmpaddr.addr;
 136:	f3c1 2307 	ubfx	r3, r1, #8, #8
 13a:	746b      	strb	r3, [r5, #17]
 13c:	f3c1 4307 	ubfx	r3, r1, #16, #8
 140:	0e09      	lsrs	r1, r1, #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:189
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
    tmpaddr.addr = iphdr->src.addr;
    iphdr->src.addr = iphdr->dest.addr;
 142:	73aa      	strb	r2, [r5, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:190
    iphdr->dest.addr = tmpaddr.addr;
 144:	74e9      	strb	r1, [r5, #19]
 146:	74ab      	strb	r3, [r5, #18]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:191
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 148:	7004      	strb	r4, [r0, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:198

/* This part of code has been modified by ST's MCD Application Team */
/* To use the Checksum Offload Engine for the putgoing ICMP packets,
   the ICMP checksum field should be set to 0, this is required only for Tx ICMP*/
#ifdef CHECKSUM_BY_HARDWARE
    iecho->chksum = 0;
 14a:	7084      	strb	r4, [r0, #2]
 14c:	70c4      	strb	r4, [r0, #3]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:209
      iecho->chksum += htons(ICMP_ECHO << 8);
    }	
#endif

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 14e:	7a2b      	ldrb	r3, [r5, #8]
 150:	7a68      	ldrb	r0, [r5, #9]
 152:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 156:	f7ff fffe 	bl	0 <ntohs>
 15a:	ea6f 6000 	mvn.w	r0, r0, lsl #24
 15e:	ea6f 6010 	mvn.w	r0, r0, lsr #24
 162:	b280      	uxth	r0, r0
 164:	f7ff fffe 	bl	0 <htons>
 168:	7228      	strb	r0, [r5, #8]
 16a:	f3c0 200f 	ubfx	r0, r0, #8, #16
 16e:	7268      	strb	r0, [r5, #9]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:210
    IPH_CHKSUM_SET(iphdr, 0);
 170:	72ac      	strb	r4, [r5, #10]
 172:	72ec      	strb	r4, [r5, #11]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:221
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 174:	4630      	mov	r0, r6
 176:	4649      	mov	r1, r9
 178:	f7ff fffe 	bl	0 <pbuf_header>
 17c:	4602      	mov	r2, r0
 17e:	b950      	cbnz	r0, 196 <icmp_input+0x196>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:225
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
 180:	2301      	movs	r3, #1
 182:	9000      	str	r0, [sp, #0]
 184:	9301      	str	r3, [sp, #4]
 186:	4630      	mov	r0, r6
 188:	f105 010c 	add.w	r1, r5, #12	; 0xc
 18c:	33fe      	adds	r3, #254
 18e:	f8cd b008 	str.w	fp, [sp, #8]
 192:	f7ff fffe 	bl	0 <ip_output_if>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:247
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 196:	4630      	mov	r0, r6
 198:	f7ff fffe 	bl	0 <pbuf_free>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Utilities\lwip-1.3.1\src\core\ipv4/icmp.c:252
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 19c:	b005      	add	sp, #20
 19e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1a2:	46c0      	nop			(mov r8, r8)
