
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32f10x_flash.o:     file format elf32-littlearm
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Project\RIDE\STM3210C-EVAL\stm32f10x_flash.o

Disassembly of section .text.FLASH_SetLatency:

00000000 <FLASH_SetLatency>:
FLASH_SetLatency():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:133
  
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Read the ACR register */
  tmpreg = FLASH->ACR;  
   0:	4b03      	ldr	r3, [pc, #12]	(10 <FLASH_SetLatency+0x10>)
   2:	681a      	ldr	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:136
  
  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
   4:	f002 0238 	and.w	r2, r2, #56	; 0x38
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:137
  tmpreg |= FLASH_Latency;
   8:	4310      	orrs	r0, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:140
  
  /* Write the ACR register */
  FLASH->ACR = tmpreg;
   a:	6018      	str	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:141
}
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_HalfCycleAccessCmd:

00000000 <FLASH_HalfCycleAccessCmd>:
FLASH_HalfCycleAccessCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:157
{
  /* Check the parameters */
  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
  
  /* Enable or disable the Half cycle access */
  FLASH->ACR &= ACR_HLFCYA_Mask;
   0:	4a04      	ldr	r2, [pc, #16]	(14 <FLASH_HalfCycleAccessCmd+0x14>)
   2:	6813      	ldr	r3, [r2, #0]
   4:	f023 0308 	bic.w	r3, r3, #8	; 0x8
   8:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:158
  FLASH->ACR |= FLASH_HalfCycleAccess;
   a:	6813      	ldr	r3, [r2, #0]
   c:	4318      	orrs	r0, r3
   e:	6010      	str	r0, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:159
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
  14:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_PrefetchBufferCmd:

00000000 <FLASH_PrefetchBufferCmd>:
FLASH_PrefetchBufferCmd():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:175
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
   0:	4a04      	ldr	r2, [pc, #16]	(14 <FLASH_PrefetchBufferCmd+0x14>)
   2:	6813      	ldr	r3, [r2, #0]
   4:	f023 0310 	bic.w	r3, r3, #16	; 0x10
   8:	6013      	str	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:176
  FLASH->ACR |= FLASH_PrefetchBuffer;
   a:	6813      	ldr	r3, [r2, #0]
   c:	4318      	orrs	r0, r3
   e:	6010      	str	r0, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:177
}
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
  14:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_Unlock:

00000000 <FLASH_Unlock>:
FLASH_Unlock():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:187
  * @retval None
  */
void FLASH_Unlock(void)
{
  /* Authorize the FPEC Access */
  FLASH->KEYR = FLASH_KEY1;
   0:	4b03      	ldr	r3, [pc, #12]	(10 <FLASH_Unlock+0x10>)
   2:	4a04      	ldr	r2, [pc, #16]	(14 <FLASH_Unlock+0x14>)
   4:	605a      	str	r2, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:188
  FLASH->KEYR = FLASH_KEY2;
   6:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
   a:	605a      	str	r2, [r3, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:189
}
   c:	4770      	bx	lr
   e:	46c0      	nop			(mov r8, r8)
  10:	40022000 	.word	0x40022000
  14:	45670123 	.word	0x45670123
Disassembly of section .text.FLASH_Lock:

00000000 <FLASH_Lock>:
FLASH_Lock():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:199
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the Lock Bit to lock the FPEC and the FCR */
  FLASH->CR |= CR_LOCK_Set;
   0:	4a02      	ldr	r2, [pc, #8]	(c <FLASH_Lock+0xc>)
   2:	6913      	ldr	r3, [r2, #16]
   4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   8:	6113      	str	r3, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:200
}
   a:	4770      	bx	lr
   c:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetUserOptionByte:

00000000 <FLASH_GetUserOptionByte>:
FLASH_GetUserOptionByte():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:649
  *   and RST_STDBY(Bit2).
  */
uint32_t FLASH_GetUserOptionByte(void)
{
  /* Return the User Option Byte */
  return (uint32_t)(FLASH->OBR >> 2);
   0:	4b01      	ldr	r3, [pc, #4]	(8 <FLASH_GetUserOptionByte+0x8>)
   2:	69d8      	ldr	r0, [r3, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:650
}
   4:	0880      	lsrs	r0, r0, #2
   6:	4770      	bx	lr
   8:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetWriteProtectionOptionByte:

00000000 <FLASH_GetWriteProtectionOptionByte>:
FLASH_GetWriteProtectionOptionByte():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:660
  * @retval The FLASH Write Protection  Option Bytes Register value
  */
uint32_t FLASH_GetWriteProtectionOptionByte(void)
{
  /* Return the Falsh write protection Register value */
  return (uint32_t)(FLASH->WRPR);
   0:	4b01      	ldr	r3, [pc, #4]	(8 <FLASH_GetWriteProtectionOptionByte+0x8>)
   2:	6a18      	ldr	r0, [r3, #32]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:661
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetReadOutProtectionStatus:

00000000 <FLASH_GetReadOutProtectionStatus>:
FLASH_GetReadOutProtectionStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:671
  * @retval FLASH ReadOut Protection Status(SET or RESET)
  */
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;
  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
   0:	4b02      	ldr	r3, [pc, #8]	(c <FLASH_GetReadOutProtectionStatus+0xc>)
   2:	69d8      	ldr	r0, [r3, #28]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:680
  else
  {
    readoutstatus = RESET;
  }
  return readoutstatus;
}
   4:	f3c0 0040 	ubfx	r0, r0, #1, #1
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetPrefetchBufferStatus:

00000000 <FLASH_GetPrefetchBufferStatus>:
FLASH_GetPrefetchBufferStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:691
  */
FlagStatus FLASH_GetPrefetchBufferStatus(void)
{
  FlagStatus bitstatus = RESET;
  
  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
   0:	4b02      	ldr	r3, [pc, #8]	(c <FLASH_GetPrefetchBufferStatus+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:701
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
  return bitstatus; 
}
   4:	f3c0 1040 	ubfx	r0, r0, #5, #1
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_ITConfig:

00000000 <FLASH_ITConfig>:
FLASH_ITConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:718
void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if(NewState != DISABLE)
   0:	b121      	cbz	r1, c <FLASH_ITConfig+0xc>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:721
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
   2:	4a05      	ldr	r2, [pc, #20]	(18 <FLASH_ITConfig+0x18>)
   4:	6913      	ldr	r3, [r2, #16]
   6:	ea40 0303 	orr.w	r3, r0, r3
   a:	e003      	b.n	14 <FLASH_ITConfig+0x14>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:726
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
   c:	4a02      	ldr	r2, [pc, #8]	(18 <FLASH_ITConfig+0x18>)
   e:	6913      	ldr	r3, [r2, #16]
  10:	ea23 0300 	bic.w	r3, r3, r0
  14:	6113      	str	r3, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:728
  }
}
  16:	4770      	bx	lr
  18:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetFlagStatus:

00000000 <FLASH_GetFlagStatus>:
FLASH_GetFlagStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:746
FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   0:	2801      	cmp	r0, #1
   2:	d104      	bne.n	e <FLASH_GetFlagStatus+0xe>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:748
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
   4:	4b05      	ldr	r3, [pc, #20]	(1c <FLASH_GetFlagStatus+0x1c>)
   6:	69db      	ldr	r3, [r3, #28]
   8:	f003 0001 	and.w	r0, r3, #1	; 0x1
   c:	e005      	b.n	1a <FLASH_GetFlagStatus+0x1a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:759
      bitstatus = RESET;
    }
  }
  else
  {
   if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   e:	4b03      	ldr	r3, [pc, #12]	(1c <FLASH_GetFlagStatus+0x1c>)
  10:	68db      	ldr	r3, [r3, #12]
  12:	4218      	tst	r0, r3
  14:	bf0c      	ite	eq
  16:	2000      	moveq	r0, #0
  18:	2001      	movne	r0, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:770
      bitstatus = RESET;
    }
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus;
}
  1a:	4770      	bx	lr
  1c:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_ClearFlag:

00000000 <FLASH_ClearFlag>:
FLASH_ClearFlag():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:787
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
   0:	4b01      	ldr	r3, [pc, #4]	(8 <FLASH_ClearFlag+0x8>)
   2:	60d8      	str	r0, [r3, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:788
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_GetStatus:

00000000 <FLASH_GetStatus>:
FLASH_GetStatus():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:800
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   0:	4a09      	ldr	r2, [pc, #36]	(28 <FLASH_GetStatus+0x28>)
   2:	68d3      	ldr	r3, [r2, #12]
   4:	f013 0f01 	tst.w	r3, #1	; 0x1
   8:	d001      	beq.n	e <FLASH_GetStatus+0xe>
   a:	2001      	movs	r0, #1
   c:	e00b      	b.n	26 <FLASH_GetStatus+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:806
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
   e:	68d3      	ldr	r3, [r2, #12]
  10:	f013 0f04 	tst.w	r3, #4	; 0x4
  14:	d001      	beq.n	1a <FLASH_GetStatus+0x1a>
  16:	2002      	movs	r0, #2
  18:	e005      	b.n	26 <FLASH_GetStatus+0x26>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:812
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
  1a:	68d3      	ldr	r3, [r2, #12]
  1c:	f013 0f10 	tst.w	r3, #16	; 0x10
  20:	bf14      	ite	ne
  22:	2003      	movne	r0, #3
  24:	2004      	moveq	r0, #4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:824
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
}
  26:	4770      	bx	lr
  28:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_WaitForLastOperation:

00000000 <FLASH_WaitForLastOperation>:
FLASH_WaitForLastOperation():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:833
  * @param  Timeout: FLASH progamming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:837
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetStatus();
   4:	f7ff fffe 	bl	0 <FLASH_WaitForLastOperation>
   8:	e00c      	b.n	24 <FLASH_WaitForLastOperation+0x24>
delay():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:860
  * @param  None
  * @retval None
  */
static void delay(void)
{
  __IO uint32_t i = 0;
   a:	2300      	movs	r3, #0
   c:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:861
  for(i = 0xFF; i != 0; i--)
   e:	33ff      	adds	r3, #255
  10:	e001      	b.n	16 <FLASH_WaitForLastOperation+0x16>
  12:	9b01      	ldr	r3, [sp, #4]
  14:	3b01      	subs	r3, #1
  16:	9301      	str	r3, [sp, #4]
  18:	9b01      	ldr	r3, [sp, #4]
  1a:	2b00      	cmp	r3, #0
  1c:	d1f9      	bne.n	12 <FLASH_WaitForLastOperation+0x12>
FLASH_WaitForLastOperation():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:842
  status = FLASH_GetStatus();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    delay();
    status = FLASH_GetStatus();
  1e:	f7ff fffe 	bl	0 <FLASH_WaitForLastOperation>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:843
    Timeout--;
  22:	3c01      	subs	r4, #1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:839
  FLASH_Status status = FLASH_COMPLETE;
   
  /* Check for the Flash Status */
  status = FLASH_GetStatus();
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  24:	2801      	cmp	r0, #1
  26:	d102      	bne.n	2e <FLASH_WaitForLastOperation+0x2e>
  28:	2c00      	cmp	r4, #0
  2a:	d1ee      	bne.n	a <FLASH_WaitForLastOperation+0xa>
  2c:	e000      	b.n	30 <FLASH_WaitForLastOperation+0x30>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:845
  {
    delay();
    status = FLASH_GetStatus();
    Timeout--;
  }
  if(Timeout == 0x00 )
  2e:	b904      	cbnz	r4, 32 <FLASH_WaitForLastOperation+0x32>
  30:	2005      	movs	r0, #5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:851
  {
    status = FLASH_TIMEOUT;
  }
  /* Return the operation status */
  return status;
}
  32:	bd1c      	pop	{r2, r3, r4, pc}
Disassembly of section .text.FLASH_UserOptionByteConfig:

00000000 <FLASH_UserOptionByteConfig>:
FLASH_UserOptionByteConfig():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:606
  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
  * FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:615
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
   4:	4b13      	ldr	r3, [pc, #76]	(54 <FLASH_UserOptionByteConfig+0x54>)
   6:	4c14      	ldr	r4, [pc, #80]	(58 <FLASH_UserOptionByteConfig+0x58>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:606
  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
  * FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
{
   8:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:615
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
   a:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:616
  FLASH->OPTKEYR = FLASH_KEY2;
   c:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:619
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  10:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:616
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
  12:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:606
  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
  * FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
{
  14:	460e      	mov	r6, r1
  16:	4617      	mov	r7, r2
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:619
  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  18:	f7ff fffe 	bl	0 <FLASH_UserOptionByteConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:621
  
  if(status == FLASH_COMPLETE)
  1c:	2804      	cmp	r0, #4
  1e:	d116      	bne.n	4e <FLASH_UserOptionByteConfig+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:624
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
  20:	6923      	ldr	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:626
           
    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
  22:	4a0e      	ldr	r2, [pc, #56]	(5c <FLASH_UserOptionByteConfig+0x5c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:624
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
  24:	f043 0310 	orr.w	r3, r3, #16	; 0x10
  28:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:626
           
    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
  2a:	f045 03f8 	orr.w	r3, r5, #248	; 0xf8
  2e:	ea46 0303 	orr.w	r3, r6, r3
  32:	ea47 0303 	orr.w	r3, r7, r3
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:629
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  36:	300b      	adds	r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:626
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
           
    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
  38:	8053      	strh	r3, [r2, #2]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:629
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  3a:	f7ff fffe 	bl	0 <FLASH_UserOptionByteConfig>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:630
    if(status != FLASH_TIMEOUT)
  3e:	2805      	cmp	r0, #5
  40:	d005      	beq.n	4e <FLASH_UserOptionByteConfig+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:633
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
  42:	6922      	ldr	r2, [r4, #16]
  44:	f641 73ef 	movw	r3, #8175	; 0x1fef
  48:	ea02 0303 	and.w	r3, r2, r3
  4c:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:638
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
  4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  52:	46c0      	nop			(mov r8, r8)
  54:	45670123 	.word	0x45670123
  58:	40022000 	.word	0x40022000
  5c:	1ffff800 	.word	0x1ffff800
Disassembly of section .text.FLASH_ReadOutProtection:

00000000 <FLASH_ReadOutProtection>:
FLASH_ReadOutProtection():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:538
  *   This parameter can be: ENABLE or DISABLE.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:542
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  status = FLASH_WaitForLastOperation(EraseTimeout);
   4:	f640 70ff 	movw	r0, #4095	; 0xfff
   8:	f7ff fffe 	bl	0 <FLASH_ReadOutProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:543
  if(status == FLASH_COMPLETE)
   c:	2804      	cmp	r0, #4
   e:	d13c      	bne.n	8a <FLASH_ReadOutProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:546
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  10:	4c1e      	ldr	r4, [pc, #120]	(8c <FLASH_ReadOutProtection+0x8c>)
  12:	4b1f      	ldr	r3, [pc, #124]	(90 <FLASH_ReadOutProtection+0x90>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:551
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  14:	f640 70ff 	movw	r0, #4095	; 0xfff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:546
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  18:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:547
    FLASH->OPTKEYR = FLASH_KEY2;
  1a:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
  1e:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:548
    FLASH->CR |= CR_OPTER_Set;
  20:	6923      	ldr	r3, [r4, #16]
  22:	f043 0320 	orr.w	r3, r3, #32	; 0x20
  26:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:549
    FLASH->CR |= CR_STRT_Set;
  28:	6923      	ldr	r3, [r4, #16]
  2a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  2e:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:551
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  30:	f7ff fffe 	bl	0 <FLASH_ReadOutProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:552
    if(status == FLASH_COMPLETE)
  34:	2804      	cmp	r0, #4
  36:	d120      	bne.n	7a <FLASH_ReadOutProtection+0x7a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:555
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
  38:	6923      	ldr	r3, [r4, #16]
  3a:	f641 72df 	movw	r2, #8159	; 0x1fdf
  3e:	ea03 0202 	and.w	r2, r3, r2
  42:	6122      	str	r2, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:557
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
  44:	6923      	ldr	r3, [r4, #16]
  46:	f043 0310 	orr.w	r3, r3, #16	; 0x10
  4a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:558
      if(NewState != DISABLE)
  4c:	b11d      	cbz	r5, 56 <FLASH_ReadOutProtection+0x56>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:560
      {
        OB->RDP = 0x00;
  4e:	4b11      	ldr	r3, [pc, #68]	(94 <FLASH_ReadOutProtection+0x94>)
  50:	f04f 0200 	mov.w	r2, #0	; 0x0
  54:	e002      	b.n	5c <FLASH_ReadOutProtection+0x5c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:564
      }
      else
      {
        OB->RDP = RDP_Key;  
  56:	4b0f      	ldr	r3, [pc, #60]	(94 <FLASH_ReadOutProtection+0x94>)
  58:	f04f 02a5 	mov.w	r2, #165	; 0xa5
  5c:	801a      	strh	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:567
      }
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(EraseTimeout); 
  5e:	f640 70ff 	movw	r0, #4095	; 0xfff
  62:	f7ff fffe 	bl	0 <FLASH_ReadOutProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:569
    
      if(status != FLASH_TIMEOUT)
  66:	2805      	cmp	r0, #5
  68:	d00f      	beq.n	8a <FLASH_ReadOutProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:572
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
  6a:	4908      	ldr	r1, [pc, #32]	(8c <FLASH_ReadOutProtection+0x8c>)
  6c:	f641 73ef 	movw	r3, #8175	; 0x1fef
  70:	690a      	ldr	r2, [r1, #16]
  72:	ea02 0303 	and.w	r3, r2, r3
  76:	610b      	str	r3, [r1, #16]
  78:	e007      	b.n	8a <FLASH_ReadOutProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:577
      }
    }
    else 
    {
      if(status != FLASH_TIMEOUT)
  7a:	2805      	cmp	r0, #5
  7c:	d005      	beq.n	8a <FLASH_ReadOutProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:580
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= CR_OPTER_Reset;
  7e:	6922      	ldr	r2, [r4, #16]
  80:	f641 73df 	movw	r3, #8159	; 0x1fdf
  84:	ea02 0303 	and.w	r3, r2, r3
  88:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:586
      }
    }
  }
  /* Return the protection operation Status */
  return status;      
}
  8a:	bd70      	pop	{r4, r5, r6, pc}
  8c:	40022000 	.word	0x40022000
  90:	45670123 	.word	0x45670123
  94:	1ffff800 	.word	0x1ffff800
Disassembly of section .text.FLASH_EnableWriteProtection:

00000000 <FLASH_EnableWriteProtection>:
FLASH_EnableWriteProtection():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:465
  *     @arg FLASH_WRProt_AllPages
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:480
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   4:	200f      	movs	r0, #15
   6:	f7ff fffe 	bl	0 <FLASH_EnableWriteProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:482
  
  if(status == FLASH_COMPLETE)
   a:	2804      	cmp	r0, #4
   c:	d13d      	bne.n	8a <FLASH_EnableWriteProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:485
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
   e:	4a1f      	ldr	r2, [pc, #124]	(8c <FLASH_EnableWriteProtection+0x8c>)
  10:	4b1f      	ldr	r3, [pc, #124]	(90 <FLASH_EnableWriteProtection+0x90>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:473
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  12:	43e4      	mvns	r4, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:485
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  14:	6093      	str	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:486
    FLASH->OPTKEYR = FLASH_KEY2;
  16:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
  1a:	6093      	str	r3, [r2, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:487
    FLASH->CR |= CR_OPTPG_Set;
  1c:	6913      	ldr	r3, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:474
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  1e:	b2e1      	uxtb	r1, r4
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:487
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
  20:	f043 0310 	orr.w	r3, r3, #16	; 0x10
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:488
    if(WRP0_Data != 0xFF)
  24:	29ff      	cmp	r1, #255
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:487
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
  26:	6113      	str	r3, [r2, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:488
    if(WRP0_Data != 0xFF)
  28:	d006      	beq.n	38 <FLASH_EnableWriteProtection+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:490
    {
      OB->WRP0 = WRP0_Data;
  2a:	4b1a      	ldr	r3, [pc, #104]	(94 <FLASH_EnableWriteProtection+0x94>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:493
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  2c:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:490
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
    if(WRP0_Data != 0xFF)
    {
      OB->WRP0 = WRP0_Data;
  2e:	8119      	strh	r1, [r3, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:493
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  30:	f7ff fffe 	bl	0 <FLASH_EnableWriteProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:495
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
  34:	2804      	cmp	r0, #4
  36:	d11f      	bne.n	78 <FLASH_EnableWriteProtection+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:475
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  38:	f3c4 2207 	ubfx	r2, r4, #8, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:495
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
  3c:	2aff      	cmp	r2, #255
  3e:	d006      	beq.n	4e <FLASH_EnableWriteProtection+0x4e>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:497
    {
      OB->WRP1 = WRP1_Data;
  40:	4b14      	ldr	r3, [pc, #80]	(94 <FLASH_EnableWriteProtection+0x94>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:500
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  42:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:497
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
  44:	815a      	strh	r2, [r3, #10]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:500
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  46:	f7ff fffe 	bl	0 <FLASH_EnableWriteProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:502
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
  4a:	2804      	cmp	r0, #4
  4c:	d114      	bne.n	78 <FLASH_EnableWriteProtection+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:476
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
  4e:	f3c4 4207 	ubfx	r2, r4, #16, #8
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:502
      OB->WRP1 = WRP1_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
  52:	2aff      	cmp	r2, #255
  54:	d006      	beq.n	64 <FLASH_EnableWriteProtection+0x64>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:504
    {
      OB->WRP2 = WRP2_Data;
  56:	4b0f      	ldr	r3, [pc, #60]	(94 <FLASH_EnableWriteProtection+0x94>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:507
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  58:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:504
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
  5a:	819a      	strh	r2, [r3, #12]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:507
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  5c:	f7ff fffe 	bl	0 <FLASH_EnableWriteProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:510
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
  60:	2804      	cmp	r0, #4
  62:	d109      	bne.n	78 <FLASH_EnableWriteProtection+0x78>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:477
  
  FLASH_Pages = (uint32_t)(~FLASH_Pages);
  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
  64:	0e20      	lsrs	r0, r4, #24
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:510
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
  66:	28ff      	cmp	r0, #255
  68:	d101      	bne.n	6e <FLASH_EnableWriteProtection+0x6e>
  6a:	2004      	movs	r0, #4
  6c:	e006      	b.n	7c <FLASH_EnableWriteProtection+0x7c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:512
    {
      OB->WRP3 = WRP3_Data;
  6e:	4b09      	ldr	r3, [pc, #36]	(94 <FLASH_EnableWriteProtection+0x94>)
  70:	81d8      	strh	r0, [r3, #14]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:515
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  72:	200f      	movs	r0, #15
  74:	f7ff fffe 	bl	0 <FLASH_EnableWriteProtection>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:518
    }
          
    if(status != FLASH_TIMEOUT)
  78:	2805      	cmp	r0, #5
  7a:	d006      	beq.n	8a <FLASH_EnableWriteProtection+0x8a>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:521
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
  7c:	4903      	ldr	r1, [pc, #12]	(8c <FLASH_EnableWriteProtection+0x8c>)
  7e:	f641 73ef 	movw	r3, #8175	; 0x1fef
  82:	690a      	ldr	r2, [r1, #16]
  84:	ea02 0303 	and.w	r3, r2, r3
  88:	610b      	str	r3, [r1, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:526
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
  8a:	bd10      	pop	{r4, pc}
  8c:	40022000 	.word	0x40022000
  90:	45670123 	.word	0x45670123
  94:	1ffff800 	.word	0x1ffff800
Disassembly of section .text.FLASH_ProgramOptionByteData:

00000000 <FLASH_ProgramOptionByteData>:
FLASH_ProgramOptionByteData():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:423
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:427
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   4:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:423
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
{
   6:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:427
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   8:	f7ff fffe 	bl	0 <FLASH_ProgramOptionByteData>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:428
  if(status == FLASH_COMPLETE)
   c:	2804      	cmp	r0, #4
   e:	d115      	bne.n	3c <FLASH_ProgramOptionByteData+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:431
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  10:	4c0b      	ldr	r4, [pc, #44]	(40 <FLASH_ProgramOptionByteData+0x40>)
  12:	4b0c      	ldr	r3, [pc, #48]	(44 <FLASH_ProgramOptionByteData+0x44>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:438
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
    *(__IO uint16_t*)Address = Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  14:	300b      	adds	r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:431
  assert_param(IS_OB_DATA_ADDRESS(Address));
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  16:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:432
    FLASH->OPTKEYR = FLASH_KEY2;
  18:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
  1c:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:434
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
  1e:	6923      	ldr	r3, [r4, #16]
  20:	f043 0310 	orr.w	r3, r3, #16	; 0x10
  24:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:435
    *(__IO uint16_t*)Address = Data;
  26:	8035      	strh	r5, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:438
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  28:	f7ff fffe 	bl	0 <FLASH_ProgramOptionByteData>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:439
    if(status != FLASH_TIMEOUT)
  2c:	2805      	cmp	r0, #5
  2e:	d005      	beq.n	3c <FLASH_ProgramOptionByteData+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:442
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
  30:	6922      	ldr	r2, [r4, #16]
  32:	f641 73ef 	movw	r3, #8175	; 0x1fef
  36:	ea02 0303 	and.w	r3, r2, r3
  3a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:447
    }
  }    
  /* Return the Option Byte Data Program Status */
  return status;
}
  3c:	bd70      	pop	{r4, r5, r6, pc}
  3e:	46c0      	nop			(mov r8, r8)
  40:	40022000 	.word	0x40022000
  44:	45670123 	.word	0x45670123
Disassembly of section .text.FLASH_ProgramHalfWord:

00000000 <FLASH_ProgramHalfWord>:
FLASH_ProgramHalfWord():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:389
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:394
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   4:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:389
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
{
   6:	460d      	mov	r5, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:394
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   8:	f7ff fffe 	bl	0 <FLASH_ProgramHalfWord>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:396
  
  if(status == FLASH_COMPLETE)
   c:	2804      	cmp	r0, #4
   e:	d110      	bne.n	32 <FLASH_ProgramHalfWord+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:399
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
  10:	4c08      	ldr	r4, [pc, #32]	(34 <FLASH_ProgramHalfWord+0x34>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:403
  
    *(__IO uint16_t*)Address = Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  12:	300b      	adds	r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:399
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
  14:	6923      	ldr	r3, [r4, #16]
  16:	f043 0301 	orr.w	r3, r3, #1	; 0x1
  1a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:401
  
    *(__IO uint16_t*)Address = Data;
  1c:	8035      	strh	r5, [r6, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:403
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  1e:	f7ff fffe 	bl	0 <FLASH_ProgramHalfWord>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:404
    if(status != FLASH_TIMEOUT)
  22:	2805      	cmp	r0, #5
  24:	d005      	beq.n	32 <FLASH_ProgramHalfWord+0x32>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:407
    {
      /* if the program operation is completed, disable the PG Bit */
      FLASH->CR &= CR_PG_Reset;
  26:	6922      	ldr	r2, [r4, #16]
  28:	f641 73fe 	movw	r3, #8190	; 0x1ffe
  2c:	ea02 0303 	and.w	r3, r2, r3
  30:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:412
    }
  } 
  /* Return the Program Status */
  return status;
}
  32:	bd70      	pop	{r4, r5, r6, pc}
  34:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_ProgramWord:

00000000 <FLASH_ProgramWord>:
FLASH_ProgramWord():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:332
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:334
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
   2:	2300      	movs	r3, #0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:332
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
   4:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:339
  __IO uint32_t tmp = 0;

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   6:	200f      	movs	r0, #15
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:332
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
   8:	460e      	mov	r6, r1
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:334
  FLASH_Status status = FLASH_COMPLETE;
  __IO uint32_t tmp = 0;
   a:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:339

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
   c:	f7ff fffe 	bl	0 <FLASH_ProgramWord>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:341
  
  if(status == FLASH_COMPLETE)
  10:	2804      	cmp	r0, #4
  12:	d11b      	bne.n	4c <FLASH_ProgramWord+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:345
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
  14:	4c0e      	ldr	r4, [pc, #56]	(50 <FLASH_ProgramWord+0x50>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:349
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  16:	300b      	adds	r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:345
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
  18:	6923      	ldr	r3, [r4, #16]
  1a:	f043 0301 	orr.w	r3, r3, #1	; 0x1
  1e:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:347
  
    *(__IO uint16_t*)Address = (uint16_t)Data;
  20:	b2b3      	uxth	r3, r6
  22:	802b      	strh	r3, [r5, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:349
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
  24:	f7ff fffe 	bl	0 <FLASH_ProgramWord>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:351
 
    if(status == FLASH_COMPLETE)
  28:	2804      	cmp	r0, #4
  2a:	d107      	bne.n	3c <FLASH_ProgramWord+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:355
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      tmp = Address + 2;
  2c:	1cab      	adds	r3, r5, #2
  2e:	9301      	str	r3, [sp, #4]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:357

      *(__IO uint16_t*) tmp = Data >> 16;
  30:	9a01      	ldr	r2, [sp, #4]
  32:	0c33      	lsrs	r3, r6, #16
  34:	8013      	strh	r3, [r2, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:360
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  36:	300b      	adds	r0, #11
  38:	f7ff fffe 	bl	0 <FLASH_ProgramWord>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:370
        FLASH->CR &= CR_PG_Reset;
      }
    }
    else
    {
      if (status != FLASH_TIMEOUT)
  3c:	2805      	cmp	r0, #5
  3e:	d005      	beq.n	4c <FLASH_ProgramWord+0x4c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:373
      {
        /* Disable the PG Bit */
        FLASH->CR &= CR_PG_Reset;
  40:	6922      	ldr	r2, [r4, #16]
  42:	f641 73fe 	movw	r3, #8190	; 0x1ffe
  46:	ea02 0303 	and.w	r3, r2, r3
  4a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:379
      }
     }
  }
  /* Return the Program Status */
  return status;
}
  4c:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
  4e:	46c0      	nop			(mov r8, r8)
  50:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_EraseOptionBytes:

00000000 <FLASH_EraseOptionBytes>:
FLASH_EraseOptionBytes():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:276
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EraseOptionBytes(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:280
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
   2:	f640 70ff 	movw	r0, #4095	; 0xfff
   6:	f7ff fffe 	bl	0 <FLASH_EraseOptionBytes>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:281
  if(status == FLASH_COMPLETE)
   a:	2804      	cmp	r0, #4
   c:	d12c      	bne.n	68 <FLASH_EraseOptionBytes+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:284
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
   e:	4c17      	ldr	r4, [pc, #92]	(6c <FLASH_EraseOptionBytes+0x6c>)
  10:	4b17      	ldr	r3, [pc, #92]	(70 <FLASH_EraseOptionBytes+0x70>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:291
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  12:	f640 70ff 	movw	r0, #4095	; 0xfff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:284
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
  16:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:285
    FLASH->OPTKEYR = FLASH_KEY2;
  18:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
  1c:	60a3      	str	r3, [r4, #8]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:288
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
  1e:	6923      	ldr	r3, [r4, #16]
  20:	f043 0320 	orr.w	r3, r3, #32	; 0x20
  24:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:289
    FLASH->CR |= CR_STRT_Set;
  26:	6923      	ldr	r3, [r4, #16]
  28:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  2c:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:291
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  2e:	f7ff fffe 	bl	0 <FLASH_EraseOptionBytes>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:293
    
    if(status == FLASH_COMPLETE)
  32:	2804      	cmp	r0, #4
  34:	d110      	bne.n	58 <FLASH_EraseOptionBytes+0x58>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:296
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
  36:	6922      	ldr	r2, [r4, #16]
  38:	f641 73df 	movw	r3, #8159	; 0x1fdf
  3c:	ea02 0303 	and.w	r3, r2, r3
  40:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:299
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
  42:	6923      	ldr	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:301
      /* Disable the Read protection */
      OB->RDP= RDP_Key; 
  44:	f04f 02a5 	mov.w	r2, #165	; 0xa5
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:299
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
  48:	f043 0310 	orr.w	r3, r3, #16	; 0x10
  4c:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:301
      /* Disable the Read protection */
      OB->RDP= RDP_Key; 
  4e:	4b09      	ldr	r3, [pc, #36]	(74 <FLASH_EraseOptionBytes+0x74>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:303
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  50:	300b      	adds	r0, #11
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:301
      FLASH->CR &= CR_OPTER_Reset;
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
      /* Disable the Read protection */
      OB->RDP= RDP_Key; 
  52:	801a      	strh	r2, [r3, #0]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:303
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
  54:	f7ff fffe 	bl	0 <FLASH_EraseOptionBytes>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:313
        FLASH->CR &= CR_OPTPG_Reset;
      }
    }
    else
    {
      if (status != FLASH_TIMEOUT)
  58:	2805      	cmp	r0, #5
  5a:	d005      	beq.n	68 <FLASH_EraseOptionBytes+0x68>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:316
      {
        /* Disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
  5c:	6922      	ldr	r2, [r4, #16]
  5e:	f641 73ef 	movw	r3, #8175	; 0x1fef
  62:	ea02 0303 	and.w	r3, r2, r3
  66:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:322
      }
    }  
  }
  /* Return the erase status */
  return status;
}
  68:	bd10      	pop	{r4, pc}
  6a:	46c0      	nop			(mov r8, r8)
  6c:	40022000 	.word	0x40022000
  70:	45670123 	.word	0x45670123
  74:	1ffff800 	.word	0x1ffff800
Disassembly of section .text.FLASH_EraseAllPages:

00000000 <FLASH_EraseAllPages>:
FLASH_EraseAllPages():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:242
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_EraseAllPages(void)
{
   0:	b510      	push	{r4, lr}
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:245
  FLASH_Status status = FLASH_COMPLETE;
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
   2:	f640 70ff 	movw	r0, #4095	; 0xfff
   6:	f7ff fffe 	bl	0 <FLASH_EraseAllPages>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:247
  
  if(status == FLASH_COMPLETE)
   a:	2804      	cmp	r0, #4
   c:	d114      	bne.n	38 <FLASH_EraseAllPages+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:250
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
   e:	4c0b      	ldr	r4, [pc, #44]	(3c <FLASH_EraseAllPages+0x3c>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:254
     FLASH->CR |= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  10:	f640 70ff 	movw	r0, #4095	; 0xfff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:250
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
  14:	6923      	ldr	r3, [r4, #16]
  16:	f043 0304 	orr.w	r3, r3, #4	; 0x4
  1a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:251
     FLASH->CR |= CR_STRT_Set;
  1c:	6923      	ldr	r3, [r4, #16]
  1e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  22:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:254
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  24:	f7ff fffe 	bl	0 <FLASH_EraseAllPages>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:255
    if(status != FLASH_TIMEOUT)
  28:	2805      	cmp	r0, #5
  2a:	d005      	beq.n	38 <FLASH_EraseAllPages+0x38>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:258
    {
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= CR_MER_Reset;
  2c:	6922      	ldr	r2, [r4, #16]
  2e:	f641 73fb 	movw	r3, #8187	; 0x1ffb
  32:	ea02 0303 	and.w	r3, r2, r3
  36:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:263
    }
  }	   
  /* Return the Erase Status */
  return status;
}
  38:	bd10      	pop	{r4, pc}
  3a:	46c0      	nop			(mov r8, r8)
  3c:	40022000 	.word	0x40022000
Disassembly of section .text.FLASH_ErasePage:

00000000 <FLASH_ErasePage>:
FLASH_ErasePage():
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:209
  * @param  Page_Address: The page address to be erased.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:214
  FLASH_Status status = FLASH_COMPLETE;
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Page_Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
   4:	f640 70ff 	movw	r0, #4095	; 0xfff
   8:	f7ff fffe 	bl	0 <FLASH_ErasePage>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:216
  
  if(status == FLASH_COMPLETE)
   c:	2804      	cmp	r0, #4
   e:	d115      	bne.n	3c <FLASH_ErasePage+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:219
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
  10:	4c0b      	ldr	r4, [pc, #44]	(40 <FLASH_ErasePage+0x40>)
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:224
    FLASH->AR = Page_Address; 
    FLASH->CR|= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  12:	f640 70ff 	movw	r0, #4095	; 0xfff
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:219
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
  16:	6923      	ldr	r3, [r4, #16]
  18:	f043 0302 	orr.w	r3, r3, #2	; 0x2
  1c:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:220
    FLASH->AR = Page_Address; 
  1e:	6165      	str	r5, [r4, #20]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:221
    FLASH->CR|= CR_STRT_Set;
  20:	6923      	ldr	r3, [r4, #16]
  22:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  26:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:224
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
  28:	f7ff fffe 	bl	0 <FLASH_ErasePage>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:225
    if(status != FLASH_TIMEOUT)
  2c:	2805      	cmp	r0, #5
  2e:	d005      	beq.n	3c <FLASH_ErasePage+0x3c>
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:228
    {
      /* if the erase operation is completed, disable the PER Bit */
      FLASH->CR &= CR_PER_Reset;
  30:	6922      	ldr	r2, [r4, #16]
  32:	f641 73fd 	movw	r3, #8189	; 0x1ffd
  36:	ea02 0303 	and.w	r3, r2, r3
  3a:	6123      	str	r3, [r4, #16]
D:\SAV\STM32_Documents\lwip_st_STM32\STM32F107_ETH_LwIP_V1.0.0\Libraries\STM32F10x_StdPeriph_Driver\src/stm32f10x_flash.c:233
    }
  }
  /* Return the Erase Status */
  return status;
}
  3c:	bd70      	pop	{r4, r5, r6, pc}
  3e:	46c0      	nop			(mov r8, r8)
  40:	40022000 	.word	0x40022000
